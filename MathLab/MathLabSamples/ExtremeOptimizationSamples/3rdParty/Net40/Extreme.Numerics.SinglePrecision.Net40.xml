<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Extreme.Numerics.SinglePrecision.Net40</name>
    </assembly>
    <members>
        <member name="M:Extreme.Mathematics.Generic.ComplexSingleOperations.Sqrt(System.Single)">
            <summary>
            Returns the first square root of a real number.
            </summary>
            <param name="a">A real number</param>
            <returns>The square root of <paramref name="a"/>
            that is either real and positive, or imaginary with
            a positive imaginary part.</returns>
        </member>
        <member name="M:Extreme.Mathematics.Generic.ComplexSingleOperations.Asinh(Extreme.Mathematics.Complex{System.Single})">
            <summary>
            Gets the inverse hyperbolic sine of a complex number.
            </summary>
            <param name="z">A complex number.</param>
            <returns>The inverse hyperbolic sine of the complex number.</returns>
        </member>
        <member name="M:Extreme.Mathematics.Generic.ComplexSingleOperations.Acosh(Extreme.Mathematics.Complex{System.Single})">
            <summary>
            Gets the inverse hyperbolic cosine of a complex number.
            </summary>
            <param name="z">A complex number.</param>
            <returns>The inverse hyperbolic cosine of the complex number.</returns>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slamch(System.Char)">
            <summary>
            <para>
            Determines double precision machine parameters.</para>
            </summary>
            <param name="cmach">
            <pre>
            Specifies the value to be returned by DLAMCH:
            = 'E' or 'e',   DLAMCH := eps
            = 'S' or 's ,   DLAMCH := sfmin
            = 'B' or 'b',   DLAMCH := base
            = 'P' or 'p',   DLAMCH := eps*base
            = 'N' or 'n',   DLAMCH := t
            = 'R' or 'r',   DLAMCH := rnd
            = 'M' or 'm',   DLAMCH := emin
            = 'U' or 'u',   DLAMCH := rmin
            = 'L' or 'l',   DLAMCH := emax
            = 'O' or 'o',   DLAMCH := rmax
            where
            eps   = relative machine precision
            sfmin = safe minimum, such that 1/sfmin does not overflow
            base  = base of the machine
            prec  = eps*base
            t     = number of (base) digits in the mantissa
            rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
            emin  = minimum exponent before (gradual) underflow
            rmin  = underflow threshold - base**(emin-1)
            emax  = largest exponent before overflow
            rmax  = overflow threshold  - (base**emax)*(1-eps)
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slamc3(System.Single,System.Single)">
            <summary>
            </summary>
            <param name="a">
            <pre>
            A is a DOUBLE PRECISION
            </pre>
            </param>
            <param name="b">
            <pre>
            B is a DOUBLE PRECISION
            The values A and B.
            </pre>
            </param>
            <remarks>
            <pre>
            DLAMC3  is intended to force  A  and  B  to be stored prior to doing
            the addition of  A  and  B ,  for use in situations where optimizers
            might hold one of these in a register.
            </pre>
            <para>Authors: 
             LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ieeeck(System.Int32,System.Single,System.Single)">
            <summary>
            <para>
            Is called from the ILAENV to verify that Infinity and
            possibly NaN arithmetic is safe (i.</para>
            </summary>
            <param name="ispec">
            <code>
            ISPEC is INTEGER
            Specifies whether to test just for inifinity arithmetic
            or whether to test for infinity and NaN arithmetic.
            = 0: Verify infinity arithmetic only.
            = 1: Verify infinity and NaN arithmetic.
            </code>
            </param>
            <param name="zero">
            <code>
            ZERO is REAL
            Must contain the value 0.0
            This is passed to prevent the compiler from optimizing
            away this code.
            </code>
            </param>
            <param name="one">
            <code>
            ONE is REAL
            Must contain the value 1.0
            This is passed to prevent the compiler from optimizing
            away this code.
            VALUE:  INTEGER
             = 0:  Arithmetic failed to produce the correct answers
             = 1:  Arithmetic produced the correct answers
            </code>
            </param>
            <remarks>
            <para>
            <code>
            e. will not trap).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Iparmq(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Program sets problem and machine dependent parameters
                 useful for xHSEQR and its subroutines.</para>
            </summary>
            <param name="ispec">
            <code>
            ISPEC is integer scalar
                ISPEC specifies which tunable parameter IPARMQ should
                return.
                ISPEC=12: (INMIN)  Matrices of order nmin or less
                          are sent directly to xLAHQR, the implicit
                          double shift QR algorithm.  NMIN must be
                          at least 11.
                ISPEC=13: (INWIN)  Size of the deflation window.
                          This is best set greater than or equal to
                          the number of simultaneous shifts NS.
                          Larger matrices benefit from larger deflation
                          windows.
                ISPEC=14: (INIBL) Determines when to stop nibbling and
                          invest in an (expensive) multi-shift QR sweep.
                          If the aggressive early deflation subroutine
                          finds LD converged eigenvalues from an order
                          NW deflation window and LD.GT.(NW*NIBBLE)/100,
                          then the next QR sweep is skipped and early
                          deflation is applied immediately to the
                          remaining active diagonal block.  Setting
                          IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a
                          multi-shift QR sweep whenever early deflation
                          finds a converged eigenvalue.  Setting
                          IPARMQ(ISPEC=14) greater than or equal to 100
                          prevents TTQRE from skipping a multi-shift
                          QR sweep.
                ISPEC=15: (NSHFTS) The number of simultaneous shifts in
                          a multi-shift QR iteration.
                ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the
                          following meanings.
                          0:  During the multi-shift QR sweep,
                              xLAQR5 does not accumulate reflections and
                              does not use matrix-matrix multiply to
                              update the far-from-diagonal matrix
                              entries.
                          1:  During the multi-shift QR sweep,
                              xLAQR5 and/or xLAQRaccumulates reflections and uses
                              matrix-matrix multiply to update the
                              far-from-diagonal matrix entries.
                          2:  During the multi-shift QR sweep.
                              xLAQR5 accumulates reflections and takes
                              advantage of 2-by-2 block structure during
                              matrix-matrix multiplies.
                          (If xTRMM is slower than xGEMM, then
                          IPARMQ(ISPEC=16)=1 may be more efficient than
                          IPARMQ(ISPEC=16)=2 despite the greater level of
                          arithmetic work implied by the latter choice.)
            </code>
            </param>
            <param name="name">
            <code>
            NAME is character string
                 Name of the calling subroutine
            </code>
            </param>
            <param name="opts">
            <code>
            OPTS is character string
                 This is a concatenation of the string arguments to
                 TTQRE.
            </code>
            </param>
            <param name="n">
            <code>
            N is integer scalar
                 N is the order of the Hessenberg matrix H.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
                 It is assumed that H is already upper triangular
                 in rows and columns 1:ILO-1 and IHI+1:N.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is integer scalar
                 The amount of workspace available.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It is called whenever
                 ILAENV is called with 12 &amp;lt;= ISPEC &amp;lt;= 16
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Little is known about how best to choose these parameters.
            It is possible to use different values of the parameters
            for each of CHSEQR, DHSEQR, SHSEQR and ZHSEQR.
            It is probably best to choose different parameters for
            different matrices and different parameters at different
            times during the iteration, but this has not been
            implemented --- yet.
            The best choices of most of the parameters depend
            in an ill-understood way on the relative execution
            rate of xLAQR3 and xLAQR5 and on the nature of each
            particular eigenvalue problem.  Experiment may be the
            only practical way to determine which choices are most
            effective.
            Following is a list of default values supplied by IPARMQ.
            These defaults may be adjusted in order to attain better
            performance in any particular computational environment.
            IPARMQ(ISPEC=12) The xLAHQR vs xLAQR0 crossover point.
                             Default: 75. (Must be at least 11.)
            IPARMQ(ISPEC=13) Recommended deflation window size.
                             This depends on ILO, IHI and NS, the
                             number of simultaneous shifts returned
                             by IPARMQ(ISPEC=15).  The default for
                             (IHI-ILO+1).LE.500 is NS.  The default
                             for (IHI-ILO+1).GT.500 is 3*NS/2.
            IPARMQ(ISPEC=14) Nibble crossover point.  Default: 14.
            IPARMQ(ISPEC=15) Number of simultaneous shifts, NS.
                             a multi-shift QR iteration.
                             If IHI-ILO+1 is ...
                             greater than      ...but less    ... the
                             or equal to ...      than        default is
                                     0               30       NS =   2+
                                    30               60       NS =   4+
                                    60              150       NS =  10
                                   150              590       NS =  **
                                   590             3000       NS =  64
                                  3000             6000       NS = 128
                                  6000             infinity   NS = 256
                         (+)  By default matrices of this order are
                              passed to the implicit double shift routine
                              xLAHQR.  See IPARMQ(ISPEC=12) above.   These
                              values of NS are used only in case of a rare
                              xLAHQR failure.
                         (**) The asterisks (**) indicate an ad-hoc
                              function increasing from 10 to 64.
            IPARMQ(ISPEC=16) Select structured matrix multiply.
                             (See ISPEC=16 above for details.)
                             Default: 3.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ilaenv(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Is called from the LAPACK routines to choose problem-dependent
            parameters for the local environment.</para>
            </summary>
            <param name="ispec">
            <code>
            ISPEC is INTEGER
            Specifies the parameter to be returned as the value of
            ILAENV.
            = 1: the optimal blocksize; if this value is 1, an unblocked
                 algorithm will give the best performance.
            = 2: the minimum block size for which the block routine
                 should be used; if the usable block size is less than
                 this value, an unblocked routine should be used.
            = 3: the crossover point (in a block routine, for N less
                 than this value, an unblocked routine should be used)
            = 4: the number of shifts, used in the nonsymmetric
                 eigenvalue routines (DEPRECATED)
            = 5: the minimum column dimension for blocking to be used;
                 rectangular blocks must have dimension at least k by m,
                 where k is given by ILAENV(2,...) and m by ILAENV(5,...)
            = 6: the crossover point for the SVD (when reducing an m by n
                 matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
                 this value, a QR factorization is used first to reduce
                 the matrix to a triangular form.)
            = 7: the number of processors
            = 8: the crossover point for the multishift QR method
                 for nonsymmetric eigenvalue problems (DEPRECATED)
            = 9: maximum size of the subproblems at the bottom of the
                 computation tree in the divide-and-conquer algorithm
                 (used by xGELSD and xGESDD)
            =10: ieee NaN arithmetic can be trusted not to trap
            =11: infinity arithmetic can be trusted not to trap
            12 &amp;lt;= ISPEC &amp;lt;= 16:
                 xHSEQR or one of its subroutines,
                 see IPARMQ for detailed explanation
            </code>
            </param>
            <param name="name">
            <code>
            NAME is CHARACTER*(*)
            The name of the calling subroutine, in either upper case or
            lower case.
            </code>
            </param>
            <param name="opts">
            <code>
            OPTS is CHARACTER*(*)
            The character options to the subroutine NAME, concatenated
            into a single character string.  For example, UPLO = 'U',
            TRANS = 'T', and DIAG = 'N' for a triangular routine would
            be specified as OPTS = 'UTN'.
            </code>
            </param>
            <param name="n1">
            <code>
            N1 is INTEGER
            </code>
            </param>
            <param name="n2">
            <code>
            N2 is INTEGER
            </code>
            </param>
            <param name="n3">
            <code>
            N3 is INTEGER
            </code>
            </param>
            <param name="n4">
            <code>
            N4 is INTEGER
            Problem dimensions for the subroutine NAME; these may not all
            be required.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            See ISPEC for a description of
            the parameters.
            ILAENV returns an INTEGER
            if ILAENV >= 0: ILAENV returns the value of the parameter specified by ISPEC
            if ILAENV &amp;lt; 0:  if ILAENV = -k, the k-th argument had an illegal value.
            This version provides a set of parameters which should give good,
            but not optimal, performance on many of the currently available
            computers.  Users are encouraged to modify this subroutine to set
            the tuning parameters for their particular machine using the option
            and problem size information in the arguments.
            This routine will not function correctly if it is converted to all
            lower case.  Converting it to all upper case is allowed.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The following conventions have been used when calling ILAENV from the
            LAPACK routines:
            1)  OPTS is a concatenation of all of the character options to
                subroutine NAME, in the same order that they appear in the
                argument list for NAME, even if they are not used in determining
                the value of the parameter specified by ISPEC.
            2)  The problem dimensions N1, N2, N3, N4 are specified in the order
                that they appear in the argument list for NAME.  N1 is used
                first, N2 second, and so on, and unused problem dimensions are
                passed a value of -1.
            3)  The parameter value returned by ILAENV is checked for validity in
                the calling subroutine.  For example, ILAENV is used to retrieve
                the optimal blocksize for STRTRI as follows:
                NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
                IF( NB.LE.1 ) NB = MAX( 1, N )
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ilaslr(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Scans A for its last non-zero row.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ilaslc(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Scans A for its last non-zero column.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Icmax1(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Finds the index of the element whose real part has maximum
            absolute value.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of elements in the vector CX.
            </code>
            </param>
            <param name="cx">
            <code>
            CX is COMPLEX array, dimension (N)
            The vector whose elements will be summed.
            </code>
            <code>
            INCX is INTEGER
            The spacing between successive values of CX.  INCX >= 1.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Based on ICAMAX from Level 1 BLAS.
            The change is to use the 'genuine' absolute value.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Nick Higham for use with CLACON.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ilaclr(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Scans A for its last non-zero row.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ilaclc(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Scans A for its last non-zero column.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clacn2(System.Int32,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Single@,System.Int32@,Extreme.Collections.Array1D{System.Int32})">
            <summary>
            <para>
            Estimates the 1-norm of a square, complex matrix A.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix.  N >= 1.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array, dimension (N)
            On the final return, V = A*W,  where  EST = norm(V)/norm(W)
            (W is not returned).
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX array, dimension (N)
            On an intermediate return, X should be overwritten by
                  A * X,   if KASE=1,
                  A**H * X,  if KASE=2,
            where A**H is the conjugate transpose of A, and CLACN2 must be
            re-called with all the other parameters unchanged.
            </code>
            </param>
            <param name="est">
            <code>
            EST is REAL
            On entry with KASE = 1 or 2 and ISAVE(1) = 3, EST should be
            unchanged from the previous call to CLACN2.
            On exit, EST is an estimate (a lower bound) for norm(A).
            </code>
            </param>
            <param name="kase">
            <code>
            KASE is INTEGER
            On the initial call to CLACN2, KASE should be 0.
            On an intermediate return, KASE will be 1 or 2, indicating
            whether X should be overwritten by A * X  or A**H * X.
            On the final return from CLACN2, KASE will again be 0.
            </code>
            </param>
            <param name="isave">
            <code>
            ISAVE is INTEGER array, dimension (3)
            ISAVE is used to save variables between calls to SLACN2
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Reverse communication is used for evaluating matrix-vector products.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Originally named CONEST, dated March 16, 1988.
            Last modified:  April, 1999
            This is a thread safe version of CLACON, which uses the array ISAVE
            in place of a SAVE statement, as follows:
               CLACON     CLACN2
                JUMP     ISAVE(1)
                J        ISAVE(2)
                ITER     ISAVE(3)
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Nick Higham, University of Manchester
            </para>
            <h4> References:</h4>
            <para>
             N.J. Higham, "FORTRAN codes for estimating the one-norm of
             a real or complex matrix, with applications to condition estimation",
             ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cladiv(Extreme.Mathematics.Complex{System.Single},Extreme.Mathematics.Complex{System.Single})">
            <summary>
            <para>
            := X / Y, where X and Y are complex.</para>
            </summary>
            <param name="x">
            <code>
            X is COMPLEX
            </code>
            </param>
            <param name="y">
            <code>
            Y is COMPLEX
            The complex scalars X and Y.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The computation of X / Y
            will not overflow on an intermediary step unless the results
            overflows.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clatbs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Single@,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves one of the triangular systems
               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
            with scaling to prevent overflow, where A is an upper or lower
            triangular band matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the operation applied to A.
            = 'N':  Solve A * x = s*b     (No transpose)
            = 'T':  Solve A**T * x = s*b  (Transpose)
            = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="normin">
            <code>
            NORMIN is CHARACTER*1
            Specifies whether CNORM has been set or not.
            = 'Y':  CNORM contains the column norms on entry
            = 'N':  CNORM is not set on entry.  On exit, the norms will
                    be computed and stored in CNORM.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of subdiagonals or superdiagonals in the
            triangular matrix A.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first KD+1 rows of the array. The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX array, dimension (N)
            On entry, the right hand side b of the triangular system.
            On exit, X is overwritten by the solution vector x.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL
            The scaling factor s for the triangular system
               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
            If SCALE = 0, the matrix A is singular or badly scaled, and
            the vector x is an exact or approximate solution to A*x = 0.
            </code>
            </param>
            <param name="cnorm">
            <code>
            CNORM is REAL array, dimension (N)
            If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
            contains the norm of the off-diagonal part of the j-th column
            of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
            to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
            must be greater than or equal to the 1-norm.
            If NORMIN = 'N', CNORM is an output argument and CNORM(j)
            returns the 1-norm of the offdiagonal part of the j-th column
            of A.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Here A**T denotes the transpose of A, x and b
            are n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine CTBSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            A rough bound on x is computed; if that is less than overflow, CTBSV
            is called, otherwise, specific code is used which checks for possible
            overflow or divide-by-zero at every operation.
            A columnwise scheme is used for solving A*x = b.  The basic algorithm
            if A is lower triangular is
                 x[1:n] := b[1:n]
                 for j = 1, ..., n
                      x(j) := x(j) / A(j,j)
                      x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                 end
            Define bounds on the components of x after j iterations of the loop:
               M(j) = bound on x[1:j]
               G(j) = bound on x[j+1:n]
            Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
            Then for iteration j+1 we have
               M(j+1) &amp;lt;= G(j) / | A(j+1,j+1) |
               G(j+1) &amp;lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                      &amp;lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
            where CNORM(j+1) is greater than or equal to the infinity-norm of
            column j+1 of A, not counting the diagonal.  Hence
               G(j) &amp;lt;= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
                            1&amp;lt;=i&amp;lt;=j
            and
               |x(j)| &amp;lt;= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                             1&amp;lt;=i&amp;lt; j
            Since |x(j)| &amp;lt;= M(j), we use the Level 2 BLAS routine CTBSV if the
            reciprocal of the largest M(j), j=1,..,n, is larger than
            max(underflow, 1/overflow).
            The bound on x(j) is also used to determine when a step in the
            columnwise method can be performed without fear of overflow.  If
            the computed bound is greater than a large constant, x is scaled to
            prevent overflow, but if the bound overflows, x is set to 0, x(j) to
            1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
            Similarly, a row-wise scheme is used to solve A**T *x = b  or
            A**H *x = b.  The basic algorithm for A upper triangular is
                 for j = 1, ..., n
                      x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
                 end
            We simultaneously compute two bounds
                 G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1&amp;lt;=i&amp;lt;=j
                 M(j) = bound on x(i), 1&amp;lt;=i&amp;lt;=j
            The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
            add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
            Then the bound on x(j) is
                 M(j) &amp;lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
                      &amp;lt;= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                1&amp;lt;=i&amp;lt;=j
            and we can safely call CTBSV if 1/M(n) and 1/G(n) are both greater
            than max(underflow, 1/overflow).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Csrscl(System.Int32,System.Single,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Multiplies an n-element complex vector x by the real scalar
            1/a.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of components of the vector x.
            </code>
            </param>
            <param name="sa">
            <code>
            SA is REAL
            The scalar a which is used to divide each component of x.
            SA must be >= 0, or the subroutine will divide by zero.
            </code>
            </param>
            <param name="sx">
            <code>
            SX is COMPLEX array, dimension
                           (1+(N-1)*abs(INCX))
            The n-element vector x.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive values of the vector SX.
            > 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),     1&amp;lt; i&amp;lt;= n
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is done without overflow or underflow as long as
            the final result x/a does not overflow or underflow.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claswp(System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32)">
            <summary>
            <para>
            Performs a series of row interchanges on the matrix A.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the matrix of column dimension N to which the row
            interchanges will be applied.
            On exit, the permuted matrix.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            </code>
            </param>
            <param name="k1">
            <code>
            K1 is INTEGER
            The first element of IPIV for which a row interchange will
            be done.
            </code>
            </param>
            <param name="k2">
            <code>
            K2 is INTEGER
            The last element of IPIV for which a row interchange will
            be done.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (K2*abs(INCX))
            The vector of pivot indices.  Only the elements in positions
            K1 through K2 of IPIV are accessed.
            IPIV(K) = L implies rows K and L are to be interchanged.
            </code>
            </param>
            <param name="incx">
            <code>
            INCX is INTEGER
            The increment between successive values of IPIV.  If IPIV
            is negative, the pivots are applied in reverse order.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            One row interchange is initiated for each of rows K1 through K2 of A.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Modified by
             R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clacgv(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Conjugates a complex vector of length N.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The length of the vector X.  N >= 0.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX array, dimension
                           (1+(N-1)*abs(INCX))
            On entry, the vector of length N to be conjugated.
            On exit, X is overwritten with conjg(X).
            </code>
            <code>
            INCX is INTEGER
            The spacing between successive elements of X.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clatrs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Single@,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves one of the triangular systems
               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
            with scaling to prevent overflow.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the operation applied to A.
            = 'N':  Solve A * x = s*b     (No transpose)
            = 'T':  Solve A**T * x = s*b  (Transpose)
            = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="normin">
            <code>
            NORMIN is CHARACTER*1
            Specifies whether CNORM has been set or not.
            = 'Y':  CNORM contains the column norms on entry
            = 'N':  CNORM is not set on entry.  On exit, the norms will
                    be computed and stored in CNORM.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max (1,N).
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX array, dimension (N)
            On entry, the right hand side b of the triangular system.
            On exit, X is overwritten by the solution vector x.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL
            The scaling factor s for the triangular system
               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
            If SCALE = 0, the matrix A is singular or badly scaled, and
            the vector x is an exact or approximate solution to A*x = 0.
            </code>
            </param>
            <param name="cnorm">
            <code>
            CNORM is REAL array, dimension (N)
            If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
            contains the norm of the off-diagonal part of the j-th column
            of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
            to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
            must be greater than or equal to the 1-norm.
            If NORMIN = 'N', CNORM is an output argument and CNORM(j)
            returns the 1-norm of the offdiagonal part of the j-th column
            of A.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Here A is an upper or lower
            triangular matrix, A**T denotes the transpose of A, A**H denotes the
            conjugate transpose of A, x and b are n-element vectors, and s is a
            scaling factor, usually less than or equal to 1, chosen so that the
            components of x will be less than the overflow threshold.  If the
            unscaled problem will not cause overflow, the Level 2 BLAS routine
            CTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
            then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            A rough bound on x is computed; if that is less than overflow, CTRSV
            is called, otherwise, specific code is used which checks for possible
            overflow or divide-by-zero at every operation.
            A columnwise scheme is used for solving A*x = b.  The basic algorithm
            if A is lower triangular is
                 x[1:n] := b[1:n]
                 for j = 1, ..., n
                      x(j) := x(j) / A(j,j)
                      x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                 end
            Define bounds on the components of x after j iterations of the loop:
               M(j) = bound on x[1:j]
               G(j) = bound on x[j+1:n]
            Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
            Then for iteration j+1 we have
               M(j+1) &amp;lt;= G(j) / | A(j+1,j+1) |
               G(j+1) &amp;lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                      &amp;lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
            where CNORM(j+1) is greater than or equal to the infinity-norm of
            column j+1 of A, not counting the diagonal.  Hence
               G(j) &amp;lt;= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
                            1&amp;lt;=i&amp;lt;=j
            and
               |x(j)| &amp;lt;= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                             1&amp;lt;=i&amp;lt; j
            Since |x(j)| &amp;lt;= M(j), we use the Level 2 BLAS routine CTRSV if the
            reciprocal of the largest M(j), j=1,..,n, is larger than
            max(underflow, 1/overflow).
            The bound on x(j) is also used to determine when a step in the
            columnwise method can be performed without fear of overflow.  If
            the computed bound is greater than a large constant, x is scaled to
            prevent overflow, but if the bound overflows, x is set to 0, x(j) to
            1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
            Similarly, a row-wise scheme is used to solve A**T *x = b  or
            A**H *x = b.  The basic algorithm for A upper triangular is
                 for j = 1, ..., n
                      x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
                 end
            We simultaneously compute two bounds
                 G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1&amp;lt;=i&amp;lt;=j
                 M(j) = bound on x(i), 1&amp;lt;=i&amp;lt;=j
            The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
            add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
            Then the bound on x(j) is
                 M(j) &amp;lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
                      &amp;lt;= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                1&amp;lt;=i&amp;lt;=j
            and we can safely call CTRSV if 1/M(n) and 1/G(n) are both greater
            than max(underflow, 1/overflow).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clarf(Extreme.Mathematics.MatrixOperationSide,System.Int32,System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Applies a complex elementary reflector H to a complex M-by-N
            matrix C, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': form  H * C
            = 'R': form  C * H
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array, dimension
                       (1 + (M-1)*abs(INCV)) if SIDE = 'L'
                    or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
            The vector v in the representation of H. V is not used if
            TAU = 0.
            </code>
            <code>
            INCV is INTEGER
            The increment between elements of v. INCV &amp;lt;> 0.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX
            The value tau in the representation of H.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by the matrix H * C if SIDE = 'L',
            or C * H if SIDE = 'R'.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension
                           (N) if SIDE = 'L'
                        or (M) if SIDE = 'R'
            </code>
            </param>
            <remarks>
            <para>
            <code>
            H is represented in the
            form
                  H = I - tau * v * v**H
            where tau is a complex scalar and v is a complex vector.
            If tau = 0, then H is taken to be the unit matrix.
            To apply H**H (the conjugate transpose of H), supply conjg(tau) instead
            tau.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clarfg(System.Int32,Extreme.Mathematics.Complex{System.Single}@,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single}@)">
            <summary>
            <para>
            Generates a complex elementary reflector H of order n, such
            that
                  H**H * ( alpha ) = ( beta ),   H**H * H = I.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the elementary reflector.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is COMPLEX
            On entry, the value alpha.
            On exit, it is overwritten with the value beta.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX array, dimension
                           (1+(N-2)*abs(INCX))
            On entry, the vector x.
            On exit, it is overwritten with the vector v.
            </code>
            <code>
            INCX is INTEGER
            The increment between elements of X. INCX > 0.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX
            The value tau.
            </code>
            </param>
            <remarks>
            <para>
            <code>
                         (   x   )   (   0  )
            where alpha and beta are scalars, with beta real, and x is an
            (n-1)-element complex vector. H is represented in the form
                  H = I - tau * ( 1 ) * ( 1 v**H ) ,
                                ( v )
            where tau is a complex scalar and v is a complex (n-1)-element
            vector. Note that H is not hermitian.
            If the elements of x are all zero and alpha is real, then tau = 0
            and H is taken to be the unit matrix.
            Otherwise  1 &amp;lt;= real(tau) &amp;lt;= 2  and  abs(tau-1) &amp;lt;= 1 .
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Copy(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Copies all or part of a two-dimensional matrix A to another
            matrix B.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper trapezium
            is accessed; if UPLO = 'L', only the lower trapezium is
            accessed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clahr2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Reduces the first NB columns of A complex general n-BY-(n-k+1)
            matrix A so that elements below the k-th subdiagonal are zero.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The offset for the reduction. Elements below the k-th
            subdiagonal in the first NB columns are reduced to zero.
            K &amp;lt; N.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of columns to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N-K+1)
            On entry, the n-by-(n-k+1) general matrix A.
            On exit, the elements on and above the k-th subdiagonal in
            the first NB columns are overwritten with the corresponding
            elements of the reduced matrix; the elements below the k-th
            subdiagonal, with the array TAU, represent the matrix Q as a
            product of elementary reflectors. The other columns of A are
            unchanged. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (NB)
            The scalar factors of the elementary reflectors. See Further
            Details.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX array, dimension (LDT,NB)
            The upper triangular matrix T.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T.  LDT >= NB.
            </code>
            </param>
            <param name="y">
            <code>
            Y is COMPLEX array, dimension (LDY,NB)
            The n-by-nb matrix Y.
            </code>
            <code>
            LDY is INTEGER
            The leading dimension of the array Y. LDY >= N.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The
            reduction is performed by an unitary similarity transformation
            Q**H * A * Q. The routine returns the matrices V and T which determine
            Q as a block reflector I - V*T*v**H, and also the matrix Y = A * V * T.
            This is an auxiliary routine called by CGEHRD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of nb elementary reflectors
               Q = H(1) H(2) . . . H(nb).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
            A(i+k+1:n,i), and tau in TAU(i).
            The elements of the vectors v together form the (n-k+1)-by-nb matrix
            V which is needed, with T and Y, to apply the transformation to the
            unreduced part of the matrix, using an update of the form:
            A := (I - V*T*V**H) * (A - Y*V**H).
            The contents of A on exit are illustrated by the following example
            with n = 7, k = 3 and nb = 2:
               ( a   a   a   a   a )
               ( a   a   a   a   a )
               ( a   a   a   a   a )
               ( h   h   a   a   a )
               ( v1  h   a   a   a )
               ( v1  v2  a   a   a )
               ( v1  v2  a   a   a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            This subroutine is a slight modification of LAPACK-3.0's DLAHRD
            incorporating improvements proposed by Quintana-Orti and Van de
            Gejin. Note that the entries of A(1:K,2:NB) differ from those
            returned by the original LAPACK-3.0's DLAHRD routine. (This
            subroutine is not backward compatible with LAPACK-3.0's DLAHRD.)
            </code>
            </para>
            <h4> References:</h4>
            <para>
             Gregorio Quintana-Orti and Robert van de Geijn, "Improving the
             performance of reduction to Hessenberg form," ACM Transactions on
             Mathematical Software, 32(2):180-194, June 2006.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clarfb(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Applies a complex block reflector H or its transpose H**H to a
            complex M-by-N matrix C, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply H or H**H from the Left
            = 'R': apply H or H**H from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply H (No transpose)
            = 'C': apply H**H (Conjugate transpose)
            </code>
            </param>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Indicates how H is formed from a product of elementary
            reflectors
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </code>
            </param>
            <param name="storev">
            <code>
            STOREV is CHARACTER*1
            Indicates how the vectors which define the elementary
            reflectors are stored:
            = 'C': Columnwise
            = 'R': Rowwise
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The order of the matrix T (= the number of elementary
            reflectors whose product defines the block reflector).
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array, dimension
                                  (LDV,K) if STOREV = 'C'
                                  (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                  (LDV,N) if STOREV = 'R' and SIDE = 'R'
            The matrix V. See Further Details.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V.
            If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
            if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
            if STOREV = 'R', LDV >= K.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX array, dimension (LDT,K)
            The triangular K-by-K matrix T in the representation of the
            block reflector.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= K.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by H*C or H**H*C or C*H or C*H**H.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (LDWORK,K)
            </code>
            <code>
            LDWORK is INTEGER
            The leading dimension of the array WORK.
            If SIDE = 'L', LDWORK >= max(1,N);
            if SIDE = 'R', LDWORK >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The shape of the matrix V and the storage of the vectors which define
            the H(i) is best illustrated by the following example with n = 5 and
            k = 3. The elements equal to 1 are not stored; the corresponding
            array elements are modified but restored on exit. The rest of the
            array is not used.
            DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
                         V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                             ( v1  1    )                     (     1 v2 v2 v2 )
                             ( v1 v2  1 )                     (        1 v3 v3 )
                             ( v1 v2 v3 )
                             ( v1 v2 v3 )
            DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
                         V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                             ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                             (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                             (     1 v3 )
                             (        1 )
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clahqr(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Is an auxiliary routine called by CHSEQR to update the
               eigenvalues and Schur decomposition already computed by CHSEQR, by
               dealing with the Hessenberg submatrix in rows and columns ILO to
               IHI.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that H is already upper triangular in rows and
            columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless ILO = 1).
            CLAHQR works primarily with the Hessenberg submatrix in rows
            and columns ILO to IHI, but applies transformations to all of
            H if WANTT is .TRUE..
            1 &amp;lt;= ILO &amp;lt;= max(1,IHI); IHI &amp;lt;= N.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX array, dimension (LDH,N)
            On entry, the upper Hessenberg matrix H.
            On exit, if INFO is zero and if WANTT is .TRUE., then H
            is upper triangular in rows and columns ILO:IHI.  If INFO
            is zero and if WANTT is .FALSE., then the contents of H
            are unspecified on exit.  The output state of H in case
            INF is positive is below under the description of INFO.
            </code>
            <code>
            LDH is INTEGER
            The leading dimension of the array H. LDH >= max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX array, dimension (N)
            The computed eigenvalues ILO to IHI are stored in the
            corresponding elements of W. If WANTT is .TRUE., the
            eigenvalues are stored in the same order as on the diagonal
            of the Schur form returned in H, with W(i) = H(i,i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE..
            1 &amp;lt;= ILOZ &amp;lt;= ILO; IHI &amp;lt;= IHIZ &amp;lt;= N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX array, dimension (LDZ,N)
            If WANTZ is .TRUE., on entry Z must contain the current
            matrix Z of transformations accumulated by CHSEQR, and on
            exit Z has been updated; transformations are applied only to
            the submatrix Z(ILOZ:IHIZ,ILO:IHI).
            If WANTZ is .FALSE., Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z. LDZ >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
             =   0: successful exit
            .GT. 0: if INFO = i, CLAHQR failed to compute all the
                    eigenvalues ILO to IHI in a total of 30 iterations
                    per eigenvalue; elements i+1:ihi of W contain
                    those eigenvalues which have been successfully
                    computed.
                    If INFO .GT. 0 and WANTT is .FALSE., then on exit,
                    the remaining unconverged eigenvalues are the
                    eigenvalues of the upper Hessenberg matrix
                    rows and columns ILO thorugh INFO of the final,
                    output value of H.
                    If INFO .GT. 0 and WANTT is .TRUE., then on exit
            (*)       (initial value of H)*U  = U*(final value of H)
                    where U is an orthognal matrix.    The final
                    value of H is upper Hessenberg and triangular in
                    rows and columns INFO+1 through IHI.
                    If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                        (final value of Z)  = (initial value of Z)*U
                    where U is the orthogonal matrix in (*)
                    (regardless of the value of WANTT.)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            <code>
            02-96 Based on modifications by
            David Day, Sandia National Laboratory, USA
            12-04 Further modifications by
            Ralph Byers, University of Kansas, USA
            This is a modified version of CLAHQR from LAPACK version 3.0.
            It is (1) more robust against overflow and underflow and
            (2) adopts the more conservative Ahues &amp; Tisseur stopping
            criterion (LAWN 122, 1997).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claset(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Initializes a 2-D array A to BETA on the diagonal and
            ALPHA on the offdiagonals.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies the part of the matrix A to be set.
            = 'U':      Upper triangular part is set. The lower triangle
                        is unchanged.
            = 'L':      Lower triangular part is set. The upper triangle
                        is unchanged.
            Otherwise:  All of the matrix A is set.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            On entry, M specifies the number of rows of A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            On entry, N specifies the number of columns of A.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is COMPLEX
            All the offdiagonal array elements are set to ALPHA.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is COMPLEX
            All the diagonal array elements are set to BETA.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, A(i,j) = ALPHA, 1 &amp;lt;= i &amp;lt;= m, 1 &amp;lt;= j &amp;lt;= n, i.ne.j;
                     A(i,i) = BETA , 1 &amp;lt;= i &amp;lt;= min(m,n)
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clartg(Extreme.Mathematics.Complex{System.Single},Extreme.Mathematics.Complex{System.Single},System.Single@,Extreme.Mathematics.Complex{System.Single}@,Extreme.Mathematics.Complex{System.Single}@)">
            <summary>
            <para>
            Generates a plane rotation so that
               [  CS  SN  ]     [ F ]     [ R ]
               [  __      ]  .</para>
            </summary>
            <param name="f">
            <code>
            F is COMPLEX
            The first component of vector to be rotated.
            </code>
            </param>
            <param name="g">
            <code>
            G is COMPLEX
            The second component of vector to be rotated.
            </code>
            </param>
            <param name="cs">
            <code>
            CS is REAL
            The cosine of the rotation.
            </code>
            </param>
            <param name="sn">
            <code>
            SN is COMPLEX
            The sine of the rotation.
            </code>
            </param>
            <param name="r">
            <code>
            R is COMPLEX
            The nonzero component of the rotated vector.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            [   ]  =  [   ]   where CS**2 + |SN|**2 = 1.
               [ -SN  CS  ]     [ G ]     [ 0 ]
            This is a faster version of the BLAS1 routine CROTG, except for
            the following differences:
               F and G are unchanged on return.
               If G=0, then CS=1 and SN=0.
               If F=0, then CS=0 and SN is chosen so that R is real.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            3-5-96 - Modified with a new algorithm by W. Kahan and J. Demmel
            This version has a few statements commented out for thread safety
            (machine parameters are computed on each entry). 10 feb 03, SJH.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Crot(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},System.Single,Extreme.Mathematics.Complex{System.Single})">
            <summary>
            <para>
            Applies a plane rotation, where the cos (C) is real and the
            sin (S) is complex, and the vectors CX and CY are complex.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of elements in the vectors CX and CY.
            </code>
            </param>
            <param name="cx">
            <code>
            CX is COMPLEX array, dimension (N)
            On input, the vector X.
            On output, CX is overwritten with C*X + S*Y.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive values of CY.  INCX &amp;lt;> 0.
            </code>
            </param>
            <param name="cy">
            <code>
            CY is COMPLEX array, dimension (N)
            On input, the vector Y.
            On output, CY is overwritten with -CONJG(S)*X + C*Y.
            </code>
            <code>
            INCY is INTEGER
            The increment between successive values of CY.  INCX &amp;lt;> 0.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL
            </code>
            </param>
            <param name="s">
            <code>
            S is COMPLEX
            C and S define a rotation
               [  C          S  ]
               [ -conjg(S)   C  ]
            where C*C + S*CONJG(S) = 1.0.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clarft(System.Char,System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Forms the triangular factor T of a complex block reflector H
            of order n, which is defined as a product of k elementary reflectors.</para>
            </summary>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Specifies the order in which the elementary reflectors are
            multiplied to form the block reflector:
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </code>
            </param>
            <param name="storev">
            <code>
            STOREV is CHARACTER*1
            Specifies how the vectors which define the elementary
            reflectors are stored (see also Further Details):
            = 'C': columnwise
            = 'R': rowwise
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the block reflector H. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The order of the triangular factor T (= the number of
            elementary reflectors). K >= 1.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array, dimension
                                 (LDV,K) if STOREV = 'C'
                                 (LDV,N) if STOREV = 'R'
            The matrix V. See further details.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V.
            If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i).
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX array, dimension (LDT,K)
            The k by k triangular factor T of the block reflector.
            If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
            lower triangular. The rest of the array is not used.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= K.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
            If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
            If STOREV = 'C', the vector which defines the elementary reflector
            H(i) is stored in the i-th column of the array V, and
               H  =  I - V * T * V**H
            If STOREV = 'R', the vector which defines the elementary reflector
            H(i) is stored in the i-th row of the array V, and
               H  =  I - V**H * T * V
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The shape of the matrix V and the storage of the vectors which define
            the H(i) is best illustrated by the following example with n = 5 and
            k = 3. The elements equal to 1 are not stored.
            DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
                         V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                             ( v1  1    )                     (     1 v2 v2 v2 )
                             ( v1 v2  1 )                     (        1 v3 v3 )
                             ( v1 v2 v3 )
                             ( v1 v2 v3 )
            DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
                         V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                             ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                             (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                             (     1 v3 )
                             (        1 )
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claqr2(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@,System.Int32@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32)">
            <summary>
            <para>
            Is identical to CLAQR3 except that it avoids
               recursion by calling CLAHQR instead of CLAQR4.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            If .TRUE., then the Hessenberg matrix H is fully updated
            so that the triangular Schur factor may be
            computed (in cooperation with the calling subroutine).
            If .FALSE., then only enough of H is updated to preserve
            the eigenvalues.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            If .TRUE., then the unitary matrix Z is updated so
            so that the unitary Schur factor may be computed
            (in cooperation with the calling subroutine).
            If .FALSE., then Z is not referenced.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H and (if WANTZ is .TRUE.) the
            order of the unitary matrix Z.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is INTEGER
            It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
            KBOT and KTOP together determine an isolated block
            along the diagonal of the Hessenberg matrix.
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is INTEGER
            It is assumed without a check that either
            KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
            determine an isolated block along the diagonal of the
            Hessenberg matrix.
            </code>
            </param>
            <param name="nw">
            <code>
            NW is INTEGER
            Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX array, dimension (LDH,N)
            On input the initial N-by-N section of H stores the
            Hessenberg matrix undergoing aggressive early deflation.
            On output H has been transformed by a unitary
            similarity transformation, perturbed, and the returned
            to Hessenberg form that (it is to be hoped) has some
            zero subdiagonal entries.
            </code>
            <code>
            LDH is integer
            Leading dimension of H just as declared in the calling
            subroutine.  N .LE. LDH
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX array, dimension (LDZ,N)
            IF WANTZ is .TRUE., then on output, the unitary
            similarity transformation mentioned above has been
            accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
            If WANTZ is .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer
            The leading dimension of Z just as declared in the
            calling subroutine.  1 .LE. LDZ.
            </code>
            </param>
            <param name="ns">
            <code>
            NS is integer
            The number of unconverged (ie approximate) eigenvalues
            returned in SR and SI that may be used as shifts by the
            calling subroutine.
            </code>
            </param>
            <param name="nd">
            <code>
            ND is integer
            The number of converged eigenvalues uncovered by this
            subroutine.
            </code>
            </param>
            <param name="sh">
            <code>
            SH is COMPLEX array, dimension KBOT
            On output, approximate eigenvalues that may
            be used for shifts are stored in SH(KBOT-ND-NS+1)
            through SR(KBOT-ND).  Converged eigenvalues are
            stored in SH(KBOT-ND+1) through SH(KBOT).
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array, dimension (LDV,NW)
            An NW-by-NW work array.
            </code>
            <code>
            LDV is integer scalar
            The leading dimension of V just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
            The number of columns of T.  NH.GE.NW.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX array, dimension (LDT,NW)
            </code>
            <code>
            LDT is integer
            The leading dimension of T just as declared in the
            calling subroutine.  NW .LE. LDT
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer
            The number of rows of work array WV available for
            workspace.  NV.GE.NW.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is COMPLEX array, dimension (LDWV,NW)
            </code>
            <code>
            LDWV is integer
            The leading dimension of W just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension LWORK.
            On exit, WORK(1) is set to an estimate of the optimal value
            of LWORK for the given values of N, NW, KTOP and KBOT.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is integer
            The dimension of the work array WORK.  LWORK = 2*NW
            suffices, but greater efficiency may result from larger
            values of LWORK.
            If LWORK = -1, then a workspace query is assumed; CLAQR2
            only estimates the optimal workspace size for the given
            values of N, NW, KTOP and KBOT.  The estimate is returned
            in WORK(1).  No error message related to LWORK is issued
            by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Aggressive early deflation:
               This subroutine accepts as input an upper Hessenberg matrix
               H and performs an unitary similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.  On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an unitary similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claqr1(System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            A 2-by-2 or 3-by-3 matrix H, CLAQR1 sets v to a
                 scalar multiple of the first column of the product
                 (*)  K = (H - s1*I)*(H - s2*I)
                 scaling to avoid overflows and most underflows.</para>
            </summary>
            <param name="n">
            <code>
            N is integer
                Order of the matrix H. N must be either 2 or 3.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX array of dimension (LDH,N)
                The 2-by-2 or 3-by-3 matrix H in (*).
            </code>
            <code>
            LDH is integer
                The leading dimension of H as declared in
                the calling procedure.  LDH.GE.N
            </code>
            </param>
            <param name="s1">
            <code>
            S1 is COMPLEX
            </code>
            </param>
            <param name="s2">
            <code>
            S2 is COMPLEX
            S1 and S2 are the shifts defining K in (*) above.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array of dimension N
                A scalar multiple of the first column of the
                matrix K in (*).
            </code>
            </param>
            <remarks>
            <para>
            <code>
                 This is useful for starting double implicit shift bulges
                 in the QR algorithm.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claqr5(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Called by CLAQR0 performs a
               single small-bulge multi-shift QR sweep.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is logical scalar
               WANTT = .true. if the triangular Schur factor
               is being computed.  WANTT is set to .false. otherwise.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is logical scalar
               WANTZ = .true. if the unitary Schur factor is being
               computed.  WANTZ is set to .false. otherwise.
            </code>
            </param>
            <param name="kacc22">
            <code>
            KACC22 is integer with value 0, 1, or 2.
               Specifies the computation mode of far-from-diagonal
               orthogonal updates.
            = 0: CLAQR5 does not accumulate reflections and does not
                 use matrix-matrix multiply to update far-from-diagonal
                 matrix entries.
            = 1: CLAQR5 accumulates reflections and uses matrix-matrix
                 multiply to update the far-from-diagonal matrix entries.
            = 2: CLAQR5 accumulates reflections, uses matrix-matrix
                 multiply to update the far-from-diagonal matrix entries,
                 and takes advantage of 2-by-2 block structure during
                 matrix multiplies.
            </code>
            </param>
            <param name="n">
            <code>
            N is integer scalar
               N is the order of the Hessenberg matrix H upon which this
               subroutine operates.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is integer scalar
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is integer scalar
               These are the first and last rows and columns of an
               isolated diagonal block upon which the QR sweep is to be
               applied. It is assumed without a check that
                         either KTOP = 1  or   H(KTOP,KTOP-1) = 0
               and
                         either KBOT = N  or   H(KBOT+1,KBOT) = 0.
            </code>
            </param>
            <param name="nshfts">
            <code>
            NSHFTS is integer scalar
               NSHFTS gives the number of simultaneous shifts.  NSHFTS
               must be positive and even.
            </code>
            </param>
            <param name="s">
            <code>
            S is COMPLEX array of size (NSHFTS)
               S contains the shifts of origin that define the multi-
               shift QR sweep.  On output S may be reordered.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX array of size (LDH,N)
               On input H contains a Hessenberg matrix.  On output a
               multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
               to the isolated diagonal block in rows and columns KTOP
               through KBOT.
            </code>
            <code>
            LDH is integer scalar
               LDH is the leading dimension of H just as declared in the
               calling procedure.  LDH.GE.MAX(1,N).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
               Specify the rows of Z to which transformations must be
               applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX array of size (LDZ,IHI)
               If WANTZ = .TRUE., then the QR Sweep unitary
               similarity transformation is accumulated into
               Z(ILOZ:IHIZ,ILO:IHI) from the right.
               If WANTZ = .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer scalar
               LDA is the leading dimension of Z just as declared in
               the calling procedure. LDZ.GE.N.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array of size (LDV,NSHFTS/2)
            </code>
            <code>
            LDV is integer scalar
               LDV is the leading dimension of V as declared in the
               calling procedure.  LDV.GE.3.
            </code>
            </param>
            <param name="u">
            <code>
            U is COMPLEX array of size
               (LDU,3*NSHFTS-3)
            </code>
            <code>
            LDU is integer scalar
               LDU is the leading dimension of U just as declared in the
               in the calling subroutine.  LDU.GE.3*NSHFTS-3.
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
               NH is the number of columns in array WH available for
               workspace. NH.GE.1.
            </code>
            </param>
            <param name="wh">
            <code>
            WH is COMPLEX array of size (LDWH,NH)
            </code>
            <code>
            LDWH is integer scalar
               Leading dimension of WH just as declared in the
               calling procedure.  LDWH.GE.3*NSHFTS-3.
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer scalar
               NV is the number of rows in WV agailable for workspace.
               NV.GE.1.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is COMPLEX array of size
               (LDWV,3*NSHFTS-3)
            </code>
            <code>
            LDWV is integer scalar
               LDWV is the leading dimension of WV as declared in the
               in the calling subroutine.  LDWV.GE.NV.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claqr4(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Implements one level of recursion for CLAQR0.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
             H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
             previous call to CGEBAL, and then passed to CGEHRD when the
             matrix output by CGEBAL is reduced to Hessenberg form.
             Otherwise, ILO and IHI should be set to 1 and N,
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and WANTT is .TRUE., then H
             contains the upper triangular matrix T from the Schur
             decomposition (the Schur form). If INFO = 0 and WANT is
             .FALSE., then the contents of H are unspecified on exit.
             (The output value of H when INFO.GT.0 is given under the
             description of INFO below.)
             This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
             j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX array, dimension (N)
             The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored
             in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are
             stored in the same order as on the diagonal of the Schur
             form returned in H, with W(i) = H(i,i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX array, dimension (LDZ,IHI)
             If WANTZ is .FALSE., then Z is not referenced.
             If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
             replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
             orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
             (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if WANTZ is .TRUE.
             then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension LWORK
             On exit, if LWORK = -1, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             If LWORK = -1, then CLAQR4 does a workspace query.
             In this case, CLAQR4 checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .GT. 0:  if INFO = i, CLAQR4 failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and WANT is .FALSE., then on exit,
                  the remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and WANTT is .TRUE., then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is a unitary matrix.  The final
                  value of  H is upper Hessenberg and triangular in
                  rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                    (final value of Z(ILO:IHI,ILOZ:IHIZ)
                     =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
                  where U is the unitary matrix in (*) (regard-
                  less of the value of WANTT.)
                  If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It is a complete implementation of the small bulge multi-shift
            QR algorithm.  It may be called by CLAQR0 and, for large enough
            deflation window size, it may be called by CLAQR3.  This
            subroutine is identical to CLAQR0 except that it calls CLAQR2
            instead of CLAQR3.
            CLAQR4 computes the eigenvalues of a Hessenberg matrix H
            and, optionally, the matrices T and Z from the Schur decomposition
            H = Z T Z**H, where T is an upper triangular matrix (the
            Schur form), and Z is the unitary matrix of Schur vectors.
            Optionally Z may be postmultiplied into an input unitary
            matrix Q so that this routine can give the Schur factorization
            of a matrix A which has been reduced to the Hessenberg form H
            by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claqr3(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@,System.Int32@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32)">
            <summary>
            <para>
            Early deflation:
               CLAQR3 accepts as input an upper Hessenberg matrix
               H and performs an unitary similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            If .TRUE., then the Hessenberg matrix H is fully updated
            so that the triangular Schur factor may be
            computed (in cooperation with the calling subroutine).
            If .FALSE., then only enough of H is updated to preserve
            the eigenvalues.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            If .TRUE., then the unitary matrix Z is updated so
            so that the unitary Schur factor may be computed
            (in cooperation with the calling subroutine).
            If .FALSE., then Z is not referenced.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H and (if WANTZ is .TRUE.) the
            order of the unitary matrix Z.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is INTEGER
            It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
            KBOT and KTOP together determine an isolated block
            along the diagonal of the Hessenberg matrix.
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is INTEGER
            It is assumed without a check that either
            KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
            determine an isolated block along the diagonal of the
            Hessenberg matrix.
            </code>
            </param>
            <param name="nw">
            <code>
            NW is INTEGER
            Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX array, dimension (LDH,N)
            On input the initial N-by-N section of H stores the
            Hessenberg matrix undergoing aggressive early deflation.
            On output H has been transformed by a unitary
            similarity transformation, perturbed, and the returned
            to Hessenberg form that (it is to be hoped) has some
            zero subdiagonal entries.
            </code>
            <code>
            LDH is integer
            Leading dimension of H just as declared in the calling
            subroutine.  N .LE. LDH
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX array, dimension (LDZ,N)
            IF WANTZ is .TRUE., then on output, the unitary
            similarity transformation mentioned above has been
            accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
            If WANTZ is .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer
            The leading dimension of Z just as declared in the
            calling subroutine.  1 .LE. LDZ.
            </code>
            </param>
            <param name="ns">
            <code>
            NS is integer
            The number of unconverged (ie approximate) eigenvalues
            returned in SR and SI that may be used as shifts by the
            calling subroutine.
            </code>
            </param>
            <param name="nd">
            <code>
            ND is integer
            The number of converged eigenvalues uncovered by this
            subroutine.
            </code>
            </param>
            <param name="sh">
            <code>
            SH is COMPLEX array, dimension KBOT
            On output, approximate eigenvalues that may
            be used for shifts are stored in SH(KBOT-ND-NS+1)
            through SR(KBOT-ND).  Converged eigenvalues are
            stored in SH(KBOT-ND+1) through SH(KBOT).
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array, dimension (LDV,NW)
            An NW-by-NW work array.
            </code>
            <code>
            LDV is integer scalar
            The leading dimension of V just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
            The number of columns of T.  NH.GE.NW.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX array, dimension (LDT,NW)
            </code>
            <code>
            LDT is integer
            The leading dimension of T just as declared in the
            calling subroutine.  NW .LE. LDT
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer
            The number of rows of work array WV available for
            workspace.  NV.GE.NW.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is COMPLEX array, dimension (LDWV,NW)
            </code>
            <code>
            LDWV is integer
            The leading dimension of W just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension LWORK.
            On exit, WORK(1) is set to an estimate of the optimal value
            of LWORK for the given values of N, NW, KTOP and KBOT.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is integer
            The dimension of the work array WORK.  LWORK = 2*NW
            suffices, but greater efficiency may result from larger
            values of LWORK.
            If LWORK = -1, then a workspace query is assumed; CLAQR3
            only estimates the optimal workspace size for the given
            values of N, NW, KTOP and KBOT.  The estimate is returned
            in WORK(1).  No error message related to LWORK is issued
            by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an unitary similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claqr0(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**H, where T is an upper triangular matrix (the
               Schur form), and Z is the unitary matrix of Schur vectors.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
             H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
             previous call to CGEBAL, and then passed to CGEHRD when the
             matrix output by CGEBAL is reduced to Hessenberg form.
             Otherwise, ILO and IHI should be set to 1 and N,
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and WANTT is .TRUE., then H
             contains the upper triangular matrix T from the Schur
             decomposition (the Schur form). If INFO = 0 and WANT is
             .FALSE., then the contents of H are unspecified on exit.
             (The output value of H when INFO.GT.0 is given under the
             description of INFO below.)
             This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
             j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX array, dimension (N)
             The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored
             in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are
             stored in the same order as on the diagonal of the Schur
             form returned in H, with W(i) = H(i,i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX array, dimension (LDZ,IHI)
             If WANTZ is .FALSE., then Z is not referenced.
             If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
             replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
             orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
             (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if WANTZ is .TRUE.
             then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension LWORK
             On exit, if LWORK = -1, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             If LWORK = -1, then CLAQR0 does a workspace query.
             In this case, CLAQR0 checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .GT. 0:  if INFO = i, CLAQR0 failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and WANT is .FALSE., then on exit,
                  the remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and WANTT is .TRUE., then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is a unitary matrix.  The final
                  value of  H is upper Hessenberg and triangular in
                  rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                    (final value of Z(ILO:IHI,ILOZ:IHIZ)
                     =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
                  where U is the unitary matrix in (*) (regard-
                  less of the value of WANTT.)
                  If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Optionally Z may be postmultiplied into an input unitary
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clascl(System.Char,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Multiplies the M by N complex matrix A by the real scalar
            CTO/CFROM.</para>
            </summary>
            <param name="type">
            <code>
            TYPE is CHARACTER*1
            TYPE indices the storage type of the input matrix.
            = 'G':  A is a full matrix.
            = 'L':  A is a lower triangular matrix.
            = 'U':  A is an upper triangular matrix.
            = 'H':  A is an upper Hessenberg matrix.
            = 'B':  A is a symmetric band matrix with lower bandwidth KL
                    and upper bandwidth KU and with the only the lower
                    half stored.
            = 'Q':  A is a symmetric band matrix with lower bandwidth KL
                    and upper bandwidth KU and with the only the upper
                    half stored.
            = 'Z':  A is a band matrix with lower bandwidth KL and upper
                    bandwidth KU. See CGBTRF for storage details.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The lower bandwidth of A.  Referenced only if TYPE = 'B',
            'Q' or 'Z'.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The upper bandwidth of A.  Referenced only if TYPE = 'B',
            'Q' or 'Z'.
            </code>
            </param>
            <param name="cfrom">
            <code>
            CFROM is REAL
            </code>
            </param>
            <param name="cto">
            <code>
            CTO is REAL
            The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
            without over/underflow if the final result CTO*A(I,J)/CFROM
            can be represented without over/underflow.  CFROM must be
            nonzero.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The matrix to be multiplied by CTO/CFROM.  See TYPE for the
            storage type.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            0  - successful exit
            &amp;lt;0 - if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is done without over/underflow as long as the final
            result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
            A may be full, upper triangular, lower triangular, upper Hessenberg,
            or banded.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Classq(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},System.Single@,System.Single@)">
            <summary>
            <para>
            Returns the values scl and ssq such that
               ( scl**2 )*ssq = x( 1 )**2 +.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of elements to be used from the vector X.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX array, dimension (N)
            The vector x as described above.
               x( i )  = X( 1 + ( i - 1 )*INCX ), 1 &amp;lt;= i &amp;lt;= n.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive values of the vector X.
            INCX > 0.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL
            On entry, the value  scale  in the equation above.
            On exit, SCALE is overwritten with the value  scl .
            </code>
            </param>
            <param name="sumsq">
            <code>
            SUMSQ is REAL
            On entry, the value  sumsq  in the equation above.
            On exit, SUMSQ is overwritten with the value  ssq .
            </code>
            </param>
            <remarks>
            <para>
            <code>
            where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
            assumed to be at least unity and the value of ssq will then satisfy
               1.0 .le. ssq .le. ( sumsq + 2*n ).
            scale is assumed to be non-negative and scl returns the value
               scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
                      i
            scale and sumsq must be supplied in SCALE and SUMSQ respectively.
            SCALE and SUMSQ are overwritten by scl and ssq respectively.
            The routine makes only one pass through the vector X.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.FullMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in CLANGE as described
            above.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.  When M = 0,
            CLANGE is set to zero.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.  When N = 0,
            CLANGE is set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(M,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK)),
            where LWORK >= M when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            CLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claqp2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Computes a QR factorization with column pivoting of
            the block A(OFFSET+1:M,1:N).</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0.
            </code>
            </param>
            <param name="offset">
            <code>
            OFFSET is INTEGER
            The number of rows of the matrix A that must be pivoted
            but no factorized. OFFSET >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of block A(OFFSET+1:M,1:N) is
            the triangular factor obtained; the elements in block
            A(OFFSET+1:M,1:N) below the diagonal, together with the
            array TAU, represent the orthogonal matrix Q as a product of
            elementary reflectors. Block A(1:OFFSET,1:N) has been
            accordingly pivoted, but no factorized.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(i) = 0,
            the i-th column of A is a free column.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="vn1">
            <code>
            VN1 is REAL array, dimension (N)
            The vector with the partial column norms.
            </code>
            </param>
            <param name="vn2">
            <code>
            VN2 is REAL array, dimension (N)
            The vector with the exact column norms.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (N)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>
             Partial column norm updating strategy modified on April 2011
               Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
               University of Zagreb, Croatia.
            </para>
            <h4> References:</h4>
            <para>
            LAPACK Working Note 176
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claqps(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Computes a step of QR factorization with column pivoting
            of a complex M-by-N matrix A by using Blas-3.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0
            </code>
            </param>
            <param name="offset">
            <code>
            OFFSET is INTEGER
            The number of rows of A that have been factorized in
            previous steps.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of columns to factorize.
            </code>
            </param>
            <param name="kb">
            <code>
            KB is INTEGER
            The number of columns actually factorized.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, block A(OFFSET+1:M,1:KB) is the triangular
            factor obtained and block A(1:OFFSET,1:N) has been
            accordingly pivoted, but no factorized.
            The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
            been updated.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            JPVT(I) = K &amp;lt;==> Column K of the full matrix A has been
            permuted into position I in AP.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (KB)
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="vn1">
            <code>
            VN1 is REAL array, dimension (N)
            The vector with the partial column norms.
            </code>
            </param>
            <param name="vn2">
            <code>
            VN2 is REAL array, dimension (N)
            The vector with the exact column norms.
            </code>
            </param>
            <param name="auxv">
            <code>
            AUXV is COMPLEX array, dimension (NB)
            Auxiliar vector.
            </code>
            </param>
            <param name="f">
            <code>
            F is COMPLEX array, dimension (LDF,NB)
            Matrix  F**H = L * Y**H * A.
            </code>
            <code>
            LDF is INTEGER
            The leading dimension of the array F. LDF >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It tries to factorize
            NB columns from A starting from the row OFFSET+1, and updates all
            of the matrix with Blas-3 xGEMM.
            In some cases, due to catastrophic cancellations, it cannot
            factorize NB columns.  Hence, the actual number of factorized
            columns is returned in KB.
            Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>
             Partial column norm updating strategy modified on April 2011
               Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
               University of Zagreb, Croatia.
            </para>
            <h4> References:</h4>
            <para>
            LAPACK Working Note 176
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clabrd(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Reduces the first NB rows and columns of a complex general
            m by n matrix A to upper or lower real bidiagonal form by a unitary
            transformation Q**H * A * P, and returns the matrices X and Y which
            are needed to apply the transformation to the unreduced part of A.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of leading rows and columns of A to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit, the first NB rows and columns of the matrix are
            overwritten; the rest of the array is unchanged.
            If m >= n, elements on and below the diagonal in the first NB
              columns, with the array TAUQ, represent the unitary
              matrix Q as a product of elementary reflectors; and
              elements above the diagonal in the first NB rows, with the
              array TAUP, represent the unitary matrix P as a product
              of elementary reflectors.
            If m &amp;lt; n, elements below the diagonal in the first NB
              columns, with the array TAUQ, represent the unitary
              matrix Q as a product of elementary reflectors, and
              elements on and above the diagonal in the first NB rows,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (NB)
            The diagonal elements of the first NB rows and columns of
            the reduced matrix.  D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (NB)
            The off-diagonal elements of the first NB rows and columns of
            the reduced matrix.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is COMPLEX array dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is COMPLEX array, dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX array, dimension (LDX,NB)
            The m-by-nb matrix X required to update the unreduced part
            of A.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of the array X. LDX >= max(1,M).
            </code>
            </param>
            <param name="y">
            <code>
            Y is COMPLEX array, dimension (LDY,NB)
            The n-by-nb matrix Y required to update the unreduced part
            of A.
            </code>
            <code>
            LDY is INTEGER
            The leading dimension of the array Y. LDY >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, A is reduced to upper bidiagonal form; if m &amp;lt; n, to lower
            bidiagonal form.
            This is an auxiliary routine called by CGEBRD
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
               Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
            where tauq and taup are complex scalars, and v and u are complex
            vectors.
            If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
            A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
            A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
            A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
            A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            The elements of the vectors v and u together form the m-by-nb matrix
            V and the nb-by-n matrix U**H which are needed, with X and Y, to apply
            the transformation to the unreduced part of the matrix, using a block
            update of the form:  A := A - V*Y**H - X*U**H.
            The contents of A on exit are illustrated by the following examples
            with nb = 2:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
              (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
              (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
              (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
              (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
              (  v1  v2  a   a   a  )
            where a denotes an element of the original matrix which is unchanged,
            vi denotes an element of the vector defining H(i), and ui an element
            of the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clacp2(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Copies all or part of a real two-dimensional matrix A to a
            complex matrix B.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper trapezium
            is accessed; if UPLO = 'L', only the lower trapezium is
            accessed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clacrm(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Performs a very simple matrix-matrix multiplication:
                     C := A * B,
            where A is M by N and complex; B is N by N and real;
            C is M by N and complex.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A and of the matrix C.
            M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns and rows of the matrix B and
            the number of columns of the matrix C.
            N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA, N)
            A contains the M by N matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >=max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB, N)
            B contains the N by N matrix B.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >=max(1,N).
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC, N)
            C contains the M by N matrix C.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >=max(1,N).
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (2*M*N)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clarcm(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Performs a very simple matrix-matrix multiplication:
                     C := A * B,
            where A is M by M and real; B is M by N and complex;
            C is M by N and complex.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A and of the matrix C.
            M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns and rows of the matrix B and
            the number of columns of the matrix C.
            N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA, M)
            A contains the M by M matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >=max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB, N)
            B contains the M by N matrix B.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >=max(1,M).
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC, N)
            C contains the M by N matrix C.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >=max(1,M).
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (2*M*N)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clapmt(System.Boolean,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32})">
            <summary>
            <para>
            Rearranges the columns of the M by N matrix X as specified
            by the permutation K(1),K(2),.</para>
            </summary>
            <param name="forwrd">
            <code>
            FORWRD is LOGICAL
            = .TRUE., forward permutation
            = .FALSE., backward permutation
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix X. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix X. N >= 0.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX array, dimension (LDX,N)
            On entry, the M by N matrix X.
            On exit, X contains the permuted matrix X.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of the array X, LDX >= MAX(1,M).
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER array, dimension (N)
            On entry, K contains the permutation vector. K is used as
            internal workspace, but reset to its original value on
            output.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If FORWRD = .TRUE.,  forward permutation:
                 X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
            If FORWRD = .FALSE., backward permutation:
                 X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clags2(System.Boolean,System.Single,Extreme.Mathematics.Complex{System.Single},System.Single,System.Single,Extreme.Mathematics.Complex{System.Single},System.Single,System.Single@,Extreme.Mathematics.Complex{System.Single}@,System.Single@,Extreme.Mathematics.Complex{System.Single}@,System.Single@,Extreme.Mathematics.Complex{System.Single}@)">
            <summary>
            <para>
            Computes 2-by-2 unitary matrices U, V and Q, such
            that if ( UPPER ) then
                      U**H *A*Q = U**H *( A1 A2 )*Q = ( x  0  )
                                        ( 0  A3 )     ( x  x  )
            and
                      V**H*B*Q = V**H *( B1 B2 )*Q = ( x  0  )
                                       ( 0  B3 )     ( x  x  )
            or if ( .</para>
            </summary>
            <param name="upper">
            <code>
            UPPER is LOGICAL
            = .TRUE.: the input matrices A and B are upper triangular.
            = .FALSE.: the input matrices A and B are lower triangular.
            </code>
            </param>
            <param name="a1">
            <code>
            A1 is REAL
            </code>
            </param>
            <param name="a2">
            <code>
            A2 is COMPLEX
            </code>
            </param>
            <param name="a3">
            <code>
            A3 is REAL
            On entry, A1, A2 and A3 are elements of the input 2-by-2
            upper (lower) triangular matrix A.
            </code>
            </param>
            <param name="b1">
            <code>
            B1 is REAL
            </code>
            </param>
            <param name="b2">
            <code>
            B2 is COMPLEX
            </code>
            </param>
            <param name="b3">
            <code>
            B3 is REAL
            On entry, B1, B2 and B3 are elements of the input 2-by-2
            upper (lower) triangular matrix B.
            </code>
            </param>
            <param name="csu">
            <code>
            CSU is REAL
            </code>
            </param>
            <param name="snu">
            <code>
            SNU is COMPLEX
            The desired unitary matrix U.
            </code>
            </param>
            <param name="csv">
            <code>
            CSV is REAL
            </code>
            </param>
            <param name="snv">
            <code>
            SNV is COMPLEX
            The desired unitary matrix V.
            </code>
            </param>
            <param name="csq">
            <code>
            CSQ is REAL
            </code>
            </param>
            <param name="snq">
            <code>
            SNQ is COMPLEX
            The desired unitary matrix Q.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            NOT.UPPER ) then
                      U**H *A*Q = U**H *( A1 0  )*Q = ( x  x  )
                                        ( A2 A3 )     ( 0  x  )
            and
                      V**H *B*Q = V**H *( B1 0  )*Q = ( x  x  )
                                        ( B2 B3 )     ( 0  x  )
            where
              U = (   CSU    SNU ), V = (  CSV    SNV ),
                  ( -SNU**H  CSU )      ( -SNV**H CSV )
              Q = (   CSQ    SNQ )
                  ( -SNQ**H  CSQ )
            The rows of the transformed A and B are parallel. Moreover, if the
            input 2-by-2 matrix A is not zero, then the transformed (1,1) entry
            of A is not zero. If the input matrices A and B are both not zero,
            then the transformed (2,2) element of B is not zero, except when the
            first rows of input A and B are parallel and the second rows are
            zero.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clapll(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},System.Single@)">
            <summary>
            <para>
            Two column vectors X and Y, let
                                 A = ( X Y ).</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The length of the vectors X and Y.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX array, dimension (1+(N-1)*INCX)
            On entry, X contains the N-vector X.
            On exit, X is overwritten.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive elements of X. INCX > 0.
            </code>
            </param>
            <param name="y">
            <code>
            Y is COMPLEX array, dimension (1+(N-1)*INCY)
            On entry, Y contains the N-vector Y.
            On exit, Y is overwritten.
            </code>
            <code>
            INCY is INTEGER
            The increment between successive elements of Y. INCY > 0.
            </code>
            </param>
            <param name="ssmin">
            <code>
            SSMIN is REAL
            The smallest singular value of the N-by-2 matrix A = ( X Y ).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The subroutine first computes the QR factorization of A = Q*R,
            and then computes the SVD of the 2-by-2 upper triangular matrix R.
            The smaller singular value of R is returned in SSMIN, which is used
            as the measurement of the linear dependency of the vectors X and Y.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ctgsja(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,System.Single,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@,System.Int32@)">
            <summary>
            <para>
            Computes the generalized singular value decomposition (GSVD)
            of two complex upper triangular (or trapezoidal) matrices A and B.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  U must contain a unitary matrix U1 on entry, and
                    the product U1*U is returned;
            = 'I':  U is initialized to the unit matrix, and the
                    unitary matrix U is returned;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  V must contain a unitary matrix V1 on entry, and
                    the product V1*V is returned;
            = 'I':  V is initialized to the unit matrix, and the
                    unitary matrix V is returned;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Q must contain a unitary matrix Q1 on entry, and
                    the product Q1*Q is returned;
            = 'I':  Q is initialized to the unit matrix, and the
                    unitary matrix Q is returned;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            K and L specify the subblocks in the input matrices A and B:
            A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,,N-L+1:N)
            of A and B, whose GSVD is going to be computed by CTGSJA.
            See Further Details.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
            matrix R or part of R.  See Purpose for details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
            a part of R.  See Purpose for details.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="tola">
            <code>
            TOLA is REAL
            </code>
            </param>
            <param name="tolb">
            <code>
            TOLB is REAL
            TOLA and TOLB are the convergence criteria for the Jacobi-
            Kogbetliantz iteration procedure. Generally, they are the
            same as used in the preprocessing step, say
                TOLA = MAX(M,N)*norm(A)*MACHEPS,
                TOLB = MAX(P,N)*norm(B)*MACHEPS.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is REAL array, dimension (N)
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is REAL array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L >= 0,
              ALPHA(K+1:K+L) = diag(C),
              BETA(K+1:K+L)  = diag(S),
            or if M-K-L &amp;lt; 0,
              ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
              BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
            Furthermore, if K+L &amp;lt; N,
              ALPHA(K+L+1:N) = 0
              BETA(K+L+1:N)  = 0.
            </code>
            </param>
            <param name="u">
            <code>
            U is COMPLEX array, dimension (LDU,M)
            On entry, if JOBU = 'U', U must contain a matrix U1 (usually
            the unitary matrix returned by CGGSVP).
            On exit,
            if JOBU = 'I', U contains the unitary matrix U;
            if JOBU = 'U', U contains the product U1*U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array, dimension (LDV,P)
            On entry, if JOBV = 'V', V must contain a matrix V1 (usually
            the unitary matrix returned by CGGSVP).
            On exit,
            if JOBV = 'I', V contains the unitary matrix V;
            if JOBV = 'V', V contains the product V1*V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX array, dimension (LDQ,N)
            On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
            the unitary matrix returned by CGGSVP).
            On exit,
            if JOBQ = 'I', Q contains the unitary matrix Q;
            if JOBQ = 'Q', Q contains the product Q1*Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (2*N)
            </code>
            </param>
            <param name="ncycle">
            <code>
            NCYCLE is INTEGER
            The number of cycles required for convergence.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1:  the procedure does not converge after MAXIT cycles.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On entry, it is assumed that matrices A and B have the following
            forms, which may be obtained by the preprocessing subroutine CGGSVP
            from a general M-by-N matrix A and P-by-N matrix B:
                         N-K-L  K    L
               A =    K ( 0    A12  A13 ) if M-K-L >= 0;
                      L ( 0     0   A23 )
                  M-K-L ( 0     0    0  )
                       N-K-L  K    L
               A =  K ( 0    A12  A13 ) if M-K-L &amp;lt; 0;
                  M-K ( 0     0   A23 )
                       N-K-L  K    L
               B =  L ( 0     0   B13 )
                  P-L ( 0     0    0  )
            where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
            upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
            otherwise A23 is (M-K)-by-L upper trapezoidal.
            On exit,
                   U**H *A*Q = D1*( 0 R ),    V**H *B*Q = D2*( 0 R ),
            where U, V and Q are unitary matrices.
            R is a nonsingular upper triangular matrix, and D1
            and D2 are ``diagonal'' matrices, which are of the following
            structures:
            If M-K-L >= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                               K  L
                   D2 = L   ( 0  S )
                        P-L ( 0  0 )
                           N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 ) K
                        L (  0    0   R22 ) L
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &amp;lt; 0,
                           K M-K K+L-M
                D1 =   K ( I  0    0   )
                     M-K ( 0  C    0   )
                             K M-K K+L-M
                D2 =   M-K ( 0  S    0   )
                     K+L-M ( 0  0    I   )
                       P-L ( 0  0    0   )
                           N-K-L  K   M-K  K+L-M
            ( 0 R ) =    K ( 0    R11  R12  R13  )
                      M-K ( 0     0   R22  R23  )
                    K+L-M ( 0     0    0   R33  )
            where
            C = diag( ALPHA(K+1), ... , ALPHA(M) ),
            S = diag( BETA(K+1),  ... , BETA(M) ),
            C**2 + S**2 = I.
            R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
                (  0  R22 R23 )
            in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The computation of the unitary transformation matrices U, V or Q
            is optional.  These matrices may either be formed explicitly, or they
            may be postmultiplied into input matrices U1, V1, or Q1.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            CTGSJA essentially uses a variant of Kogbetliantz algorithm to reduce
            min(L,M-K)-by-L triangular (or trapezoidal) matrix A23 and L-by-L
            matrix B13 to the form:
                     U1**H *A13*Q1 = C1*R1; V1**H *B13*Q1 = S1*R1,
            where U1, V1 and Q1 are unitary matrix.
            C1 and S1 are diagonal matrices satisfying
                          C1**2 + S1**2 = I,
            and R1 is an L-by-L nonsingular upper triangular matrix.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.TriangularMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            trapezoidal or triangular matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in CLANTR as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower trapezoidal.
            = 'U':  Upper trapezoidal
            = 'L':  Lower trapezoidal
            Note that A is triangular instead of trapezoidal if M = N.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A has unit diagonal.
            = 'N':  Non-unit diagonal
            = 'U':  Unit diagonal
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0, and if
            UPLO = 'U', M &amp;lt;= N.  When M = 0, CLANTR is set to zero.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0, and if
            UPLO = 'L', N &amp;lt;= M.  When N = 0, CLANTR is set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The trapezoidal matrix A (A is triangular if M = N).
            If UPLO = 'U', the leading m by n upper trapezoidal part of
            the array A contains the upper trapezoidal matrix, and the
            strictly lower triangular part of A is not referenced.
            If UPLO = 'L', the leading m by n lower trapezoidal part of
            the array A contains the lower trapezoidal matrix, and the
            strictly upper triangular part of A is not referenced.  Note
            that when DIAG = 'U', the diagonal elements of A are not
            referenced and are assumed to be one.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(M,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK)),
            where LWORK >= M when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            CLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.SymmetricMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex symmetric matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in CLANSY as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is to be referenced.
            = 'U':  Upper triangular part of A is referenced
            = 'L':  Lower triangular part of A is referenced
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, CLANSY is
            set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The symmetric matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(N,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
            WORK is not referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            CLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.HermitianMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex hermitian matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in CLANHE as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            hermitian matrix A is to be referenced.
            = 'U':  Upper triangular part of A is referenced
            = 'L':  Lower triangular part of A is referenced
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, CLANHE is
            set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The hermitian matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced. Note that the imaginary parts of the diagonal
            elements need not be set and are assumed to be zero.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(N,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
            WORK is not referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            CLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clauu2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the product U * U**H or L**H * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the triangular factor U or L.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U**H;
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L**H * L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.
            This is the unblocked form of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clauum(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the product U * U**H or L**H * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the triangular factor U or L.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U**H;
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L**H * L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.
            This is the blocked form of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clahef(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes a partial factorization of a complex Hermitian
            matrix A using the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The maximum number of columns of the matrix A that should be
            factored.  NB should be at least 2 to allow for 2-by-2 pivot
            blocks.
            </code>
            </param>
            <param name="kb">
            <code>
            KB is INTEGER
            The number of columns of A that were actually factored.
            KB is either NB-1 or NB, or N if N &amp;lt;= NB.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, A contains details of the partial factorization.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If UPLO = 'U', only the last KB elements of IPIV are set;
            if UPLO = 'L', only the first KB elements are set.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX array, dimension (LDW,NB)
            </code>
            <code>
            LDW is INTEGER
            The leading dimension of the array W.  LDW >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
                 has been completed, but the block diagonal matrix D is
                 exactly singular.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The
            partial factorization has the form:
            A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
                  ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
            A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
                  ( L21  I ) (  0  A22 ) (  0      I     )
            where the order of D is at most NB. The actual order is returned in
            the argument KB, and is either NB or NB-1, or N if N &amp;lt;= NB.
            Note that U**H denotes the conjugate transpose of U.
            CLAHEF is an auxiliary routine called by CHETRF. It uses blocked code
            (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
            A22 (if UPLO = 'L').
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clatrd(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Reduces NB rows and columns of a complex Hermitian matrix A to
            Hermitian tridiagonal form by a unitary similarity
            transformation Q**H * A * Q, and returns the matrices V and W which are
            needed to apply the transformation to the unreduced part of A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U': Upper triangular
            = 'L': Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of rows and columns to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit:
            if UPLO = 'U', the last NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements above the diagonal
              with the array TAU, represent the unitary matrix Q as a
              product of elementary reflectors;
            if UPLO = 'L', the first NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements below the diagonal
              with the array TAU, represent the  unitary matrix Q as a
              product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
            elements of the last NB columns of the reduced matrix;
            if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
            the first NB columns of the reduced matrix.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (N-1)
            The scalar factors of the elementary reflectors, stored in
            TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
            See Further Details.
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX array, dimension (LDW,NB)
            The n-by-nb matrix W required to update the unreduced part
            of A.
            </code>
            <code>
            LDW is INTEGER
            The leading dimension of the array W. LDW >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U', CLATRD reduces the last NB rows and columns of a
            matrix, of which the upper triangle is supplied;
            if UPLO = 'L', CLATRD reduces the first NB rows and columns of a
            matrix, of which the lower triangle is supplied.
            This is an auxiliary routine called by CHETRD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n) H(n-1) . . . H(n-nb+1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
            and tau in TAU(i-1).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(nb).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
            and tau in TAU(i).
            The elements of the vectors v together form the n-by-nb matrix V
            which is needed, with W, to apply the transformation to the unreduced
            part of the matrix, using a Hermitian rank-2k update of the form:
            A := A - V*W**H - W*V**H.
            The contents of A on exit are illustrated by the following examples
            with n = 5 and nb = 2:
            if UPLO = 'U':                       if UPLO = 'L':
              (  a   a   a   v4  v5 )              (  d                  )
              (      a   a   v4  v5 )              (  1   d              )
              (          a   1   v5 )              (  v1  1   a          )
              (              d   1  )              (  v1  v2  a   a      )
              (                  d  )              (  v1  v2  a   a   a  )
            where d denotes a diagonal element of the reduced matrix, a denotes
            an element of the original matrix that is unchanged, and vi denotes
            an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claed8(System.Int32@,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Single@,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@,Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Merges the two sets of eigenvalues together into a single
            sorted set.</para>
            </summary>
            <param name="k">
            <code>
            K is INTEGER
            Contains the number of non-deflated eigenvalues.
            This is the order of the related secular equation.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the unitary matrix used to reduce
            the dense or band matrix to tridiagonal form.
            QSIZ >= N if ICOMPQ = 1.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX array, dimension (LDQ,N)
            On entry, Q contains the eigenvectors of the partially solved
            system which has been previously updated in matrix
            multiplies with other partially solved eigensystems.
            On exit, Q contains the trailing (N-K) updated eigenvectors
            (those which were deflated) in its last N-K columns.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max( 1, N ).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, D contains the eigenvalues of the two submatrices to
            be combined.  On exit, D contains the trailing (N-K) updated
            eigenvalues (those which were deflated) sorted into increasing
            order.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            Contains the off diagonal element associated with the rank-1
            cut which originally split the two submatrices which are now
            being recombined. RHO is modified during the computation to
            the value required by SLAED3.
            </code>
            </param>
            <param name="cutpnt">
            <code>
            CUTPNT is INTEGER
            Contains the location of the last eigenvalue in the leading
            sub-matrix.  MIN(1,N) &amp;lt;= CUTPNT &amp;lt;= N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (N)
            On input this vector contains the updating vector (the last
            row of the first sub-eigenvector matrix and the first row of
            the second sub-eigenvector matrix).  The contents of Z are
            destroyed during the updating process.
            </code>
            </param>
            <param name="dlamda">
            <code>
            DLAMDA is REAL array, dimension (N)
            Contains a copy of the first K eigenvalues which will be used
            by SLAED3 to form the secular equation.
            </code>
            </param>
            <param name="q2">
            <code>
            Q2 is COMPLEX array, dimension (LDQ2,N)
            If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
            Contains a copy of the first K eigenvectors which will be used
            by SLAED7 in a matrix multiply (SGEMM) to update the new
            eigenvectors.
            </code>
            <code>
            LDQ2 is INTEGER
            The leading dimension of the array Q2.  LDQ2 >= max( 1, N ).
            </code>
            </param>
            <param name="w">
            <code>
            W is REAL array, dimension (N)
            This will hold the first k values of the final
            deflation-altered z-vector and will be passed to SLAED3.
            </code>
            </param>
            <param name="indxp">
            <code>
            INDXP is INTEGER array, dimension (N)
            This will contain the permutation used to place deflated
            values of D at the end of the array. On output INDXP(1:K)
            points to the nondeflated D-values and INDXP(K+1:N)
            points to the deflated eigenvalues.
            </code>
            </param>
            <param name="indx">
            <code>
            INDX is INTEGER array, dimension (N)
            This will contain the permutation used to sort the contents of
            D into ascending order.
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            This contains the permutation which separately sorts the two
            sub-problems in D into ascending order.  Note that elements in
            the second half of this permutation must first have CUTPNT
            added to their values in order to be accurate.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension (N)
            Contains the permutations (from deflation and sorting) to be
            applied to each eigenblock.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER
            Contains the number of Givens rotations which took place in
            this subproblem.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension (2, N)
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is REAL array, dimension (2, N)
            Each number indicates the S value to be used in the
            corresponding Givens rotation.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny element in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claed7(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="cutpnt">
            <code>
            CUTPNT is INTEGER
            Contains the location of the last eigenvalue in the leading
            sub-matrix.  min(1,N) &amp;lt;= CUTPNT &amp;lt;= N.
            </code>
            </param>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the unitary matrix used to reduce
            the full matrix to tridiagonal form.  QSIZ >= N.
            </code>
            </param>
            <param name="tlvls">
            <code>
            TLVLS is INTEGER
            The total number of merging levels in the overall divide and
            conquer tree.
            </code>
            </param>
            <param name="curlvl">
            <code>
            CURLVL is INTEGER
            The current level in the overall merge routine,
            0 &amp;lt;= curlvl &amp;lt;= tlvls.
            </code>
            </param>
            <param name="curpbm">
            <code>
            CURPBM is INTEGER
            The current problem in the current level in the overall
            merge routine (counting from upper left to lower right).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the eigenvalues of the rank-1-perturbed matrix.
            On exit, the eigenvalues of the repaired matrix.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX array, dimension (LDQ,N)
            On entry, the eigenvectors of the rank-1-perturbed matrix.
            On exit, the eigenvectors of the repaired tridiagonal matrix.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            Contains the subdiagonal element used to create the rank-1
            modification.
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            This contains the permutation which will reintegrate the
            subproblem just solved back into sorted order,
            ie. D( INDXQ( I = 1, N ) ) will be in ascending order.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (4*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array,
                                   dimension (3*N+2*QSIZ*N)
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (QSIZ*N)
            </code>
            </param>
            <param name="qstore">
            <code>
            QSTORE is REAL array, dimension (N**2+1)
            Stores eigenvectors of submatrices encountered during
            divide and conquer, packed together. QPTR points to
            beginning of the submatrices.
            </code>
            </param>
            <param name="qptr">
            <code>
            QPTR is INTEGER array, dimension (N+2)
            List of indices pointing to beginning of submatrices stored
            in QSTORE. The submatrices are numbered starting at the
            bottom left of the divide and conquer tree, from left to
            right and bottom to top.
            </code>
            </param>
            <param name="prmptr">
            <code>
            PRMPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in PERM a
            level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
            indicates the size of the permutation and also the size of
            the full, non-deflated problem.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension (N lg N)
            Contains the permutations (from deflation and sorting) to be
            applied to each eigenblock.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in GIVCOL a
            level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
            indicates the number of Givens rotations.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension (2, N lg N)
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is REAL array, dimension (2, N lg N)
            Each number indicates the S value to be used in the
            corresponding Givens rotation.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This
            routine is used only for the eigenproblem which requires all
            eigenvalues and optionally eigenvectors of a dense or banded
            Hermitian matrix that has been reduced to tridiagonal form.
              T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)
              where Z = Q**Hu, u is a vector of length N with ones in the
              CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:
                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine SLAED2.
                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine SLAED4 (as called by SLAED3).
                  This routine also calculates the eigenvectors of the current
                  problem.
                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Claed0(System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            The divide and conquer method, CLAED0 computes all eigenvalues
            of a symmetric tridiagonal matrix which is one diagonal block of
            those from reducing a dense or band Hermitian matrix and
            corresponding eigenvectors of the dense or band matrix.</para>
            </summary>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the unitary matrix used to reduce
            the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            On entry, the off-diagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX array, dimension (LDQ,N)
            On entry, Q must contain an QSIZ x N matrix whose columns
            unitarily orthonormal. It is a part of the unitary matrix
            that reduces the full dense Hermitian matrix to a
            (reducible) symmetric tridiagonal matrix.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array,
            the dimension of IWORK must be at least
                         6 + 6*N + 5*N*lg N
                         ( lg( N ) = smallest integer k
                                     such that 2^k >= N )
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array,
                                 dimension (1 + 3*N + 2*N*lg N + 3*N**2)
                          ( lg( N ) = smallest integer k
                                      such that 2^k >= N )
            </code>
            </param>
            <param name="qstore">
            <code>
            QSTORE is COMPLEX array, dimension (LDQS, N)
            Used to store parts of
            the eigenvector matrix when the updating matrix multiplies
            take place.
            </code>
            </param>
            <param name="ldqs">
            <code>
            LDQS is INTEGER
            The leading dimension of the array QSTORE.
            LDQS >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Clasr(Extreme.Mathematics.MatrixOperationSide,System.Char,System.Char,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Applies a sequence of real plane rotations to a complex matrix
            A, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            Specifies whether the plane rotation matrix P is applied to
            A on the left or the right.
            = 'L':  Left, compute A := P*A
            = 'R':  Right, compute A:= A*P**T
            </code>
            </param>
            <param name="pivot">
            <code>
            PIVOT is CHARACTER*1
            Specifies the plane for which P(k) is a plane rotation
            matrix.
            = 'V':  Variable pivot, the plane (k,k+1)
            = 'T':  Top pivot, the plane (1,k+1)
            = 'B':  Bottom pivot, the plane (k,z)
            </code>
            </param>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Specifies whether P is a forward or backward sequence of
            plane rotations.
            = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
            = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  If m &amp;lt;= 1, an immediate
            return is effected.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  If n &amp;lt;= 1, an
            immediate return is effected.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension
                    (M-1) if SIDE = 'L'
                    (N-1) if SIDE = 'R'
            The cosines c(k) of the plane rotations.
            </code>
            </param>
            <param name="s">
            <code>
            S is REAL array, dimension
                    (M-1) if SIDE = 'L'
                    (N-1) if SIDE = 'R'
            The sines s(k) of the plane rotations.  The 2-by-2 plane
            rotation part of the matrix P(k), R(k), has the form
            R(k) = (  c(k)  s(k) )
                   ( -s(k)  c(k) ).
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The M-by-N matrix A.  On exit, A is overwritten by P*A if
            SIDE = 'R' or by A*P**T if SIDE = 'L'.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            When SIDE = 'L', the transformation takes the form
               A := P*A
            and when SIDE = 'R', the transformation takes the form
               A := A*P**T
            where P is an orthogonal matrix consisting of a sequence of z plane
            rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
            and P**T is the transpose of P.
            When DIRECT = 'F' (Forward sequence), then
               P = P(z-1) * ... * P(2) * P(1)
            and when DIRECT = 'B' (Backward sequence), then
               P = P(1) * P(2) * ... * P(z-1)
            where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
               R(k) = (  c(k)  s(k) )
                    = ( -s(k)  c(k) ).
            When PIVOT = 'V' (Variable pivot), the rotation is performed
            for the plane (k,k+1), i.e., P(k) has the form
               P(k) = (  1                                            )
                      (       ...                                     )
                      (              1                                )
                      (                   c(k)  s(k)                  )
                      (                  -s(k)  c(k)                  )
                      (                                1              )
                      (                                     ...       )
                      (                                            1  )
            where R(k) appears as a rank-2 modification to the identity matrix in
            rows and columns k and k+1.
            When PIVOT = 'T' (Top pivot), the rotation is performed for the
            plane (1,k+1), so P(k) has the form
               P(k) = (  c(k)                    s(k)                 )
                      (         1                                     )
                      (              ...                              )
                      (                     1                         )
                      ( -s(k)                    c(k)                 )
                      (                                 1             )
                      (                                      ...      )
                      (                                             1 )
            where R(k) appears in rows and columns 1 and k+1.
            Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
            performed for the plane (k,z), giving P(k) the form
               P(k) = ( 1                                             )
                      (      ...                                      )
                      (             1                                 )
                      (                  c(k)                    s(k) )
                      (                         1                     )
                      (                              ...              )
                      (                                     1         )
                      (                 -s(k)                    c(k) )
            where R(k) appears in rows and columns k and z.  The rotations are
            performed without ever forming P(k) explicitly.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.TriangularBandMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n triangular band matrix A,  with ( k + 1 ) diagonals.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in CLANTB as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, CLANTB is
            set to zero.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of super-diagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals of the matrix A if UPLO = 'L'.
            K >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first k+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+k).
            Note that when DIAG = 'U', the elements of the array AB
            corresponding to the diagonal elements of the matrix A are
            not referenced, but are assumed to be one.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= K+1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            CLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.LUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,System.Single@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a general
            complex matrix A, in either the 1-norm or the infinity-norm, using
            the LU factorization computed by CGETRF.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by CGETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is REAL
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (2*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgetf2(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a general m-by-n matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the m by n matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, U(k,k) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = P * L * U
            where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m > n), and U is upper
            triangular (upper trapezoidal if m &amp;lt; n).
            This is the right-looking Level 2 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.LUDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = P * L * U
            where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m > n), and U is upper
            triangular (upper trapezoidal if m &amp;lt; n).
            This is the right-looking Level 3 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.LUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B,  A**T * X = B,  or  A**H * X = B
            with a general N-by-N matrix A using the LU factorization computed
            by CGETRF.</para>
            </summary>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B     (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose)
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by CGETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices from CGETRF; for 1&amp;lt;=i&amp;lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.LUInvert(System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a matrix using the LU factorization
            computed by CGETRF.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by CGETRF.
            On exit, if INFO = 0, the inverse of the original matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices from CGETRF; for 1&amp;lt;=i&amp;lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimal performance LWORK >= N*NB, where NB is
            the optimal blocksize returned by ILAENV.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This method inverts U and then computes inv(A) by solving the system
            inv(A)*L = inv(U) for inv(A).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgebak(System.Char,Extreme.Mathematics.MatrixOperationSide,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Forms the right or left eigenvectors of a complex general
            matrix by backward transformation on the computed eigenvectors of the
            balanced matrix output by CGEBAL.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
            Specifies the type of backward transformation required:
            = 'N', do nothing, return immediately;
            = 'P', do backward transformation for permutation only;
            = 'S', do backward transformation for scaling only;
            = 'B', do backward transformations for both permutation and
                   scaling.
            JOB must be the same as the argument JOB supplied to CGEBAL.
            </code>
            </param>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'R':  V contains right eigenvectors;
            = 'L':  V contains left eigenvectors.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of rows of the matrix V.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            The integers ILO and IHI determined by CGEBAL.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL array, dimension (N)
            Details of the permutation and scaling factors, as returned
            by CGEBAL.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of columns of the matrix V.  M >= 0.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array, dimension (LDV,M)
            On entry, the matrix of right or left eigenvectors to be
            transformed, as returned by CHSEIN or CTREVC.
            On exit, V is overwritten by the transformed eigenvectors.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgebal(System.Char,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@,System.Int32@,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Balances a general complex matrix A.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
            Specifies the operations to be performed on A:
            = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
                    for i = 1,...,N;
            = 'P':  permute only;
            = 'S':  scale only;
            = 'B':  both permute and scale.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the input matrix A.
            On exit,  A is overwritten by the balanced matrix.
            If JOB = 'N', A is not referenced.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI are set to integers such that on exit
            A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
            If JOB = 'N' or 'S', ILO = 1 and IHI = N.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL array, dimension (N)
            Details of the permutations and scaling factors applied to
            A.  If P(j) is the index of the row and column interchanged
            with row and column j and D(j) is the scaling factor
            applied to row and column j, then
            SCALE(j) = P(j)    for j = 1,...,ILO-1
                     = D(j)    for j = ILO,...,IHI
                     = P(j)    for j = IHI+1,...,N.
            The order in which the interchanges are made is N to IHI+1,
            then 1 to ILO-1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This involves, first,
            permuting A by a similarity transformation to isolate eigenvalues
            in the first 1 to ILO-1 and last IHI+1 to N elements on the
            diagonal; and second, applying a diagonal similarity transformation
            to rows and columns ILO to IHI to make the rows and columns as
            close in norm as possible.  Both steps are optional.
            Balancing may reduce the 1-norm of the matrix, and improve the
            accuracy of the computed eigenvalues and/or eigenvectors.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The permutations consist of row and column interchanges which put
            the matrix in the form
                       ( T1   X   Y  )
               P A P = (  0   B   Z  )
                       (  0   0   T2 )
            where T1 and T2 are upper triangular matrices whose eigenvalues lie
            along the diagonal.  The column indices ILO and IHI mark the starting
            and ending columns of the submatrix B. Balancing consists of applying
            a diagonal similarity transformation inv(D) * B * D to make the
            1-norms of each row of B and its corresponding column nearly equal.
            The output matrix is
               ( T1     X*D          Y    )
               (  0  inv(D)*B*D  inv(D)*Z ).
               (  0      0           T2   )
            Information about the permutations P and the diagonal matrix D is
            returned in the vector SCALE.
            This subroutine is based on the EISPACK routine CBAL.
            Modified by Tzu-Yi Chen, Computer Science Division, University of
              California at Berkeley, USA
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgehd2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Reduces a complex general matrix A to upper Hessenberg form H
            by a unitary similarity transformation:  Q**H * A * Q = H .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to CGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= max(1,N).
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the n by n general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the unitary matrix Q as a product of elementary
            reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of (ihi-ilo) elementary
            reflectors
               Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
            exit in A(i+2:ihi,i), and tau in TAU(i).
            The contents of A are illustrated by the following example, with
            n = 7, ilo = 2 and ihi = 6:
            on entry,                        on exit,
            ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
            (                         a )    (                          a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgehrd(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a complex general matrix A to upper Hessenberg form H by
            an unitary similarity transformation:  Q**H * A * Q = H .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to CGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the N-by-N general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the unitary matrix Q as a product of elementary
            reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
            zero.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of (ihi-ilo) elementary
            reflectors
               Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
            exit in A(i+2:ihi,i), and tau in TAU(i).
            The contents of A are illustrated by the following example, with
            n = 7, ilo = 2 and ihi = 6:
            on entry,                        on exit,
            ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
            (                         a )    (                          a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            This file is a slight modification of LAPACK-3.0's DGEHRD
            subroutine incorporating improvements proposed by Quintana-Orti and
            Van de Geijn (2006). (See DLAHR2.)
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgeev(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes for an N-by-N complex nonsymmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
            </summary>
            <param name="jobvl">
            <code>
            JOBVL is CHARACTER*1
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of are computed.
            </code>
            </param>
            <param name="jobvr">
            <code>
            JOBVR is CHARACTER*1
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A. N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX array, dimension (N)
            W contains the computed eigenvalues.
            </code>
            </param>
            <param name="vl">
            <code>
            VL is COMPLEX array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            u(j) = VL(:,j), the j-th column of VL.
            </code>
            <code>
            LDVL is INTEGER
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.
            </code>
            </param>
            <param name="vr">
            <code>
            VR is COMPLEX array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            v(j) = VR(:,j), the j-th column of VR.
            </code>
            <code>
            LDVR is INTEGER
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,2*N).
            For good performance, LWORK must generally be larger.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (2*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements and i+1:N of W contain eigenvalues which have
                  converged.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**H * A = lambda(j) * u(j)**H
            where u(j)**H denotes the conjugate transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgeqr2(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization of a complex m by n matrix A:
            A = Q * R.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(m,n) by n upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization of a complex M-by-N matrix A:
            A = Q * R.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgeqp3(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization with column pivoting of a
            matrix A:  A*P = Q*R  using Level 3 BLAS.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper trapezoidal matrix R; the elements below
            the diagonal, together with the array TAU, represent the
            unitary matrix Q as a product of min(M,N) elementary
            reflectors.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(J).ne.0, the J-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(J)=0,
            the J-th column of A is a free column.
            On exit, if JPVT(J)=K, then the J-th column of A*P was the
            the K-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= N+1.
            For optimal performance LWORK >= ( N+1 )*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (2*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit.
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a real/complex vector
            with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
            A(i+1:m,i), and tau in TAU(i).
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgebd2(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Reduces a complex general m by n matrix A to upper or lower
            real bidiagonal form B by a unitary transformation: Q**H * A * P = B.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the unitary matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors;
            if m &amp;lt; n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the unitary matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m &amp;lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is COMPLEX array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (max(M,N))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, B is upper bidiagonal; if m &amp;lt; n, B is lower bidiagonal.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
            If m >= n,
               Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
            where tauq and taup are complex scalars, and v and u are complex
            vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
            A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
            A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n,
               Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
            where tauq and taup are complex scalars, v and u are complex vectors;
            v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
            u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
            tauq is stored in TAUQ(i) and taup in TAUP(i).
            The contents of A on exit are illustrated by the following examples:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
              (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
              (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
              (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
              (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
              (  v1  v2  v3  v4  v5 )
            where d and e denote diagonal and off-diagonal elements of B, vi
            denotes an element of the vector defining H(i), and ui an element of
            the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgebrd(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a general complex M-by-N matrix A to upper or lower
            bidiagonal form B by a unitary transformation: Q**H * A * P = B.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the unitary matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors;
            if m &amp;lt; n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the unitary matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m &amp;lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is COMPLEX array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of the array WORK.  LWORK >= max(1,M,N).
            For optimum performance LWORK >= (M+N)*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, B is upper bidiagonal; if m &amp;lt; n, B is lower bidiagonal.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
            If m >= n,
               Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
            where tauq and taup are complex scalars, and v and u are complex
            vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
            A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
            A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n,
               Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
            where tauq and taup are complex scalars, and v and u are complex
            vectors; v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in
            A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in
            A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            The contents of A on exit are illustrated by the following examples:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
              (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
              (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
              (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
              (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
              (  v1  v2  v3  v4  v5 )
            where d and e denote diagonal and off-diagonal elements of B, vi
            denotes an element of the vector defining H(i), and ui an element of
            the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgelq2(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes an LQ factorization of a complex m by n matrix A:
            A = L * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m by min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &amp;lt;= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k)**H . . . H(2)**H H(1)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
            A(i,i+1:n), and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgelqf(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes an LQ factorization of a complex M-by-N matrix A:
            A = L * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &amp;lt;= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,M).
            For optimum performance LWORK >= M*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k)**H . . . H(2)**H H(1)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
            A(i,i+1:n), and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgesdd(System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors, by using divide-and-conquer method.</para>
            </summary>
            <param name="jobz">
            <code>
            JOBZ is CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V**H are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V**H are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    in the array A and all rows of V**H are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V**H are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V**H are computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the input matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the input matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M >= N;
                            A is overwritten with the first M rows
                            of V**H (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="s">
            <code>
            S is REAL array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) >= S(i+1).
            </code>
            </param>
            <param name="u">
            <code>
            U is COMPLEX array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &amp;lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &amp;lt; N, U contains the M-by-M
            unitary matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &amp;lt; N, LDU >= M.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is COMPLEX array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            N-by-N unitary matrix V**H;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V**H (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &amp;lt; N, or JOBZ = 'N', VT is not referenced.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            if JOBZ = 'S', LDVT >= min(M,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= 1.
            if JOBZ = 'N', LWORK >= 2*min(M,N)+max(M,N).
            if JOBZ = 'O',
                  LWORK >= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
            if JOBZ = 'S' or 'A',
                  LWORK >= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
            For good performance, LWORK should generally be larger.
            If LWORK = -1, a workspace query is assumed.  The optimal
            size for the WORK array is calculated and stored in WORK(1),
            and no other work except argument checking is performed.
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (MAX(1,LRWORK))
            If JOBZ = 'N', LRWORK >= 5*min(M,N).
            Otherwise,
            LRWORK >= min(M,N)*max(5*min(M,N)+7,2*max(M,N)+2*min(M,N)+1)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (8*min(M,N))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The updating process of SBDSDC did not converge.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The SVD is written
                 A = U * SIGMA * conjugate-transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**H, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgeqpf(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Routine is deprecated and has been replaced by routine CGEQP3.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper triangular matrix R; the elements
            below the diagonal, together with the array TAU,
            represent the unitary matrix Q as a product of
            min(m,n) elementary reflectors.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(i) = 0,
            the i-th column of A is a free column.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (2*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            CGEQPF computes a QR factorization with column pivoting of a
            complex M-by-N matrix A: A*P = Q*R.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(n)
            Each H(i) has the form
               H = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).
            The matrix P is represented in jpvt as follows: If
               jpvt(j) = i
            then the jth column of P is the ith canonical unit vector.
            Partial column norm updating strategy modified by
              Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
              University of Zagreb, Croatia.
            -- April 2011                                                      --
            For more details see LAPACK Working Note 176.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgerq2(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes an RQ factorization of a complex m by n matrix A:
            A = R * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, if m &amp;lt;= n, the upper triangle of the subarray
            A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
            if m >= n, the elements on and above the (m-n)-th subdiagonal
            contain the m by n upper trapezoidal matrix R; the remaining
            elements, with the array TAU, represent the unitary matrix
            Q as a product of elementary reflectors (see Further
            Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1)**H H(2)**H . . . H(k)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
            exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandLUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Single,System.Single@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a complex
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by CGBTRF.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by CGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is REAL
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cgbtf2(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a complex m-by-n band matrix
            A using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&amp;lt;=i&amp;lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U, because of fill-in resulting from the row
            interchanges.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a complex m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&amp;lt;=i&amp;lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandLUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B,  A**T * X = B,  or  A**H * X = B
            with a general band matrix A using the LU factorization computed
            by CGBTRF.</para>
            </summary>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations.
            = 'N':  A * X = B     (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose)
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by CGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cggsvp(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,System.Single,System.Int32@,System.Int32@,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes unitary matrices U, V and Q such that
                               N-K-L  K    L
             U**H*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;
                            L ( 0     0   A23 )
                        M-K-L ( 0     0    0  )
                             N-K-L  K    L
                    =     K ( 0    A12  A13 )  if M-K-L &amp;lt; 0;
                        M-K ( 0     0   A23 )
                             N-K-L  K    L
             V**H*B*Q =   L ( 0     0   B13 )
                        P-L ( 0     0    0  )
            where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
            upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
            otherwise A23 is (M-K)-by-L upper trapezoidal.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  Unitary matrix U is computed;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  Unitary matrix V is computed;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Unitary matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular (or trapezoidal) matrix
            described in the Purpose section.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains the triangular matrix described in
            the Purpose section.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="tola">
            <code>
            TOLA is REAL
            </code>
            </param>
            <param name="tolb">
            <code>
            TOLB is REAL
            TOLA and TOLB are the thresholds to determine the effective
            numerical rank of matrix B and a subblock of A. Generally,
            they are set to
               TOLA = MAX(M,N)*norm(A)*MACHEPS,
               TOLB = MAX(P,N)*norm(B)*MACHEPS.
            The size of TOLA and TOLB may affect the size of backward
            errors of the decomposition.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose section.
            K + L = effective numerical rank of (A**H,B**H)**H.
            </code>
            </param>
            <param name="u">
            <code>
            U is COMPLEX array, dimension (LDU,M)
            If JOBU = 'U', U contains the unitary matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array, dimension (LDV,P)
            If JOBV = 'V', V contains the unitary matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the unitary matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (2*N)
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (N)
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (max(3*N,M,P))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            K+L = the effective
            numerical rank of the (M+P)-by-N matrix (A**H,B**H)**H.
            This decomposition is the preprocessing step for computing the
            Generalized Singular Value Decomposition (GSVD), see subroutine
            CGGSVD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
             The subroutine uses LAPACK subroutine CGEQPF for the QR factorization
             with column pivoting to detect the effective numerical rank of the
             a matrix. It may be replaced by a better rank determination strategy.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cggsvd(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the generalized singular value decomposition (GSVD)
            of an M-by-N complex matrix A and P-by-N complex matrix B:
                  U**H*A*Q = D1*( 0 R ),    V**H*B*Q = D2*( 0 R )
            where U, V and Q are unitary matrices.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  Unitary matrix U is computed;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  Unitary matrix V is computed;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Unitary matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose.
            K + L = effective numerical rank of (A**H,B**H)**H.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular matrix R, or part of R.
            See Purpose for details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains part of the triangular matrix R if
            M-K-L &amp;lt; 0.  See Purpose for details.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is REAL array, dimension (N)
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is REAL array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L >= 0,
              ALPHA(K+1:K+L) = C,
              BETA(K+1:K+L)  = S,
            or if M-K-L &amp;lt; 0,
              ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
              BETA(K+1:M) =S, BETA(M+1:K+L) =1
            and
              ALPHA(K+L+1:N) = 0
              BETA(K+L+1:N)  = 0
            </code>
            </param>
            <param name="u">
            <code>
            U is COMPLEX array, dimension (LDU,M)
            If JOBU = 'U', U contains the M-by-M unitary matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX array, dimension (LDV,P)
            If JOBV = 'V', V contains the P-by-P unitary matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the N-by-N unitary matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (max(3*N,M,P)+N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (2*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            On exit, IWORK stores the sorting information. More
            precisely, the following loop will sort ALPHA
               for I = K+1, min(M,K+L)
                   swap ALPHA(I) and ALPHA(IWORK(I))
               endfor
            such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, the Jacobi-type procedure failed to
                  converge.  For further details, see subroutine CTGSJA.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Let K+L = the effective numerical rank of the
            matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
            triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
            matrices and of the following structures, respectively:
            If M-K-L >= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                              K  L
                   D2 =   L ( 0  S )
                        P-L ( 0  0 )
                            N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 )
                        L (  0    0   R22 )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &amp;lt; 0,
                              K M-K K+L-M
                   D1 =   K ( I  0    0   )
                        M-K ( 0  C    0   )
                                K M-K K+L-M
                   D2 =   M-K ( 0  S    0  )
                        K+L-M ( 0  0    I  )
                          P-L ( 0  0    0  )
                               N-K-L  K   M-K  K+L-M
              ( 0 R ) =     K ( 0    R11  R12  R13  )
                          M-K ( 0     0   R22  R23  )
                        K+L-M ( 0     0    0   R33  )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(M) ),
              S = diag( BETA(K+1),  ... , BETA(M) ),
              C**2 + S**2 = I.
              (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
              ( 0  R22 R23 )
              in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The routine computes C, S, R, and optionally the unitary
            transformation matrices U, V and Q.
            In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
            A and B implicitly gives the SVD of A*inv(B):
                                 A*inv(B) = U*(D1*inv(D2))*V**H.
            If ( A**H,B**H)**H has orthnormal columns, then the GSVD of A and B is also
            equal to the CS decomposition of A and B. Furthermore, the GSVD can
            be used to derive the solution of the eigenvalue problem:
                                 A**H*A x = lambda* B**H*B x.
            In some literature, the GSVD of A and B is presented in the form
                             U**H*A*X = ( 0 D1 ),   V**H*B*X = ( 0 D2 )
            where U and V are orthogonal and X is nonsingular, and D1 and D2 are
            ``diagonal''.  The former GSVD form can be converted to the latter
            form by taking the nonsingular matrix X as
                                  X = Q*(  I   0    )
                                        (  0 inv(R) )
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Chetf2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a complex Hermitian matrix A
            using the Bunch-Kaufman diagonal pivoting method:
               A = U*D*U**H  or  A = L*D*L**H
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, U**H is the conjugate transpose of U, and D is
            Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
                 has been completed, but the block diagonal matrix D is
                 exactly singular, and division by zero will occur if it
                 is used to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            09-29-06 - patch from
              Bobby Cheng, MathWorks
              Replace l.210 and l.392
                   IF( MAX( ABSAKK, COLMAX ).EQ.ZERO ) THEN
              by
                   IF( (MAX( ABSAKK, COLMAX ).EQ.ZERO) .OR. SISNAN(ABSAKK) ) THEN
            01-01-96 - Based on modifications by
              J. Lewis, Boeing Computer Services Company
              A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
            If UPLO = 'U', then A = U*D*U**H, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L**H, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.HermitianDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a complex Hermitian matrix A
            using the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of WORK.  LWORK >=1.  For best performance
            LWORK >= N*NB, where NB is the block size returned by ILAENV.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The form of the
            factorization is
               A = U*D*U**H  or  A = L*D*L**H
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is Hermitian and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', then A = U*D*U**H, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L**H, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.HermitianSolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a complex
            Hermitian matrix A using the factorization A = U*D*U**H or
            A = L*D*L**H computed by CHETRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**H;
            = 'L':  Lower triangular, form is A = L*D*L**H.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by CHETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by CHETRF.
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.HermitianInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a complex Hermitian indefinite matrix
            A using the factorization A = U*D*U**H or A = L*D*L**H computed by
            CHETRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**H;
            = 'L':  Lower triangular, form is A = L*D*L**H.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by CHETRF.
            On exit, if INFO = 0, the (Hermitian) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by CHETRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.HermitianEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Single,System.Single@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a complex
            Hermitian matrix A using the factorization A = U*D*U**H or
            A = L*D*L**H computed by CHETRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**H;
            = 'L':  Lower triangular, form is A = L*D*L**H.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by CHETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by CHETRF.
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is REAL
            The 1-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (2*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Chetd2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Reduces a complex Hermitian matrix A to real symmetric
            tridiagonal form T by a unitary similarity transformation:
            Q**H * A * Q = T.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the unitary
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the unitary matrix Q as a product
            of elementary reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n-1) . . . H(2) H(1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
            A(1:i-1,i+1), and tau in TAU(i).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(n-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
            and tau in TAU(i).
            The contents of A on exit are illustrated by the following examples
            with n = 5:
            if UPLO = 'U':                       if UPLO = 'L':
              (  d   e   v2  v3  v4 )              (  d                  )
              (      d   e   v3  v4 )              (  e   d              )
              (          d   e   v4 )              (  v1  e   d          )
              (              d   e  )              (  v1  v2  e   d      )
              (                  d  )              (  v1  v2  v3  e   d  )
            where d and e denote diagonal and off-diagonal elements of T, and vi
            denotes an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Chetrd(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a complex Hermitian matrix A to real symmetric
            tridiagonal form T by a unitary similarity transformation:
            Q**H * A * Q = T.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the unitary
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the unitary matrix Q as a product
            of elementary reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= 1.
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n-1) . . . H(2) H(1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
            A(1:i-1,i+1), and tau in TAU(i).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(n-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
            and tau in TAU(i).
            The contents of A on exit are illustrated by the following examples
            with n = 5:
            if UPLO = 'U':                       if UPLO = 'L':
              (  d   e   v2  v3  v4 )              (  d                  )
              (      d   e   v3  v4 )              (  e   d              )
              (          d   e   v4 )              (  v1  e   d          )
              (              d   e  )              (  v1  v2  e   d      )
              (                  d  )              (  v1  v2  v3  e   d  )
            where d and e denote diagonal and off-diagonal elements of T, and vi
            denotes an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cheevd(System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            complex Hermitian matrix A.</para>
            </summary>
            <param name="jobz">
            <code>
            JOBZ is CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is REAL array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of the array WORK.
            If N &amp;lt;= 1,                LWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LWORK must be at least N + 1.
            If JOBZ  = 'V' and N > 1, LWORK must be at least 2*N + N**2.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK, RWORK and
            IWORK arrays, returns these values as the first entries of
            the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array,
                                           dimension (LRWORK)
            On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
            </code>
            </param>
            <param name="lrwork">
            <code>
            LRWORK is INTEGER
            The dimension of the array RWORK.
            If N &amp;lt;= 1,                LRWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LRWORK must be at least N.
            If JOBZ  = 'V' and N > 1, LRWORK must be at least
                           1 + 5*N + 2*N**2.
            If LRWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </code>
            </param>
            <param name="liwork">
            <code>
            LIWORK is INTEGER
            The dimension of the array IWORK.
            If N &amp;lt;= 1,                LIWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
            If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the submatrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
             Modified description of INFO. Sven, 16 Feb 05.
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandCholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,System.Single@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite band matrix using
            the Cholesky factorization A = U**H*U or A = L*L**H computed by
            CPBTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**H*U or A = L*L**H of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is REAL
            The 1-norm (or infinity-norm) of the Hermitian band matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cpbtf2(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of super-diagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U**H *U or A = L*L**H of the band
            matrix A, in the same storage format as A.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**H * U ,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix, U**H is the conjugate transpose
            of U, and L is lower triangular.
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandCholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U**H*U or A = L*L**H of the band
            matrix A, in the same storage format as A.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**H * U,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
             Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandCholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a Hermitian
            positive definite band matrix A using the Cholesky factorization
            A = U**H*U or A = L*L**H computed by CPBTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**H*U or A = L*L**H of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cpotf2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n by n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**H *U  or A = L*L**H.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**H * U ,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.CholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,System.Single@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite matrix using the
            Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**H*U or A = L*L**H, as computed by CPOTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is REAL
            The 1-norm (or infinity-norm) of the Hermitian matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.CholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**H*U or A = L*L**H.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**H * U,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            This is the block version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.CholeskyInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a complex Hermitian positive definite
            matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
            computed by CPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U**H*U or A = L*L**H, as computed by
            CPOTRF.
            On exit, the upper or lower triangle of the (Hermitian)
            inverse of A, overwriting the input factor U or L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.CholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a Hermitian
            positive definite matrix A using the Cholesky factorization
            A = U**H*U or A = L*L**H computed by CPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**H*U or A = L*L**H, as computed by CPOTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Csteqr(System.Char,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the implicit QL or QR method.</para>
            </summary>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'V':  Compute eigenvalues and eigenvectors of the original
                    Hermitian matrix.  On entry, Z must contain the
                    unitary matrix used to reduce the original matrix
                    to tridiagonal form.
            = 'I':  Compute eigenvalues and eigenvectors of the
                    tridiagonal matrix.  Z is initialized to the identity
                    matrix.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX array, dimension (LDZ, N)
            On entry, if  COMPZ = 'V', then Z contains the unitary
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original Hermitian matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If COMPZ = 'N', then Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z.  LDZ >= 1, and if
            eigenvectors are desired, then  LDZ >= max(1,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (max(1,2*N-2))
            If COMPZ = 'N', then WORK is not referenced.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm has failed to find all the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero; on exit, D
                  and E contain the elements of a symmetric tridiagonal
                  matrix which is unitarily similar to the original
                  matrix.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The eigenvectors of a full or band complex Hermitian matrix can also
            be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
            matrix to tridiagonal form.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cstedc(System.Char,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.</para>
            </summary>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'I':  Compute eigenvectors of tridiagonal matrix also.
            = 'V':  Compute eigenvectors of original Hermitian matrix
                    also.  On entry, Z contains the unitary matrix used
                    to reduce the original matrix to tridiagonal form.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            On entry, the subdiagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX array, dimension (LDZ,N)
            On entry, if COMPZ = 'V', then Z contains the unitary
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original Hermitian matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If  COMPZ = 'N', then Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z.  LDZ >= 1.
            If eigenvectors are desired, then LDZ >= max(1,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If COMPZ = 'N' or 'I', or N &amp;lt;= 1, LWORK must be at least 1.
            If COMPZ = 'V' and N > 1, LWORK must be at least N*N.
            Note that for COMPZ = 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LWORK need
            only be 1.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK, RWORK and
            IWORK arrays, returns these values as the first entries of
            the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (MAX(1,LRWORK))
            On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
            </code>
            </param>
            <param name="lrwork">
            <code>
            LRWORK is INTEGER
            The dimension of the array RWORK.
            If COMPZ = 'N' or N &amp;lt;= 1, LRWORK must be at least 1.
            If COMPZ = 'V' and N > 1, LRWORK must be at least
                           1 + 3*N + 2*N*lg N + 4*N**2 ,
                           where lg( N ) = smallest integer k such
                           that 2**k >= N.
            If COMPZ = 'I' and N > 1, LRWORK must be at least
                           1 + 4*N + 2*N**2 .
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LRWORK
            need only be max(1,2*(N-1)).
            If LRWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </code>
            </param>
            <param name="liwork">
            <code>
            LIWORK is INTEGER
            The dimension of the array IWORK.
            If COMPZ = 'N' or N &amp;lt;= 1, LIWORK must be at least 1.
            If COMPZ = 'V' or N > 1,  LIWORK must be at least
                                      6 + 6*N + 5*N*lg N.
            If COMPZ = 'I' or N > 1,  LIWORK must be at least
                                      3 + 5*N .
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LIWORK
            need only be 1.
            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The eigenvectors of a full or band complex Hermitian matrix can also
            be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
            matrix to tridiagonal form.
            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See SLAED3 for details.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ctrti2(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a complex upper or lower triangular
            matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading n by n upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the Level 2 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.TriangularInvert(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a complex upper or lower triangular
            matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                 matrix is singular and its inverse can not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the Level 3 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ctrexc(System.Char,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32,System.Int32@)">
            <summary>
            <para>
            Reorders the Schur factorization of a complex matrix
            A = Q*T*Q**H, so that the diagonal element of T with row index IFST
            is moved to row ILST.</para>
            </summary>
            <param name="compq">
            <code>
            COMPQ is CHARACTER*1
            = 'V':  update the matrix Q of Schur vectors;
            = 'N':  do not update Q.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix T. N >= 0.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX array, dimension (LDT,N)
            On entry, the upper triangular matrix T.
            On exit, the reordered upper triangular matrix.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX array, dimension (LDQ,N)
            On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
            On exit, if COMPQ = 'V', Q has been postmultiplied by the
            unitary transformation matrix Z which reorders T.
            If COMPQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="ifst">
            <code>
            IFST is INTEGER
            </code>
            </param>
            <param name="ilst">
            <code>
            ILST is INTEGER
            Specify the reordering of the diagonal elements of T:
            The element with row index IFST is moved to row ILST by a
            sequence of transpositions between adjacent elements.
            1 &amp;lt;= IFST &amp;lt;= N; 1 &amp;lt;= ILST &amp;lt;= N.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The Schur form T is reordered by a unitary similarity transformation
            Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
            postmultplying it with Z.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ctrevc(Extreme.Mathematics.MatrixOperationSide,System.Char,Extreme.Collections.Array1D{System.Boolean},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes some or all of the right and/or left eigenvectors of
            a complex upper triangular matrix T.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'R':  compute right eigenvectors only;
            = 'L':  compute left eigenvectors only;
            = 'B':  compute both right and left eigenvectors.
            </code>
            </param>
            <param name="howmny">
            <code>
            HOWMNY is CHARACTER*1
            = 'A':  compute all right and/or left eigenvectors;
            = 'B':  compute all right and/or left eigenvectors,
                    backtransformed using the matrices supplied in
                    VR and/or VL;
            = 'S':  compute selected right and/or left eigenvectors,
                    as indicated by the logical array SELECT.
            </code>
            </param>
            <param name="select">
            <code>
            SELECT is LOGICAL array, dimension (N)
            If HOWMNY = 'S', SELECT specifies the eigenvectors to be
            computed.
            The eigenvector corresponding to the j-th eigenvalue is
            computed if SELECT(j) = .TRUE..
            Not referenced if HOWMNY = 'A' or 'B'.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix T. N >= 0.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX array, dimension (LDT,N)
            The upper triangular matrix T.  T is modified, but restored
            on exit.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
            </code>
            </param>
            <param name="vl">
            <code>
            VL is COMPLEX array, dimension (LDVL,MM)
            On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
            contain an N-by-N matrix Q (usually the unitary matrix Q of
            Schur vectors returned by CHSEQR).
            On exit, if SIDE = 'L' or 'B', VL contains:
            if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
            if HOWMNY = 'B', the matrix Q*Y;
            if HOWMNY = 'S', the left eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VL, in the same order as their
                             eigenvalues.
            Not referenced if SIDE = 'R'.
            </code>
            <code>
            LDVL is INTEGER
            The leading dimension of the array VL.  LDVL >= 1, and if
            SIDE = 'L' or 'B', LDVL >= N.
            </code>
            </param>
            <param name="vr">
            <code>
            VR is COMPLEX array, dimension (LDVR,MM)
            On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
            contain an N-by-N matrix Q (usually the unitary matrix Q of
            Schur vectors returned by CHSEQR).
            On exit, if SIDE = 'R' or 'B', VR contains:
            if HOWMNY = 'A', the matrix X of right eigenvectors of T;
            if HOWMNY = 'B', the matrix Q*X;
            if HOWMNY = 'S', the right eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VR, in the same order as their
                             eigenvalues.
            Not referenced if SIDE = 'L'.
            </code>
            <code>
            LDVR is INTEGER
            The leading dimension of the array VR.  LDVR >= 1, and if
            SIDE = 'R' or 'B'; LDVR >= N.
            </code>
            </param>
            <param name="mm">
            <code>
            MM is INTEGER
            The number of columns in the arrays VL and/or VR. MM >= M.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of columns in the arrays VL and/or VR actually
            used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
            is set to N.  Each selected eigenvector occupies one
            column.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Matrices of this type are produced by the Schur factorization of
            a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
            The right eigenvector x and the left eigenvector y of T corresponding
            to an eigenvalue w are defined by:
                         T*x = w*x,     (y**H)*T = w*(y**H)
            where y**H denotes the conjugate transpose of the vector y.
            The eigenvalues are not input to this routine, but are read directly
            from the diagonal of T.
            This routine returns the matrices X and/or Y of right and left
            eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
            input matrix.  If Q is the unitary factor that reduces a matrix A to
            Schur form T, then Q*X and Q*Y are the matrices of right and left
            eigenvectors of A.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The algorithm used in this program is basically backward (forward)
            substitution, with scaling to make the the code robust against
            possible overflow.
            Each eigenvector is normalized so that the element of largest
            magnitude has magnitude 1; here the magnitude of a complex number
            (x,y) is taken to be |x| + |y|.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.TriangularEstimateCondition(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a
            triangular matrix A, in either the 1-norm or the infinity-norm.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.TriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B,  A**T * X = B,  or  A**H * X = B,
            where A is a triangular matrix of order N, and B is an N-by-NRHS
            matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B     (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, the i-th diagonal element of A is zero,
                 indicating that the matrix is singular and the solutions
                 X have not been computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            A check is made to verify that A is nonsingular.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ctbcon(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a
            triangular band matrix A, in either the 1-norm or the infinity-norm.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of the array. The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ctbtrs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B,  A**T * X = B,  or  A**H * X = B,
            where A is a triangular band matrix of order N, and B is an
            N-by-NRHS matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B     (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the i-th diagonal element of A is zero,
                  indicating that the matrix is singular and the
                  solutions X have not been computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            A check is made to verify that A is nonsingular.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunm2r(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex m-by-n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**H if SIDE = 'R' and TRANS = 'C',
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left
            = 'R': apply Q or Q**H from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQRF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by CGEQRF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.QRUnitaryMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGEQRF in the first k columns of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQRF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunmhr(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI must have the same values as in the previous call
            of CGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            If SIDE = 'L', then 1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= M, if M > 0, and
            ILO = 1 and IHI = 0, if M = 0;
            if SIDE = 'R', then 1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0, and
            ILO = 1 and IHI = 0, if N = 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by CGEHRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEHRD.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q is defined as the product of
            IHI-ILO elementary reflectors, as returned by CGEHRD:
            Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cung2r(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Generates an m by n complex matrix Q with orthonormal columns,
            which is defined as the first n columns of a product of k elementary
            reflectors of order m
                  Q  =  H(1) H(2) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. M >= N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by CGEQRF in the first k columns of its array
            argument A.
            On exit, the m by n matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by CGEQRF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cungqr(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates an M-by-N complex matrix Q with orthonormal columns,
            which is defined as the first N columns of a product of K elementary
            reflectors of order M
                  Q  =  H(1) H(2) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. M >= N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by CGEQRF in the first k columns of its array
            argument A.
            On exit, the M-by-N matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by CGEQRF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunghr(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates a complex unitary matrix Q which is defined as the
            product of IHI-ILO elementary reflectors of order N, as returned by
            CGEHRD:
            Q = H(ilo) H(ilo+1) .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix Q. N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI must have the same values as in the previous call
            of CGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by CGEHRD.
            On exit, the N-by-N unitary matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (N-1)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEHRD.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= IHI-ILO.
            For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(ihi-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cungl2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Generates an m-by-n complex matrix Q with orthonormal rows,
            which is defined as the first m rows of a product of k elementary
            reflectors of order n
                  Q  =  H(k)**H .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. N >= M.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by CGELQF in the first k rows of its array argument A.
            On exit, the m by n matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGELQF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2)**H H(1)**H
            as returned by CGELQF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunglq(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates an M-by-N complex matrix Q with orthonormal rows,
            which is defined as the first M rows of a product of K elementary
            reflectors of order N
                  Q  =  H(k)**H .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. N >= M.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by CGELQF in the first k rows of its array argument A.
            On exit, the M-by-N matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGELQF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,M).
            For optimum performance LWORK >= M*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit;
            &amp;lt; 0:  if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2)**H H(1)**H
            as returned by CGELQF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cungbr(System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates one of the complex unitary matrices Q or P**H
            determined by CGEBRD when reducing a complex matrix A to bidiagonal
            form: A = Q * B * P**H.</para>
            </summary>
            <param name="vect">
            <code>
            VECT is CHARACTER*1
            Specifies whether the matrix Q or the matrix P**H is
            required, as defined in the transformation applied by CGEBRD:
            = 'Q':  generate Q;
            = 'P':  generate P**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q or P**H to be returned.
            M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q or P**H to be returned.
            N >= 0.
            If VECT = 'Q', M >= N >= min(M,K);
            if VECT = 'P', N >= M >= min(N,K).
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            If VECT = 'Q', the number of columns in the original M-by-K
            matrix reduced by CGEBRD.
            If VECT = 'P', the number of rows in the original K-by-N
            matrix reduced by CGEBRD.
            K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by CGEBRD.
            On exit, the M-by-N matrix Q or P**H.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= M.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension
                                  (min(M,K)) if VECT = 'Q'
                                  (min(N,K)) if VECT = 'P'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i), which determines Q or P**H, as
            returned by CGEBRD in its array argument TAUQ or TAUP.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,min(M,N)).
            For optimum performance LWORK >= min(M,N)*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q and P**H are defined as products of
            elementary reflectors H(i) or G(i) respectively.
            If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
            is of order M:
            if m >= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n
            columns of Q, where m >= n >= k;
            if m &amp;lt; k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an
            M-by-M matrix.
            If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
            is of order N:
            if k &amp;lt; n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m
            rows of P**H, where n >= m >= k;
            if k >= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as
            an N-by-N matrix.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  April 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunml2(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex m-by-n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**H if SIDE = 'R' and TRANS = 'C',
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k)**H .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left
            = 'R': apply Q or Q**H from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGELQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2)**H H(1)**H
            as returned by CGELQF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunmlq(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k)**H .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGELQF in the first k rows of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGELQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2)**H H(1)**H
            as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunmbr(System.Char,Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            VECT = 'Q', CUNMBR overwrites the general complex M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      P * C          C * P
            TRANS = 'C':      P**H * C       C * P**H
            Here Q and P**H are the unitary matrices determined by CGEBRD when
            reducing a complex matrix A to bidiagonal form: A = Q * B * P**H.</para>
            </summary>
            <param name="vect">
            <code>
            VECT is CHARACTER*1
            = 'Q': apply Q or Q**H;
            = 'P': apply P or P**H.
            </code>
            </param>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q, Q**H, P or P**H from the Left;
            = 'R': apply Q, Q**H, P or P**H from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q or P;
            = 'C':  Conjugate transpose, apply Q**H or P**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            If VECT = 'Q', the number of columns in the original
            matrix reduced by CGEBRD.
            If VECT = 'P', the number of rows in the original
            matrix reduced by CGEBRD.
            K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension
                                  (LDA,min(nq,K)) if VECT = 'Q'
                                  (LDA,nq)        if VECT = 'P'
            The vectors which define the elementary reflectors H(i) and
            G(i), whose products determine the matrices Q and P, as
            returned by CGEBRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If VECT = 'Q', LDA >= max(1,nq);
            if VECT = 'P', LDA >= max(1,min(nq,K)).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (min(nq,K))
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i) which determines Q or P, as returned
            by CGEBRD in the array argument TAUQ or TAUP.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
            or P*C or P**H*C or C*P or C*P**H.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M);
            if N = 0 or M = 0, LWORK >= 1.
            For optimum performance LWORK >= max(1,N*NB) if SIDE = 'L',
            and LWORK >= max(1,M*NB) if SIDE = 'R', where NB is the
            optimal blocksize. (NB = 0 if M = 0 or N = 0.)
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q
            and P**H are defined as products of elementary reflectors H(i) and
            G(i) respectively.
            Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
            order of the unitary matrix Q or P**H that is applied.
            If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq >= k, Q = H(1) H(2) . . . H(k);
            if nq &amp;lt; k, Q = H(1) H(2) . . . H(nq-1).
            If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
            if k &amp;lt; nq, P = G(1) G(2) . . . G(k);
            if k >= nq, P = G(1) G(2) . . . G(nq-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunmr2(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex m-by-n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**H if SIDE = 'R' and TRANS = 'C',
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1)**H H(2)**H .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left
            = 'R': apply Q or Q**H from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGERQF in the last k rows of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGERQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)**H
            as returned by CGERQF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunm2l(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex m-by-n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**H if SIDE = 'R' and TRANS = 'C',
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left
            = 'R': apply Q or Q**H from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGEQLF in the last k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQLF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by CGEQLF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunmql(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Transpose, apply Q**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGEQLF in the last k columns of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQLF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Cunmtr(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U': Upper triangle of A contains elementary reflectors
                   from CHETRD;
            = 'L': Lower triangle of A contains elementary reflectors
                   from CHETRD.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by CHETRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CHETRD.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >=M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q is defined as the product of
            nq-1 elementary reflectors, as returned by CHETRD:
            if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
            if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Chseqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**H, where T is an upper triangular matrix (the
               Schur form), and Z is the unitary matrix of Schur vectors.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
             = 'E':  compute eigenvalues only;
             = 'S':  compute eigenvalues and the Schur form T.
            </code>
            </param>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
             = 'N':  no Schur vectors are computed;
             = 'I':  Z is initialized to the unit matrix and the matrix Z
                     of Schur vectors of H is returned;
             = 'V':  Z must contain an unitary matrix Q on entry, and
                     the product Q*Z is returned.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
             set by a previous call to CGEBAL, and then passed to ZGEHRD
             when the matrix output by CGEBAL is reduced to Hessenberg
             form. Otherwise ILO and IHI should be set to 1 and N
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and JOB = 'S', H contains the upper
             triangular matrix T from the Schur decomposition (the
             Schur form). If INFO = 0 and JOB = 'E', the contents of
             H are unspecified on exit.  (The output value of H when
             INFO.GT.0 is given under the description of INFO below.)
             Unlike earlier versions of CHSEQR, this subroutine may
             explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1
             or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX array, dimension (N)
             The computed eigenvalues. If JOB = 'S', the eigenvalues are
             stored in the same order as on the diagonal of the Schur
             form returned in H, with W(i) = H(i,i).
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX array, dimension (LDZ,N)
             If COMPZ = 'N', Z is not referenced.
             If COMPZ = 'I', on entry Z need not be set and on exit,
             if INFO = 0, Z contains the unitary matrix Z of the Schur
             vectors of H.  If COMPZ = 'V', on entry Z must contain an
             N-by-N matrix Q, which is assumed to be equal to the unit
             matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
             if INFO = 0, Z contains Q*Z.
             Normally Q is the unitary matrix generated by CUNGHR
             after the call to CGEHRD which formed the Hessenberg matrix
             H. (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if COMPZ = 'I' or
             COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient and delivers very good and sometimes
             optimal performance.  However, LWORK as large as 11*N
             may be required for optimal performance.  A workspace
             query is recommended to determine the optimal workspace
             size.
             If LWORK = -1, then CHSEQR does a workspace query.
             In this case, CHSEQR checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal
                      value
             .GT. 0:  if INFO = i, CHSEQR failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and JOB = 'E', then on exit, the
                  remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and JOB   = 'S', then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is a unitary matrix.  The final
                  value of  H is upper Hessenberg and triangular in
                  rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and COMPZ = 'V', then on exit
                    (final value of Z)  =  (initial value of Z)*U
                  where U is the unitary matrix in (*) (regard-
                  less of the value of JOB.)
                  If INFO .GT. 0 and COMPZ = 'I', then on exit
                        (final value of Z)  = U
                  where U is the unitary matrix in (*) (regard-
                  less of the value of JOB.)
                  If INFO .GT. 0 and COMPZ = 'N', then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Optionally Z may be postmultiplied into an input unitary
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Default values supplied by
            ILAENV(ISPEC,'CHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).
            It is suggested that these defaults be adjusted in order
            to attain best performance in each particular
            computational environment.
            ISPEC=12: The CLAHQR vs CLAQR0 crossover point.
                      Default: 75. (Must be at least 11.)
            ISPEC=13: Recommended deflation window size.
                      This depends on ILO, IHI and NS.  NS is the
                      number of simultaneous shifts returned
                      by ILAENV(ISPEC=15).  (See ISPEC=15 below.)
                      The default for (IHI-ILO+1).LE.500 is NS.
                      The default for (IHI-ILO+1).GT.500 is 3*NS/2.
            ISPEC=14: Nibble crossover point. (See IPARMQ for
                      details.)  Default: 14% of deflation window
                      size.
            ISPEC=15: Number of simultaneous shifts in a multishift
                      QR iteration.
                      If IHI-ILO+1 is ...
                      greater than      ...but less    ... the
                      or equal to ...      than        default is
                           1               30          NS =   2(+)
                          30               60          NS =   4(+)
                          60              150          NS =  10(+)
                         150              590          NS =  **
                         590             3000          NS =  64
                        3000             6000          NS = 128
                        6000             infinity      NS = 256
                  (+)  By default some or all matrices of this order
                       are passed to the implicit double shift routine
                       CLAHQR and this parameter is ignored.  See
                       ISPEC=12 above and comments in IPARMQ for
                       details.
                 (**)  The asterisks (**) indicate an ad-hoc
                       function of N increasing from 10 to 64.
            ISPEC=16: Select structured matrix multiply.
                      If the number of simultaneous shifts (specified
                      by ISPEC=15) is less than 14, then the default
                      for ISPEC=16 is 0.  Otherwise the default for
                      ISPEC=16 is 2.
            </code>
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slacn2(System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Single@,System.Int32@,Extreme.Collections.Array1D{System.Int32})">
            <summary>
            <para>
            Estimates the 1-norm of a square, real matrix A.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix.  N >= 1.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension (N)
            On the final return, V = A*W,  where  EST = norm(V)/norm(W)
            (W is not returned).
            </code>
            </param>
            <param name="x">
            <code>
            X is REAL array, dimension (N)
            On an intermediate return, X should be overwritten by
                  A * X,   if KASE=1,
                  A**T * X,  if KASE=2,
            and SLACN2 must be re-called with all the other parameters
            unchanged.
            </code>
            </param>
            <param name="isgn">
            <code>
            ISGN is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="est">
            <code>
            EST is REAL
            On entry with KASE = 1 or 2 and ISAVE(1) = 3, EST should be
            unchanged from the previous call to SLACN2.
            On exit, EST is an estimate (a lower bound) for norm(A).
            </code>
            </param>
            <param name="kase">
            <code>
            KASE is INTEGER
            On the initial call to SLACN2, KASE should be 0.
            On an intermediate return, KASE will be 1 or 2, indicating
            whether X should be overwritten by A * X  or A**T * X.
            On the final return from SLACN2, KASE will again be 0.
            </code>
            </param>
            <param name="isave">
            <code>
            ISAVE is INTEGER array, dimension (3)
            ISAVE is used to save variables between calls to SLACN2
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Reverse communication is used for evaluating matrix-vector products.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Originally named SONEST, dated March 16, 1988.
            This is a thread safe version of SLACON, which uses the array ISAVE
            in place of a SAVE statement, as follows:
               SLACON     SLACN2
                JUMP     ISAVE(1)
                J        ISAVE(2)
                ITER     ISAVE(3)
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Nick Higham, University of Manchester
            </para>
            <h4> References:</h4>
            <para>
             N.J. Higham, "FORTRAN codes for estimating the one-norm of
             a real or complex matrix, with applications to condition estimation",
             ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slatbs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Single@,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves one of the triangular systems
               A *x = s*b  or  A**T*x = s*b
            with scaling to prevent overflow, where A is an upper or lower
            triangular band matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the operation applied to A.
            = 'N':  Solve A * x = s*b  (No transpose)
            = 'T':  Solve A**T* x = s*b  (Transpose)
            = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="normin">
            <code>
            NORMIN is CHARACTER*1
            Specifies whether CNORM has been set or not.
            = 'Y':  CNORM contains the column norms on entry
            = 'N':  CNORM is not set on entry.  On exit, the norms will
                    be computed and stored in CNORM.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of subdiagonals or superdiagonals in the
            triangular matrix A.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first KD+1 rows of the array. The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="x">
            <code>
            X is REAL array, dimension (N)
            On entry, the right hand side b of the triangular system.
            On exit, X is overwritten by the solution vector x.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL
            The scaling factor s for the triangular system
               A * x = s*b  or  A**T* x = s*b.
            If SCALE = 0, the matrix A is singular or badly scaled, and
            the vector x is an exact or approximate solution to A*x = 0.
            </code>
            </param>
            <param name="cnorm">
            <code>
            CNORM is REAL array, dimension (N)
            If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
            contains the norm of the off-diagonal part of the j-th column
            of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
            to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
            must be greater than or equal to the 1-norm.
            If NORMIN = 'N', CNORM is an output argument and CNORM(j)
            returns the 1-norm of the offdiagonal part of the j-th column
            of A.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Here A**T denotes the transpose of A, x and b
            are n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine STBSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            A rough bound on x is computed; if that is less than overflow, STBSV
            is called, otherwise, specific code is used which checks for possible
            overflow or divide-by-zero at every operation.
            A columnwise scheme is used for solving A*x = b.  The basic algorithm
            if A is lower triangular is
                 x[1:n] := b[1:n]
                 for j = 1, ..., n
                      x(j) := x(j) / A(j,j)
                      x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                 end
            Define bounds on the components of x after j iterations of the loop:
               M(j) = bound on x[1:j]
               G(j) = bound on x[j+1:n]
            Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
            Then for iteration j+1 we have
               M(j+1) &amp;lt;= G(j) / | A(j+1,j+1) |
               G(j+1) &amp;lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                      &amp;lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
            where CNORM(j+1) is greater than or equal to the infinity-norm of
            column j+1 of A, not counting the diagonal.  Hence
               G(j) &amp;lt;= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
                            1&amp;lt;=i&amp;lt;=j
            and
               |x(j)| &amp;lt;= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                             1&amp;lt;=i&amp;lt; j
            Since |x(j)| &amp;lt;= M(j), we use the Level 2 BLAS routine STBSV if the
            reciprocal of the largest M(j), j=1,..,n, is larger than
            max(underflow, 1/overflow).
            The bound on x(j) is also used to determine when a step in the
            columnwise method can be performed without fear of overflow.  If
            the computed bound is greater than a large constant, x is scaled to
            prevent overflow, but if the bound overflows, x is set to 0, x(j) to
            1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
            Similarly, a row-wise scheme is used to solve A**T*x = b.  The basic
            algorithm for A upper triangular is
                 for j = 1, ..., n
                      x(j) := ( b(j) - A[1:j-1,j]**T * x[1:j-1] ) / A(j,j)
                 end
            We simultaneously compute two bounds
                 G(j) = bound on ( b(i) - A[1:i-1,i]**T * x[1:i-1] ), 1&amp;lt;=i&amp;lt;=j
                 M(j) = bound on x(i), 1&amp;lt;=i&amp;lt;=j
            The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
            add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
            Then the bound on x(j) is
                 M(j) &amp;lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
                      &amp;lt;= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                1&amp;lt;=i&amp;lt;=j
            and we can safely call STBSV if 1/M(n) and 1/G(n) are both greater
            than max(underflow, 1/overflow).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slabad(System.Single@,System.Single@)">
            <summary>
            <para>
            Takes as input the values computed by SLAMCH for underflow and
            overflow, and returns the square root of each of these values if the
            log of LARGE is sufficiently large.</para>
            </summary>
            <param name="small">
            <code>
            SMALL is REAL
            On entry, the underflow threshold as computed by SLAMCH.
            On exit, if LOG10(LARGE) is sufficiently large, the square
            root of SMALL, otherwise unchanged.
            </code>
            </param>
            <param name="large">
            <code>
            LARGE is REAL
            On entry, the overflow threshold as computed by SLAMCH.
            On exit, if LOG10(LARGE) is sufficiently large, the square
            root of LARGE, otherwise unchanged.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This subroutine is intended to
            identify machines with a large exponent range, such as the Crays, and
            redefine the underflow and overflow limits to be the square roots of
            the values computed by SLAMCH.  This subroutine is needed because
            SLAMCH does not compensate for poor arithmetic in the upper half of
            the exponent range, as is found on a Cray.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Srscl(System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            <para>
            Multiplies an n-element real vector x by the real scalar 1/a.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of components of the vector x.
            </code>
            </param>
            <param name="sa">
            <code>
            SA is REAL
            The scalar a which is used to divide each component of x.
            SA must be >= 0, or the subroutine will divide by zero.
            </code>
            </param>
            <param name="sx">
            <code>
            SX is REAL array, dimension
                           (1+(N-1)*abs(INCX))
            The n-element vector x.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive values of the vector SX.
            > 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),     1&amp;lt; i&amp;lt;= n
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is done without overflow or underflow as long as
            the final result x/a does not overflow or underflow.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaswp(System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32,System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32)">
            <summary>
            <para>
            Performs a series of row interchanges on the matrix A.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the matrix of column dimension N to which the row
            interchanges will be applied.
            On exit, the permuted matrix.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            </code>
            </param>
            <param name="k1">
            <code>
            K1 is INTEGER
            The first element of IPIV for which a row interchange will
            be done.
            </code>
            </param>
            <param name="k2">
            <code>
            K2 is INTEGER
            The last element of IPIV for which a row interchange will
            be done.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (K2*abs(INCX))
            The vector of pivot indices.  Only the elements in positions
            K1 through K2 of IPIV are accessed.
            IPIV(K) = L implies rows K and L are to be interchanged.
            </code>
            </param>
            <param name="incx">
            <code>
            INCX is INTEGER
            The increment between successive values of IPIV.  If IPIV
            is negative, the pivots are applied in reverse order.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            One row interchange is initiated for each of rows K1 through K2 of A.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Modified by
             R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slatrs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Single@,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves one of the triangular systems
               A *x = s*b  or  A**T*x = s*b
            with scaling to prevent overflow.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the operation applied to A.
            = 'N':  Solve A * x = s*b  (No transpose)
            = 'T':  Solve A**T* x = s*b  (Transpose)
            = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="normin">
            <code>
            NORMIN is CHARACTER*1
            Specifies whether CNORM has been set or not.
            = 'Y':  CNORM contains the column norms on entry
            = 'N':  CNORM is not set on entry.  On exit, the norms will
                    be computed and stored in CNORM.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max (1,N).
            </code>
            </param>
            <param name="x">
            <code>
            X is REAL array, dimension (N)
            On entry, the right hand side b of the triangular system.
            On exit, X is overwritten by the solution vector x.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL
            The scaling factor s for the triangular system
               A * x = s*b  or  A**T* x = s*b.
            If SCALE = 0, the matrix A is singular or badly scaled, and
            the vector x is an exact or approximate solution to A*x = 0.
            </code>
            </param>
            <param name="cnorm">
            <code>
            CNORM is REAL array, dimension (N)
            If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
            contains the norm of the off-diagonal part of the j-th column
            of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
            to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
            must be greater than or equal to the 1-norm.
            If NORMIN = 'N', CNORM is an output argument and CNORM(j)
            returns the 1-norm of the offdiagonal part of the j-th column
            of A.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Here A is an upper or lower
            triangular matrix, A**T denotes the transpose of A, x and b are
            n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine STRSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            A rough bound on x is computed; if that is less than overflow, STRSV
            is called, otherwise, specific code is used which checks for possible
            overflow or divide-by-zero at every operation.
            A columnwise scheme is used for solving A*x = b.  The basic algorithm
            if A is lower triangular is
                 x[1:n] := b[1:n]
                 for j = 1, ..., n
                      x(j) := x(j) / A(j,j)
                      x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                 end
            Define bounds on the components of x after j iterations of the loop:
               M(j) = bound on x[1:j]
               G(j) = bound on x[j+1:n]
            Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
            Then for iteration j+1 we have
               M(j+1) &amp;lt;= G(j) / | A(j+1,j+1) |
               G(j+1) &amp;lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                      &amp;lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
            where CNORM(j+1) is greater than or equal to the infinity-norm of
            column j+1 of A, not counting the diagonal.  Hence
               G(j) &amp;lt;= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
                            1&amp;lt;=i&amp;lt;=j
            and
               |x(j)| &amp;lt;= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                             1&amp;lt;=i&amp;lt; j
            Since |x(j)| &amp;lt;= M(j), we use the Level 2 BLAS routine STRSV if the
            reciprocal of the largest M(j), j=1,..,n, is larger than
            max(underflow, 1/overflow).
            The bound on x(j) is also used to determine when a step in the
            columnwise method can be performed without fear of overflow.  If
            the computed bound is greater than a large constant, x is scaled to
            prevent overflow, but if the bound overflows, x is set to 0, x(j) to
            1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
            Similarly, a row-wise scheme is used to solve A**T*x = b.  The basic
            algorithm for A upper triangular is
                 for j = 1, ..., n
                      x(j) := ( b(j) - A[1:j-1,j]**T * x[1:j-1] ) / A(j,j)
                 end
            We simultaneously compute two bounds
                 G(j) = bound on ( b(i) - A[1:i-1,i]**T * x[1:i-1] ), 1&amp;lt;=i&amp;lt;=j
                 M(j) = bound on x(i), 1&amp;lt;=i&amp;lt;=j
            The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
            add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
            Then the bound on x(j) is
                 M(j) &amp;lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
                      &amp;lt;= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                1&amp;lt;=i&amp;lt;=j
            and we can safely call STRSV if 1/M(n) and 1/G(n) are both greater
            than max(underflow, 1/overflow).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaisnan(System.Single,System.Single)">
            <summary>
            <para>
            Routine is not for general use.</para>
            </summary>
            <param name="sin1">
            <code>
            SIN1 is REAL
            </code>
            </param>
            <param name="sin2">
            <code>
            SIN2 is REAL
            Two numbers to compare for inequality.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It exists solely to avoid
            over-optimization in SISNAN.
            SLAISNAN checks for NaNs by comparing its two arguments for
            inequality.  NaN is the only floating-point value where NaN != NaN
            returns .TRUE.  To check for NaNs, pass the same variable as both
            arguments.
            A compiler must assume that the two arguments are
            not the same variable, and the test will not be optimized away.
            Interprocedural or whole-program optimization may delete this
            test.  The ISNAN functions will be replaced by the correct
            Fortran 03 intrinsic once the intrinsic is widely available.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sisnan(System.Single)">
            <summary>
            <para>
            Returns .</para>
            </summary>
            <param name="sin">
            <code>
            SIN is REAL
            Input to test for NaN.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            TRUE. if its argument is NaN, and .FALSE.
            otherwise.  To be replaced by the Fortran 2003 intrinsic in the
            future.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slarf(Extreme.Mathematics.MatrixOperationSide,System.Int32,System.Int32,Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Applies a real elementary reflector H to a real m by n matrix
            C, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': form  H * C
            = 'R': form  C * H
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension
                       (1 + (M-1)*abs(INCV)) if SIDE = 'L'
                    or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
            The vector v in the representation of H. V is not used if
            TAU = 0.
            </code>
            <code>
            INCV is INTEGER
            The increment between elements of v. INCV &amp;lt;> 0.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL
            The value tau in the representation of H.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by the matrix H * C if SIDE = 'L',
            or C * H if SIDE = 'R'.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension
                           (N) if SIDE = 'L'
                        or (M) if SIDE = 'R'
            </code>
            </param>
            <remarks>
            <para>
            <code>
            H is represented in the form
                  H = I - tau * v * v**T
            where tau is a real scalar and v is a real vector.
            If tau = 0, then H is taken to be the unit matrix.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slapy2(System.Single,System.Single)">
            <summary>
            <para>
            Returns sqrt(x**2+y**2), taking care not to cause unnecessary
            overflow.</para>
            </summary>
            <param name="x">
            <code>
            X is REAL
            </code>
            </param>
            <param name="y">
            <code>
            Y is REAL
            X and Y specify the values x and y.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slarfg(System.Int32,System.Single@,Extreme.Collections.ArraySlice{System.Single},System.Single@)">
            <summary>
            <para>
            Generates a real elementary reflector H of order n, such
            that
                  H * ( alpha ) = ( beta ),   H**T * H = I.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the elementary reflector.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is REAL
            On entry, the value alpha.
            On exit, it is overwritten with the value beta.
            </code>
            </param>
            <param name="x">
            <code>
            X is REAL array, dimension
                           (1+(N-2)*abs(INCX))
            On entry, the vector x.
            On exit, it is overwritten with the vector v.
            </code>
            <code>
            INCX is INTEGER
            The increment between elements of X. INCX > 0.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL
            The value tau.
            </code>
            </param>
            <remarks>
            <para>
            <code>
                      (   x   )   (   0  )
            where alpha and beta are scalars, and x is an (n-1)-element real
            vector. H is represented in the form
                  H = I - tau * ( 1 ) * ( 1 v**T ) ,
                                ( v )
            where tau is a real scalar and v is a real (n-1)-element
            vector.
            If the elements of x are all zero, then tau = 0 and H is taken to be
            the unit matrix.
            Otherwise  1 &amp;lt;= tau &amp;lt;= 2.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Copy(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Copies all or part of a two-dimensional matrix A to another
            matrix B.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper triangle
            or trapezoid is accessed; if UPLO = 'L', only the lower
            triangle or trapezoid is accessed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slahr2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Reduces the first NB columns of A real general n-BY-(n-k+1)
            matrix A so that elements below the k-th subdiagonal are zero.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The offset for the reduction. Elements below the k-th
            subdiagonal in the first NB columns are reduced to zero.
            K &amp;lt; N.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of columns to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N-K+1)
            On entry, the n-by-(n-k+1) general matrix A.
            On exit, the elements on and above the k-th subdiagonal in
            the first NB columns are overwritten with the corresponding
            elements of the reduced matrix; the elements below the k-th
            subdiagonal, with the array TAU, represent the matrix Q as a
            product of elementary reflectors. The other columns of A are
            unchanged. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (NB)
            The scalar factors of the elementary reflectors. See Further
            Details.
            </code>
            </param>
            <param name="t">
            <code>
            T is REAL array, dimension (LDT,NB)
            The upper triangular matrix T.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T.  LDT >= NB.
            </code>
            </param>
            <param name="y">
            <code>
            Y is REAL array, dimension (LDY,NB)
            The n-by-nb matrix Y.
            </code>
            <code>
            LDY is INTEGER
            The leading dimension of the array Y. LDY >= N.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The
            reduction is performed by an orthogonal similarity transformation
            Q**T * A * Q. The routine returns the matrices V and T which determine
            Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
            This is an auxiliary routine called by SGEHRD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of nb elementary reflectors
               Q = H(1) H(2) . . . H(nb).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
            A(i+k+1:n,i), and tau in TAU(i).
            The elements of the vectors v together form the (n-k+1)-by-nb matrix
            V which is needed, with T and Y, to apply the transformation to the
            unreduced part of the matrix, using an update of the form:
            A := (I - V*T*V**T) * (A - Y*V**T).
            The contents of A on exit are illustrated by the following example
            with n = 7, k = 3 and nb = 2:
               ( a   a   a   a   a )
               ( a   a   a   a   a )
               ( a   a   a   a   a )
               ( h   h   a   a   a )
               ( v1  h   a   a   a )
               ( v1  v2  a   a   a )
               ( v1  v2  a   a   a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            This subroutine is a slight modification of LAPACK-3.0's DLAHRD
            incorporating improvements proposed by Quintana-Orti and Van de
            Gejin. Note that the entries of A(1:K,2:NB) differ from those
            returned by the original LAPACK-3.0's DLAHRD routine. (This
            subroutine is not backward compatible with LAPACK-3.0's DLAHRD.)
            </code>
            </para>
            <h4> References:</h4>
            <para>
             Gregorio Quintana-Orti and Robert van de Geijn, "Improving the
             performance of reduction to Hessenberg form," ACM Transactions on
             Mathematical Software, 32(2):180-194, June 2006.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slarfb(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Applies a real block reflector H or its transpose H**T to a
            real m by n matrix C, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply H or H**T from the Left
            = 'R': apply H or H**T from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply H (No transpose)
            = 'T': apply H**T (Transpose)
            </code>
            </param>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Indicates how H is formed from a product of elementary
            reflectors
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </code>
            </param>
            <param name="storev">
            <code>
            STOREV is CHARACTER*1
            Indicates how the vectors which define the elementary
            reflectors are stored:
            = 'C': Columnwise
            = 'R': Rowwise
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The order of the matrix T (= the number of elementary
            reflectors whose product defines the block reflector).
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension
                                  (LDV,K) if STOREV = 'C'
                                  (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                  (LDV,N) if STOREV = 'R' and SIDE = 'R'
            The matrix V. See Further Details.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V.
            If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
            if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
            if STOREV = 'R', LDV >= K.
            </code>
            </param>
            <param name="t">
            <code>
            T is REAL array, dimension (LDT,K)
            The triangular k by k matrix T in the representation of the
            block reflector.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= K.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (LDWORK,K)
            </code>
            <code>
            LDWORK is INTEGER
            The leading dimension of the array WORK.
            If SIDE = 'L', LDWORK >= max(1,N);
            if SIDE = 'R', LDWORK >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The shape of the matrix V and the storage of the vectors which define
            the H(i) is best illustrated by the following example with n = 5 and
            k = 3. The elements equal to 1 are not stored; the corresponding
            array elements are modified but restored on exit. The rest of the
            array is not used.
            DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
                         V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                             ( v1  1    )                     (     1 v2 v2 v2 )
                             ( v1 v2  1 )                     (        1 v3 v3 )
                             ( v1 v2 v3 )
                             ( v1 v2 v3 )
            DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
                         V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                             ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                             (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                             (     1 v3 )
                             (        1 )
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slanv2(System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            <para>
            Computes the Schur factorization of a real 2-by-2 nonsymmetric
            matrix in standard form:
                 [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
                 [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
            where either
            1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
            2) AA = DD and BB*CC &amp;lt; 0, so that AA + or - sqrt(BB*CC) are complex
            conjugate eigenvalues.</para>
            </summary>
            <param name="a">
            <code>
            A is REAL
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL
            On entry, the elements of the input matrix.
            On exit, they are overwritten by the elements of the
            standardised Schur form.
            </code>
            </param>
            <param name="rt1r">
            <code>
            RT1R is REAL
            </code>
            </param>
            <param name="rt1i">
            <code>
            RT1I is REAL
            </code>
            </param>
            <param name="rt2r">
            <code>
            RT2R is REAL
            </code>
            </param>
            <param name="rt2i">
            <code>
            RT2I is REAL
            The real and imaginary parts of the eigenvalues. If the
            eigenvalues are a complex conjugate pair, RT1I > 0.
            </code>
            </param>
            <param name="cs">
            <code>
            CS is REAL
            </code>
            </param>
            <param name="sn">
            <code>
            SN is REAL
            Parameters of the rotation matrix.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Modified by V. Sima, Research Institute for Informatics, Bucharest,
            Romania, to reduce the risk of cancellation errors,
            when computing real eigenvalues, and to ensure, if possible, that
            abs(RT1R) >= abs(RT2R).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slahqr(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Is an auxiliary routine called by SHSEQR to update the
               eigenvalues and Schur decomposition already computed by SHSEQR, by
               dealing with the Hessenberg submatrix in rows and columns ILO to
               IHI.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that H is already upper quasi-triangular in
            rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
            ILO = 1). SLAHQR works primarily with the Hessenberg
            submatrix in rows and columns ILO to IHI, but applies
            transformations to all of H if WANTT is .TRUE..
            1 &amp;lt;= ILO &amp;lt;= max(1,IHI); IHI &amp;lt;= N.
            </code>
            </param>
            <param name="h">
            <code>
            H is REAL array, dimension (LDH,N)
            On entry, the upper Hessenberg matrix H.
            On exit, if INFO is zero and if WANTT is .TRUE., H is upper
            quasi-triangular in rows and columns ILO:IHI, with any
            2-by-2 diagonal blocks in standard form. If INFO is zero
            and WANTT is .FALSE., the contents of H are unspecified on
            exit.  The output state of H if INFO is nonzero is given
            below under the description of INFO.
            </code>
            <code>
            LDH is INTEGER
            The leading dimension of the array H. LDH >= max(1,N).
            </code>
            </param>
            <param name="wr">
            <code>
            WR is REAL array, dimension (N)
            </code>
            </param>
            <param name="wi">
            <code>
            WI is REAL array, dimension (N)
            The real and imaginary parts, respectively, of the computed
            eigenvalues ILO to IHI are stored in the corresponding
            elements of WR and WI. If two eigenvalues are computed as a
            complex conjugate pair, they are stored in consecutive
            elements of WR and WI, say the i-th and (i+1)th, with
            WI(i) > 0 and WI(i+1) &amp;lt; 0. If WANTT is .TRUE., the
            eigenvalues are stored in the same order as on the diagonal
            of the Schur form returned in H, with WR(i) = H(i,i), and, if
            H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
            WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE..
            1 &amp;lt;= ILOZ &amp;lt;= ILO; IHI &amp;lt;= IHIZ &amp;lt;= N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (LDZ,N)
            If WANTZ is .TRUE., on entry Z must contain the current
            matrix Z of transformations accumulated by SHSEQR, and on
            exit Z has been updated; transformations are applied only to
            the submatrix Z(ILOZ:IHIZ,ILO:IHI).
            If WANTZ is .FALSE., Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z. LDZ >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
             =   0: successful exit
            .GT. 0: If INFO = i, SLAHQR failed to compute all the
                    eigenvalues ILO to IHI in a total of 30 iterations
                    per eigenvalue; elements i+1:ihi of WR and WI
                    contain those eigenvalues which have been
                    successfully computed.
                    If INFO .GT. 0 and WANTT is .FALSE., then on exit,
                    the remaining unconverged eigenvalues are the
                    eigenvalues of the upper Hessenberg matrix rows
                    and columns ILO thorugh INFO of the final, output
                    value of H.
                    If INFO .GT. 0 and WANTT is .TRUE., then on exit
            (*)       (initial value of H)*U  = U*(final value of H)
                    where U is an orthognal matrix.    The final
                    value of H is upper Hessenberg and triangular in
                    rows and columns INFO+1 through IHI.
                    If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                        (final value of Z)  = (initial value of Z)*U
                    where U is the orthogonal matrix in (*)
                    (regardless of the value of WANTT.)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            02-96 Based on modifications by
            David Day, Sandia National Laboratory, USA
            12-04 Further modifications by
            Ralph Byers, University of Kansas, USA
            This is a modified version of SLAHQR from LAPACK version 3.0.
            It is (1) more robust against overflow and underflow and
            (2) adopts the more conservative Ahues &amp; Tisseur stopping
            criterion (LAWN 122, 1997).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaset(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Single,System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Initializes an m-by-n matrix A to BETA on the diagonal and
            ALPHA on the offdiagonals.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies the part of the matrix A to be set.
            = 'U':      Upper triangular part is set; the strictly lower
                        triangular part of A is not changed.
            = 'L':      Lower triangular part is set; the strictly upper
                        triangular part of A is not changed.
            Otherwise:  All of the matrix A is set.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is REAL
            The constant to which the offdiagonal elements are to be set.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is REAL
            The constant to which the diagonal elements are to be set.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On exit, the leading m-by-n submatrix of A is set as follows:
            if UPLO = 'U', A(i,j) = ALPHA, 1&amp;lt;=i&amp;lt;=j-1, 1&amp;lt;=j&amp;lt;=n,
            if UPLO = 'L', A(i,j) = ALPHA, j+1&amp;lt;=i&amp;lt;=m, 1&amp;lt;=j&amp;lt;=n,
            otherwise,     A(i,j) = ALPHA, 1&amp;lt;=i&amp;lt;=m, 1&amp;lt;=j&amp;lt;=n, i.ne.j,
            and, for all UPLO, A(i,i) = BETA, 1&amp;lt;=i&amp;lt;=min(m,n).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slarft(System.Char,System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Forms the triangular factor T of a real block reflector H
            of order n, which is defined as a product of k elementary reflectors.</para>
            </summary>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Specifies the order in which the elementary reflectors are
            multiplied to form the block reflector:
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </code>
            </param>
            <param name="storev">
            <code>
            STOREV is CHARACTER*1
            Specifies how the vectors which define the elementary
            reflectors are stored (see also Further Details):
            = 'C': columnwise
            = 'R': rowwise
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the block reflector H. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The order of the triangular factor T (= the number of
            elementary reflectors). K >= 1.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension
                                 (LDV,K) if STOREV = 'C'
                                 (LDV,N) if STOREV = 'R'
            The matrix V. See further details.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V.
            If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i).
            </code>
            </param>
            <param name="t">
            <code>
            T is REAL array, dimension (LDT,K)
            The k by k triangular factor T of the block reflector.
            If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
            lower triangular. The rest of the array is not used.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= K.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
            If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
            If STOREV = 'C', the vector which defines the elementary reflector
            H(i) is stored in the i-th column of the array V, and
               H  =  I - V * T * V**T
            If STOREV = 'R', the vector which defines the elementary reflector
            H(i) is stored in the i-th row of the array V, and
               H  =  I - V**T * T * V
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The shape of the matrix V and the storage of the vectors which define
            the H(i) is best illustrated by the following example with n = 5 and
            k = 3. The elements equal to 1 are not stored.
            DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
                         V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                             ( v1  1    )                     (     1 v2 v2 v2 )
                             ( v1 v2  1 )                     (        1 v3 v3 )
                             ( v1 v2 v3 )
                             ( v1 v2 v3 )
            DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
                         V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                             ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                             (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                             (     1 v3 )
                             (        1 )
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slassq(System.Int32,Extreme.Collections.ArraySlice{System.Single},System.Single@,System.Single@)">
            <summary>
            <para>
            Returns the values  scl  and  smsq  such that
               ( scl**2 )*smsq = x( 1 )**2 +.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of elements to be used from the vector X.
            </code>
            </param>
            <param name="x">
            <code>
            X is REAL array, dimension (N)
            The vector for which a scaled sum of squares is computed.
               x( i )  = X( 1 + ( i - 1 )*INCX ), 1 &amp;lt;= i &amp;lt;= n.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive values of the vector X.
            INCX > 0.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL
            On entry, the value  scale  in the equation above.
            On exit, SCALE is overwritten with  scl , the scaling factor
            for the sum of squares.
            </code>
            </param>
            <param name="sumsq">
            <code>
            SUMSQ is REAL
            On entry, the value  sumsq  in the equation above.
            On exit, SUMSQ is overwritten with  smsq , the basic sum of
            squares from which  scl  has been factored out.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
            assumed to be non-negative and  scl  returns the value
               scl = max( scale, abs( x( i ) ) ).
            scale and sumsq must be supplied in SCALE and SUMSQ and
            scl and smsq are overwritten on SCALE and SUMSQ respectively.
            The routine makes only one pass through the vector x.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.FullMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in SLANGE as described
            above.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.  When M = 0,
            SLANGE is set to zero.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.  When N = 0,
            SLANGE is set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(M,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK)),
            where LWORK >= M when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            SLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slarfx(Extreme.Mathematics.MatrixOperationSide,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Applies a real elementary reflector H to a real m by n
            matrix C, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': form  H * C
            = 'R': form  C * H
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension (M) if SIDE = 'L'
                                       or (N) if SIDE = 'R'
            The vector v in the representation of H.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL
            The value tau in the representation of H.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by the matrix H * C if SIDE = 'L',
            or C * H if SIDE = 'R'.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDA >= (1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension
                        (N) if SIDE = 'L'
                        or (M) if SIDE = 'R'
            WORK is not referenced if H has order &amp;lt; 11.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            H is represented in the
            form
                  H = I - tau * v * v**T
            where tau is a real scalar and v is a real vector.
            If tau = 0, then H is taken to be the unit matrix
            This version uses inline code if H has order &amp;lt; 11.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slartg(System.Single,System.Single,System.Single@,System.Single@,System.Single@)">
            <summary>
            <para>
            Generate a plane rotation so that
               [  CS  SN  ]  .</para>
            </summary>
            <param name="f">
            <code>
            F is REAL
            The first component of vector to be rotated.
            </code>
            </param>
            <param name="g">
            <code>
            G is REAL
            The second component of vector to be rotated.
            </code>
            </param>
            <param name="cs">
            <code>
            CS is REAL
            The cosine of the rotation.
            </code>
            </param>
            <param name="sn">
            <code>
            SN is REAL
            The sine of the rotation.
            </code>
            </param>
            <param name="r">
            <code>
            R is REAL
            The nonzero component of the rotated vector.
            rsion has a few statements commented out for thread safety
            ne parameters are computed on each entry). 10 feb 03, SJH.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
               [ -SN  CS  ]     [ G ]     [ 0 ]
            This is a slower, more accurate version of the BLAS1 routine SROTG,
            with the following other differences:
               F and G are unchanged on return.
               If G=0, then CS=1 and SN=0.
               If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
                  floating point operations (saves work in SBDSQR when
                  there are zeros on the diagonal).
            If F exceeds G in magnitude, CS will be positive.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasy2(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single@,Extreme.Collections.Array2D{System.Single},System.Single@,System.Int32@)">
            <summary>
            <para>
            Solves for the N1 by N2 matrix X, 1 &amp;lt;= N1,N2 &amp;lt;= 2, in
                   op(TL)*X + ISGN*X*op(TR) = SCALE*B,
            where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
            -1.</para>
            </summary>
            <param name="ltranl">
            <code>
            LTRANL is LOGICAL
            On entry, LTRANL specifies the op(TL):
               = .FALSE., op(TL) = TL,
               = .TRUE., op(TL) = TL**T.
            </code>
            </param>
            <param name="ltranr">
            <code>
            LTRANR is LOGICAL
            On entry, LTRANR specifies the op(TR):
              = .FALSE., op(TR) = TR,
              = .TRUE., op(TR) = TR**T.
            </code>
            </param>
            <param name="isgn">
            <code>
            ISGN is INTEGER
            On entry, ISGN specifies the sign of the equation
            as described before. ISGN may only be 1 or -1.
            </code>
            </param>
            <param name="n1">
            <code>
            N1 is INTEGER
            On entry, N1 specifies the order of matrix TL.
            N1 may only be 0, 1 or 2.
            </code>
            </param>
            <param name="n2">
            <code>
            N2 is INTEGER
            On entry, N2 specifies the order of matrix TR.
            N2 may only be 0, 1 or 2.
            </code>
            </param>
            <param name="tl">
            <code>
            TL is REAL array, dimension (LDTL,2)
            On entry, TL contains an N1 by N1 matrix.
            </code>
            <code>
            LDTL is INTEGER
            The leading dimension of the matrix TL. LDTL >= max(1,N1).
            </code>
            </param>
            <param name="tr">
            <code>
            TR is REAL array, dimension (LDTR,2)
            On entry, TR contains an N2 by N2 matrix.
            </code>
            <code>
            LDTR is INTEGER
            The leading dimension of the matrix TR. LDTR >= max(1,N2).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,2)
            On entry, the N1 by N2 matrix B contains the right-hand
            side of the equation.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the matrix B. LDB >= max(1,N1).
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL
            On exit, SCALE contains the scale factor. SCALE is chosen
            less than or equal to 1 to prevent the solution overflowing.
            </code>
            </param>
            <param name="x">
            <code>
            X is REAL array, dimension (LDX,2)
            On exit, X contains the N1 by N2 solution.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of the matrix X. LDX >= max(1,N1).
            </code>
            </param>
            <param name="xnorm">
            <code>
            XNORM is REAL
            On exit, XNORM is the infinity-norm of the solution.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            On exit, INFO is set to
               0: successful exit.
               1: TL and TR have too close eigenvalues, so TL or
                  TR is perturbed to get a nonsingular equation.
            NOTE: In the interests of speed, this routine does not
                  check the inputs for errors.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            op(T) = T or T**T, where T**T denotes the transpose of T.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaexc(System.Boolean,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
            an upper quasi-triangular matrix T by an orthogonal similarity
            transformation.</para>
            </summary>
            <param name="wantq">
            <code>
            WANTQ is LOGICAL
            = .TRUE. : accumulate the transformation in the matrix Q;
            = .FALSE.: do not accumulate the transformation.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix T. N >= 0.
            </code>
            </param>
            <param name="t">
            <code>
            T is REAL array, dimension (LDT,N)
            On entry, the upper quasi-triangular matrix T, in Schur
            canonical form.
            On exit, the updated matrix T, again in Schur canonical form.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ,N)
            On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
            On exit, if WANTQ is .TRUE., the updated matrix Q.
            If WANTQ is .FALSE., Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.
            LDQ >= 1; and if WANTQ is .TRUE., LDQ >= N.
            </code>
            </param>
            <param name="j1">
            <code>
            J1 is INTEGER
            The index of the first row of the first block T11.
            </code>
            </param>
            <param name="n1">
            <code>
            N1 is INTEGER
            The order of the first block T11. N1 = 0, 1 or 2.
            </code>
            </param>
            <param name="n2">
            <code>
            N2 is INTEGER
            The order of the second block T22. N2 = 0, 1 or 2.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            = 1: the transformed matrix T would be too far from Schur
                 form; the blocks are not swapped and T and Q are
                 unchanged.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            T must be in Schur canonical form, that is, block upper triangular
            with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
            has its diagonal elemnts equal and its off-diagonal elements of
            opposite sign.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaqr2(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@,System.Int32@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32)">
            <summary>
            <para>
            Is identical to SLAQR3 except that it avoids
               recursion by calling SLAHQR instead of SLAQR4.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            If .TRUE., then the Hessenberg matrix H is fully updated
            so that the quasi-triangular Schur factor may be
            computed (in cooperation with the calling subroutine).
            If .FALSE., then only enough of H is updated to preserve
            the eigenvalues.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            If .TRUE., then the orthogonal matrix Z is updated so
            so that the orthogonal Schur factor may be computed
            (in cooperation with the calling subroutine).
            If .FALSE., then Z is not referenced.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H and (if WANTZ is .TRUE.) the
            order of the orthogonal matrix Z.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is INTEGER
            It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
            KBOT and KTOP together determine an isolated block
            along the diagonal of the Hessenberg matrix.
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is INTEGER
            It is assumed without a check that either
            KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
            determine an isolated block along the diagonal of the
            Hessenberg matrix.
            </code>
            </param>
            <param name="nw">
            <code>
            NW is INTEGER
            Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
            </code>
            </param>
            <param name="h">
            <code>
            H is REAL array, dimension (LDH,N)
            On input the initial N-by-N section of H stores the
            Hessenberg matrix undergoing aggressive early deflation.
            On output H has been transformed by an orthogonal
            similarity transformation, perturbed, and the returned
            to Hessenberg form that (it is to be hoped) has some
            zero subdiagonal entries.
            </code>
            <code>
            LDH is integer
            Leading dimension of H just as declared in the calling
            subroutine.  N .LE. LDH
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (LDZ,N)
            IF WANTZ is .TRUE., then on output, the orthogonal
            similarity transformation mentioned above has been
            accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
            If WANTZ is .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer
            The leading dimension of Z just as declared in the
            calling subroutine.  1 .LE. LDZ.
            </code>
            </param>
            <param name="ns">
            <code>
            NS is integer
            The number of unconverged (ie approximate) eigenvalues
            returned in SR and SI that may be used as shifts by the
            calling subroutine.
            </code>
            </param>
            <param name="nd">
            <code>
            ND is integer
            The number of converged eigenvalues uncovered by this
            subroutine.
            </code>
            </param>
            <param name="sr">
            <code>
            SR is REAL array, dimension KBOT
            </code>
            </param>
            <param name="si">
            <code>
            SI is REAL array, dimension KBOT
            On output, the real and imaginary parts of approximate
            eigenvalues that may be used for shifts are stored in
            SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
            SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
            The real and imaginary parts of converged eigenvalues
            are stored in SR(KBOT-ND+1) through SR(KBOT) and
            SI(KBOT-ND+1) through SI(KBOT), respectively.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension (LDV,NW)
            An NW-by-NW work array.
            </code>
            <code>
            LDV is integer scalar
            The leading dimension of V just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
            The number of columns of T.  NH.GE.NW.
            </code>
            </param>
            <param name="t">
            <code>
            T is REAL array, dimension (LDT,NW)
            </code>
            <code>
            LDT is integer
            The leading dimension of T just as declared in the
            calling subroutine.  NW .LE. LDT
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer
            The number of rows of work array WV available for
            workspace.  NV.GE.NW.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is REAL array, dimension (LDWV,NW)
            </code>
            <code>
            LDWV is integer
            The leading dimension of W just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension LWORK.
            On exit, WORK(1) is set to an estimate of the optimal value
            of LWORK for the given values of N, NW, KTOP and KBOT.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is integer
            The dimension of the work array WORK.  LWORK = 2*NW
            suffices, but greater efficiency may result from larger
            values of LWORK.
            If LWORK = -1, then a workspace query is assumed; SLAQR2
            only estimates the optimal workspace size for the given
            values of N, NW, KTOP and KBOT.  The estimate is returned
            in WORK(1).  No error message related to LWORK is issued
            by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Aggressive early deflation:
               This subroutine accepts as input an upper Hessenberg matrix
               H and performs an orthogonal similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.  On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an orthogonal similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaqr1(System.Int32,Extreme.Collections.Array2D{System.Single},System.Single,System.Single,System.Single,System.Single,Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            A 2-by-2 or 3-by-3 matrix H, SLAQR1 sets v to a
                 scalar multiple of the first column of the product
                 (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
                 scaling to avoid overflows and most underflows.</para>
            </summary>
            <param name="n">
            <code>
            N is integer
                Order of the matrix H. N must be either 2 or 3.
            </code>
            </param>
            <param name="h">
            <code>
            H is REAL array of dimension (LDH,N)
                The 2-by-2 or 3-by-3 matrix H in (*).
            </code>
            <code>
            LDH is integer
                The leading dimension of H as declared in
                the calling procedure.  LDH.GE.N
            </code>
            </param>
            <param name="sr1">
            <code>
            SR1 is REAL
            </code>
            </param>
            <param name="si1">
            <code>
            SI1 is REAL
            </code>
            </param>
            <param name="sr2">
            <code>
            SR2 is REAL
            </code>
            </param>
            <param name="si2">
            <code>
            SI2 is REAL
                The shifts in (*).
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array of dimension N
                A scalar multiple of the first column of the
                matrix K in (*).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It
                 is assumed that either
                         1) sr1 = sr2 and si1 = -si2
                     or
                         2) si1 = si2 = 0.
                 This is useful for starting double implicit shift bulges
                 in the QR algorithm.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaqr5(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32,Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Called by SLAQR0, performs a
               single small-bulge multi-shift QR sweep.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is logical scalar
               WANTT = .true. if the quasi-triangular Schur factor
               is being computed.  WANTT is set to .false. otherwise.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is logical scalar
               WANTZ = .true. if the orthogonal Schur factor is being
               computed.  WANTZ is set to .false. otherwise.
            </code>
            </param>
            <param name="kacc22">
            <code>
            KACC22 is integer with value 0, 1, or 2.
               Specifies the computation mode of far-from-diagonal
               orthogonal updates.
            = 0: SLAQR5 does not accumulate reflections and does not
                 use matrix-matrix multiply to update far-from-diagonal
                 matrix entries.
            = 1: SLAQR5 accumulates reflections and uses matrix-matrix
                 multiply to update the far-from-diagonal matrix entries.
            = 2: SLAQR5 accumulates reflections, uses matrix-matrix
                 multiply to update the far-from-diagonal matrix entries,
                 and takes advantage of 2-by-2 block structure during
                 matrix multiplies.
            </code>
            </param>
            <param name="n">
            <code>
            N is integer scalar
               N is the order of the Hessenberg matrix H upon which this
               subroutine operates.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is integer scalar
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is integer scalar
               These are the first and last rows and columns of an
               isolated diagonal block upon which the QR sweep is to be
               applied. It is assumed without a check that
                         either KTOP = 1  or   H(KTOP,KTOP-1) = 0
               and
                         either KBOT = N  or   H(KBOT+1,KBOT) = 0.
            </code>
            </param>
            <param name="nshfts">
            <code>
            NSHFTS is integer scalar
               NSHFTS gives the number of simultaneous shifts.  NSHFTS
               must be positive and even.
            </code>
            </param>
            <param name="sr">
            <code>
            SR is REAL array of size (NSHFTS)
            </code>
            </param>
            <param name="si">
            <code>
            SI is REAL array of size (NSHFTS)
               SR contains the real parts and SI contains the imaginary
               parts of the NSHFTS shifts of origin that define the
               multi-shift QR sweep.  On output SR and SI may be
               reordered.
            </code>
            </param>
            <param name="h">
            <code>
            H is REAL array of size (LDH,N)
               On input H contains a Hessenberg matrix.  On output a
               multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
               to the isolated diagonal block in rows and columns KTOP
               through KBOT.
            </code>
            <code>
            LDH is integer scalar
               LDH is the leading dimension of H just as declared in the
               calling procedure.  LDH.GE.MAX(1,N).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
               Specify the rows of Z to which transformations must be
               applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array of size (LDZ,IHI)
               If WANTZ = .TRUE., then the QR Sweep orthogonal
               similarity transformation is accumulated into
               Z(ILOZ:IHIZ,ILO:IHI) from the right.
               If WANTZ = .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer scalar
               LDA is the leading dimension of Z just as declared in
               the calling procedure. LDZ.GE.N.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array of size (LDV,NSHFTS/2)
            </code>
            <code>
            LDV is integer scalar
               LDV is the leading dimension of V as declared in the
               calling procedure.  LDV.GE.3.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array of size
               (LDU,3*NSHFTS-3)
            </code>
            <code>
            LDU is integer scalar
               LDU is the leading dimension of U just as declared in the
               in the calling subroutine.  LDU.GE.3*NSHFTS-3.
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
               NH is the number of columns in array WH available for
               workspace. NH.GE.1.
            </code>
            </param>
            <param name="wh">
            <code>
            WH is REAL array of size (LDWH,NH)
            </code>
            <code>
            LDWH is integer scalar
               Leading dimension of WH just as declared in the
               calling procedure.  LDWH.GE.3*NSHFTS-3.
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer scalar
               NV is the number of rows in WV agailable for workspace.
               NV.GE.1.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is REAL array of size
               (LDWV,3*NSHFTS-3)
            </code>
            <code>
            LDWV is integer scalar
               LDWV is the leading dimension of WV as declared in the
               in the calling subroutine.  LDWV.GE.NV.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaqr4(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Implements one level of recursion for SLAQR0.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
             H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
             previous call to SGEBAL, and then passed to SGEHRD when the
             matrix output by SGEBAL is reduced to Hessenberg form.
             Otherwise, ILO and IHI should be set to 1 and N,
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is REAL array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and WANTT is .TRUE., then H contains
             the upper quasi-triangular matrix T from the Schur
             decomposition (the Schur form); 2-by-2 diagonal blocks
             (corresponding to complex conjugate pairs of eigenvalues)
             are returned in standard form, with H(i,i) = H(i+1,i+1)
             and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and WANTT is
             .FALSE., then the contents of H are unspecified on exit.
             (The output value of H when INFO.GT.0 is given under the
             description of INFO below.)
             This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
             j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="wr">
            <code>
            WR is REAL array, dimension (IHI)
            </code>
            </param>
            <param name="wi">
            <code>
            WI is REAL array, dimension (IHI)
             The real and imaginary parts, respectively, of the computed
             eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
             and WI(ILO:IHI). If two eigenvalues are computed as a
             complex conjugate pair, they are stored in consecutive
             elements of WR and WI, say the i-th and (i+1)th, with
             WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., then
             the eigenvalues are stored in the same order as on the
             diagonal of the Schur form returned in H, with
             WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
             block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
             WI(i+1) = -WI(i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (LDZ,IHI)
             If WANTZ is .FALSE., then Z is not referenced.
             If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
             replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
             orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
             (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if WANTZ is .TRUE.
             then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension LWORK
             On exit, if LWORK = -1, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             If LWORK = -1, then SLAQR4 does a workspace query.
             In this case, SLAQR4 checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            INFO is INTEGER
               =  0:  successful exit
             .GT. 0:  if INFO = i, SLAQR4 failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and WANT is .FALSE., then on exit,
                  the remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and WANTT is .TRUE., then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is a orthogonal matrix.  The final
                  value of  H is upper Hessenberg and triangular in
                  rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                    (final value of Z(ILO:IHI,ILOZ:IHIZ)
                     =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
                  where U is the orthogonal matrix in (*) (regard-
                  less of the value of WANTT.)
                  If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It is a complete implementation of the small bulge multi-shift
            QR algorithm.  It may be called by SLAQR0 and, for large enough
            deflation window size, it may be called by SLAQR3.  This
            subroutine is identical to SLAQR0 except that it calls SLAQR2
            instead of SLAQR3.
            SLAQR4 computes the eigenvalues of a Hessenberg matrix H
            and, optionally, the matrices T and Z from the Schur decomposition
            H = Z T Z**T, where T is an upper quasi-triangular matrix (the
            Schur form), and Z is the orthogonal matrix of Schur vectors.
            Optionally Z may be postmultiplied into an input orthogonal
            matrix Q so that this routine can give the Schur factorization
            of a matrix A which has been reduced to the Hessenberg form H
            by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaqr3(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@,System.Int32@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32)">
            <summary>
            <para>
            Early deflation:
               SLAQR3 accepts as input an upper Hessenberg matrix
               H and performs an orthogonal similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            If .TRUE., then the Hessenberg matrix H is fully updated
            so that the quasi-triangular Schur factor may be
            computed (in cooperation with the calling subroutine).
            If .FALSE., then only enough of H is updated to preserve
            the eigenvalues.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            If .TRUE., then the orthogonal matrix Z is updated so
            so that the orthogonal Schur factor may be computed
            (in cooperation with the calling subroutine).
            If .FALSE., then Z is not referenced.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H and (if WANTZ is .TRUE.) the
            order of the orthogonal matrix Z.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is INTEGER
            It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
            KBOT and KTOP together determine an isolated block
            along the diagonal of the Hessenberg matrix.
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is INTEGER
            It is assumed without a check that either
            KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
            determine an isolated block along the diagonal of the
            Hessenberg matrix.
            </code>
            </param>
            <param name="nw">
            <code>
            NW is INTEGER
            Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
            </code>
            </param>
            <param name="h">
            <code>
            H is REAL array, dimension (LDH,N)
            On input the initial N-by-N section of H stores the
            Hessenberg matrix undergoing aggressive early deflation.
            On output H has been transformed by an orthogonal
            similarity transformation, perturbed, and the returned
            to Hessenberg form that (it is to be hoped) has some
            zero subdiagonal entries.
            </code>
            <code>
            LDH is integer
            Leading dimension of H just as declared in the calling
            subroutine.  N .LE. LDH
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (LDZ,N)
            IF WANTZ is .TRUE., then on output, the orthogonal
            similarity transformation mentioned above has been
            accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
            If WANTZ is .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer
            The leading dimension of Z just as declared in the
            calling subroutine.  1 .LE. LDZ.
            </code>
            </param>
            <param name="ns">
            <code>
            NS is integer
            The number of unconverged (ie approximate) eigenvalues
            returned in SR and SI that may be used as shifts by the
            calling subroutine.
            </code>
            </param>
            <param name="nd">
            <code>
            ND is integer
            The number of converged eigenvalues uncovered by this
            subroutine.
            </code>
            </param>
            <param name="sr">
            <code>
            SR is REAL array, dimension KBOT
            </code>
            </param>
            <param name="si">
            <code>
            SI is REAL array, dimension KBOT
            On output, the real and imaginary parts of approximate
            eigenvalues that may be used for shifts are stored in
            SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
            SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
            The real and imaginary parts of converged eigenvalues
            are stored in SR(KBOT-ND+1) through SR(KBOT) and
            SI(KBOT-ND+1) through SI(KBOT), respectively.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension (LDV,NW)
            An NW-by-NW work array.
            </code>
            <code>
            LDV is integer scalar
            The leading dimension of V just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
            The number of columns of T.  NH.GE.NW.
            </code>
            </param>
            <param name="t">
            <code>
            T is REAL array, dimension (LDT,NW)
            </code>
            <code>
            LDT is integer
            The leading dimension of T just as declared in the
            calling subroutine.  NW .LE. LDT
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer
            The number of rows of work array WV available for
            workspace.  NV.GE.NW.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is REAL array, dimension (LDWV,NW)
            </code>
            <code>
            LDWV is integer
            The leading dimension of W just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension LWORK.
            On exit, WORK(1) is set to an estimate of the optimal value
            of LWORK for the given values of N, NW, KTOP and KBOT.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is integer
            The dimension of the work array WORK.  LWORK = 2*NW
            suffices, but greater efficiency may result from larger
            values of LWORK.
            If LWORK = -1, then a workspace query is assumed; SLAQR3
            only estimates the optimal workspace size for the given
            values of N, NW, KTOP and KBOT.  The estimate is returned
            in WORK(1).  No error message related to LWORK is issued
            by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an orthogonal similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaqr0(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**T, where T is an upper quasi-triangular matrix (the
               Schur form), and Z is the orthogonal matrix of Schur vectors.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
             H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
             previous call to SGEBAL, and then passed to SGEHRD when the
             matrix output by SGEBAL is reduced to Hessenberg form.
             Otherwise, ILO and IHI should be set to 1 and N,
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is REAL array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and WANTT is .TRUE., then H contains
             the upper quasi-triangular matrix T from the Schur
             decomposition (the Schur form); 2-by-2 diagonal blocks
             (corresponding to complex conjugate pairs of eigenvalues)
             are returned in standard form, with H(i,i) = H(i+1,i+1)
             and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and WANTT is
             .FALSE., then the contents of H are unspecified on exit.
             (The output value of H when INFO.GT.0 is given under the
             description of INFO below.)
             This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
             j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="wr">
            <code>
            WR is REAL array, dimension (IHI)
            </code>
            </param>
            <param name="wi">
            <code>
            WI is REAL array, dimension (IHI)
             The real and imaginary parts, respectively, of the computed
             eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
             and WI(ILO:IHI). If two eigenvalues are computed as a
             complex conjugate pair, they are stored in consecutive
             elements of WR and WI, say the i-th and (i+1)th, with
             WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., then
             the eigenvalues are stored in the same order as on the
             diagonal of the Schur form returned in H, with
             WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
             block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
             WI(i+1) = -WI(i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (LDZ,IHI)
             If WANTZ is .FALSE., then Z is not referenced.
             If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
             replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
             orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
             (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if WANTZ is .TRUE.
             then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension LWORK
             On exit, if LWORK = -1, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             If LWORK = -1, then SLAQR0 does a workspace query.
             In this case, SLAQR0 checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .GT. 0:  if INFO = i, SLAQR0 failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and WANT is .FALSE., then on exit,
                  the remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and WANTT is .TRUE., then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is an orthogonal matrix.  The final
                  value of H is upper Hessenberg and quasi-triangular
                  in rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                    (final value of Z(ILO:IHI,ILOZ:IHIZ)
                     =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
                  where U is the orthogonal matrix in (*) (regard-
                  less of the value of WANTT.)
                  If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Optionally Z may be postmultiplied into an input orthogonal
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slascl(System.Char,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Multiplies the M by N real matrix A by the real scalar
            CTO/CFROM.</para>
            </summary>
            <param name="type">
            <code>
            TYPE is CHARACTER*1
            TYPE indices the storage type of the input matrix.
            = 'G':  A is a full matrix.
            = 'L':  A is a lower triangular matrix.
            = 'U':  A is an upper triangular matrix.
            = 'H':  A is an upper Hessenberg matrix.
            = 'B':  A is a symmetric band matrix with lower bandwidth KL
                    and upper bandwidth KU and with the only the lower
                    half stored.
            = 'Q':  A is a symmetric band matrix with lower bandwidth KL
                    and upper bandwidth KU and with the only the upper
                    half stored.
            = 'Z':  A is a band matrix with lower bandwidth KL and upper
                    bandwidth KU. See SGBTRF for storage details.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The lower bandwidth of A.  Referenced only if TYPE = 'B',
            'Q' or 'Z'.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The upper bandwidth of A.  Referenced only if TYPE = 'B',
            'Q' or 'Z'.
            </code>
            </param>
            <param name="cfrom">
            <code>
            CFROM is REAL
            </code>
            </param>
            <param name="cto">
            <code>
            CTO is REAL
            The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
            without over/underflow if the final result CTO*A(I,J)/CFROM
            can be represented without over/underflow.  CFROM must be
            nonzero.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The matrix to be multiplied by CTO/CFROM.  See TYPE for the
            storage type.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            0  - successful exit
            &amp;lt;0 - if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is done without over/underflow as long as the final
            result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
            A may be full, upper triangular, lower triangular, upper Hessenberg,
            or banded.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sladiv(System.Single,System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            <para>
            Performs complex division in  real arithmetic
                                  a + i*b
                       p + i*q = ---------
                                  c + i*d
            The algorithm is due to Robert L.</para>
            </summary>
            <param name="a">
            <code>
            A is REAL
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL
            The scalars a, b, c, and d in the above expression.
            </code>
            </param>
            <param name="p">
            <code>
            P is REAL
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL
            The scalars p and q in the above expression.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Smith and can be found
            in D. Knuth, The art of Computer Programming, Vol.2, p.195
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaln2(System.Boolean,System.Int32,System.Int32,System.Single,System.Single,Extreme.Collections.Array2D{System.Single},System.Single,System.Single,Extreme.Collections.Array2D{System.Single},System.Single,System.Single,Extreme.Collections.Array2D{System.Single},System.Single@,System.Single@,System.Int32@)">
            <summary>
            <para>
            Solves a system of the form  (ca A - w D ) X = s B
            or (ca A**T - w D) X = s B   with possible scaling ("s") and
            perturbation of A.</para>
            </summary>
            <param name="ltrans">
            <code>
            LTRANS is LOGICAL
            =.TRUE.:  A-transpose will be used.
            =.FALSE.: A will be used (not transposed.)
            </code>
            </param>
            <param name="na">
            <code>
            NA is INTEGER
            The size of the matrix A.  It may (only) be 1 or 2.
            </code>
            </param>
            <param name="nw">
            <code>
            NW is INTEGER
            1 if "w" is real, 2 if "w" is complex.  It may only be 1
            or 2.
            </code>
            </param>
            <param name="smin">
            <code>
            SMIN is REAL
            The desired lower bound on the singular values of A.  This
            should be a safe distance away from underflow or overflow,
            say, between (underflow/machine precision) and  (machine
            precision * overflow ).  (See BIGNUM and ULP.)
            </code>
            </param>
            <param name="ca">
            <code>
            CA is REAL
            The coefficient c, which A is multiplied by.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,NA)
            The NA x NA matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of A.  It must be at least NA.
            </code>
            </param>
            <param name="d1">
            <code>
            D1 is REAL
            The 1,1 element in the diagonal matrix D.
            </code>
            </param>
            <param name="d2">
            <code>
            D2 is REAL
            The 2,2 element in the diagonal matrix D.  Not used if NW=1.
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,NW)
            The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
            complex), column 1 contains the real part of B and column 2
            contains the imaginary part.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of B.  It must be at least NA.
            </code>
            </param>
            <param name="wr">
            <code>
            WR is REAL
            The real part of the scalar "w".
            </code>
            </param>
            <param name="wi">
            <code>
            WI is REAL
            The imaginary part of the scalar "w".  Not used if NW=1.
            </code>
            </param>
            <param name="x">
            <code>
            X is REAL array, dimension (LDX,NW)
            The NA x NW matrix X (unknowns), as computed by SLALN2.
            If NW=2 ("w" is complex), on exit, column 1 will contain
            the real part of X and column 2 will contain the imaginary
            part.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of X.  It must be at least NA.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL
            The scale factor that B must be multiplied by to insure
            that overflow does not occur when computing X.  Thus,
            (ca A - w D) X  will be SCALE*B, not B (ignoring
            perturbations of A.)  It will be at most 1.
            </code>
            </param>
            <param name="xnorm">
            <code>
            XNORM is REAL
            The infinity-norm of X, when X is regarded as an NA x NW
            real matrix.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            An error flag.  It will be set to zero if no error occurs,
            a negative number if an argument is in error, or a positive
            number if  ca A - w D  had to be perturbed.
            The possible values are:
            = 0: No error occurred, and (ca A - w D) did not have to be
                   perturbed.
            = 1: (ca A - w D) had to be perturbed to make its smallest
                 (or only) singular value greater than SMIN.
            NOTE: In the interests of speed, this routine does not
                  check the inputs for errors.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            (A**T means A-transpose.)
            A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
            real diagonal matrix, w is a real or complex value, and X and B are
            NA x 1 matrices -- real if w is real, complex if w is complex.  NA
            may be 1 or 2.
            If w is complex, X and B are represented as NA x 2 matrices,
            the first column of each being the real part and the second
            being the imaginary part.
            "s" is a scaling factor (.LE. 1), computed by SLALN2, which is
            so chosen that X can be computed without overflow.  X is further
            scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
            than overflow.
            If both singular values of (ca A - w D) are less than SMIN,
            SMIN*identity will be used instead of (ca A - w D).  If only one
            singular value is less than SMIN, one element of (ca A - w D) will be
            perturbed enough to make the smallest singular value roughly SMIN.
            If both singular values are at least SMIN, (ca A - w D) will not be
            perturbed.  In any case, the perturbation will be at most some small
            multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
            are computed by infinity-norm approximations, and thus will only be
            correct to a factor of 2 or so.
            Note: all input quantities are assumed to be smaller than overflow
            by a reasonable factor.  (See BIGNUM.)
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaqp2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Computes a QR factorization with column pivoting of
            the block A(OFFSET+1:M,1:N).</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0.
            </code>
            </param>
            <param name="offset">
            <code>
            OFFSET is INTEGER
            The number of rows of the matrix A that must be pivoted
            but no factorized. OFFSET >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of block A(OFFSET+1:M,1:N) is
            the triangular factor obtained; the elements in block
            A(OFFSET+1:M,1:N) below the diagonal, together with the
            array TAU, represent the orthogonal matrix Q as a product of
            elementary reflectors. Block A(1:OFFSET,1:N) has been
            accordingly pivoted, but no factorized.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(i) = 0,
            the i-th column of A is a free column.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="vn1">
            <code>
            VN1 is REAL array, dimension (N)
            The vector with the partial column norms.
            </code>
            </param>
            <param name="vn2">
            <code>
            VN2 is REAL array, dimension (N)
            The vector with the exact column norms.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (N)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>
             Partial column norm updating strategy modified on April 2011
               Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
               University of Zagreb, Croatia.
            </para>
            <h4> References:</h4>
            <para>
            LAPACK Working Note 176
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaqps(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Computes a step of QR factorization with column pivoting
            of a real M-by-N matrix A by using Blas-3.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0
            </code>
            </param>
            <param name="offset">
            <code>
            OFFSET is INTEGER
            The number of rows of A that have been factorized in
            previous steps.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of columns to factorize.
            </code>
            </param>
            <param name="kb">
            <code>
            KB is INTEGER
            The number of columns actually factorized.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, block A(OFFSET+1:M,1:KB) is the triangular
            factor obtained and block A(1:OFFSET,1:N) has been
            accordingly pivoted, but no factorized.
            The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
            been updated.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            JPVT(I) = K &amp;lt;==> Column K of the full matrix A has been
            permuted into position I in AP.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (KB)
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="vn1">
            <code>
            VN1 is REAL array, dimension (N)
            The vector with the partial column norms.
            </code>
            </param>
            <param name="vn2">
            <code>
            VN2 is REAL array, dimension (N)
            The vector with the exact column norms.
            </code>
            </param>
            <param name="auxv">
            <code>
            AUXV is REAL array, dimension (NB)
            Auxiliar vector.
            </code>
            </param>
            <param name="f">
            <code>
            F is REAL array, dimension (LDF,NB)
            Matrix F**T = L*Y**T*A.
            </code>
            <code>
            LDF is INTEGER
            The leading dimension of the array F. LDF >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It tries to factorize
            NB columns from A starting from the row OFFSET+1, and updates all
            of the matrix with Blas-3 xGEMM.
            In some cases, due to catastrophic cancellations, it cannot
            factorize NB columns.  Hence, the actual number of factorized
            columns is returned in KB.
            Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>
             Partial column norm updating strategy modified on April 2011
               Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
               University of Zagreb, Croatia.
            </para>
            <h4> References:</h4>
            <para>
            LAPACK Working Note 176
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.SymmetricTridiagonalMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real symmetric tridiagonal matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in SLANST as described
            above.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, SLANST is
            set to zero.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            The diagonal elements of A.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            The (n-1) sub-diagonal or super-diagonal elements of A.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            SLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slamrg(System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32,Extreme.Collections.Array1D{System.Int32})">
            <summary>
            <para>
            Will create a permutation list which will merge the elements
            of A (which is composed of two independently sorted sets) into a
            single set which is sorted in ascending order.</para>
            </summary>
            <param name="n1">
            <code>
            N1 is INTEGER
            </code>
            </param>
            <param name="n2">
            <code>
            N2 is INTEGER
            These arguements contain the respective lengths of the two
            sorted lists to be merged.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (N1+N2)
            The first N1 elements of A contain a list of numbers which
            are sorted in either ascending or descending order.  Likewise
            for the final N2 elements.
            </code>
            </param>
            <param name="strd1">
            <code>
            STRD1 is INTEGER
            </code>
            </param>
            <param name="strd2">
            <code>
            STRD2 is INTEGER
            These are the strides to be taken through the array A.
            Allowable strides are 1 and -1.  They indicate whether a
            subset of A is sorted in ascending (STRDx = 1) or descending
            (STRDx = -1) order.
            </code>
            </param>
            <param name="index">
            <code>
            INDEX is INTEGER array, dimension (N1+N2)
            On exit this array will contain a permutation such that
            if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
            sorted in ascending order.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasd2(System.Int32,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Single,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Merges the two sets of singular values together into a single
            sorted set.</para>
            </summary>
            <param name="nl">
            <code>
            NL is INTEGER
            The row dimension of the upper block.  NL >= 1.
            </code>
            </param>
            <param name="nr">
            <code>
            NR is INTEGER
            The row dimension of the lower block.  NR >= 1.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: the lower block is an NR-by-NR square matrix.
            = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
            The bidiagonal matrix has N = NL + NR + 1 rows and
            M = N + SQRE >= N columns.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            Contains the dimension of the non-deflated matrix,
            This is the order of the related secular equation. 1 &amp;lt;= K &amp;lt;=N.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry D contains the singular values of the two submatrices
            to be combined.  On exit D contains the trailing (N-K) updated
            singular values (those which were deflated) sorted into
            increasing order.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (N)
            On exit Z contains the updating row vector in the secular
            equation.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is REAL
            Contains the diagonal element associated with the added row.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is REAL
            Contains the off-diagonal element associated with the added
            row.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension (LDU,N)
            On entry U contains the left singular vectors of two
            submatrices in the two square blocks with corners at (1,1),
            (NL, NL), and (NL+2, NL+2), (N,N).
            On exit U contains the trailing (N-K) updated left singular
            vectors (those which were deflated) in its last N-K columns.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= N.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is REAL array, dimension (LDVT,M)
            On entry VT**T contains the right singular vectors of two
            submatrices in the two square blocks with corners at (1,1),
            (NL+1, NL+1), and (NL+2, NL+2), (M,M).
            On exit VT**T contains the trailing (N-K) updated right singular
            vectors (those which were deflated) in its last N-K columns.
            In case SQRE =1, the last row of VT spans the right null
            space.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= M.
            </code>
            </param>
            <param name="dsigma">
            <code>
            DSIGMA is REAL array, dimension (N)
            Contains a copy of the diagonal elements (K-1 singular values
            and one zero) in the secular equation.
            </code>
            </param>
            <param name="u2">
            <code>
            U2 is REAL array, dimension (LDU2,N)
            Contains a copy of the first K-1 left singular vectors which
            will be used by SLASD3 in a matrix multiply (SGEMM) to solve
            for the new left singular vectors. U2 is arranged into four
            blocks. The first block contains a column with 1 at NL+1 and
            zero everywhere else; the second block contains non-zero
            entries only at and above NL; the third contains non-zero
            entries only below NL+1; and the fourth is dense.
            </code>
            <code>
            LDU2 is INTEGER
            The leading dimension of the array U2.  LDU2 >= N.
            </code>
            </param>
            <param name="vt2">
            <code>
            VT2 is REAL array, dimension (LDVT2,N)
            VT2**T contains a copy of the first K right singular vectors
            which will be used by SLASD3 in a matrix multiply (SGEMM) to
            solve for the new right singular vectors. VT2 is arranged into
            three blocks. The first block contains a row that corresponds
            to the special 0 diagonal element in SIGMA; the second block
            contains non-zeros only at and before NL +1; the third block
            contains non-zeros only at and after  NL +2.
            </code>
            <code>
            LDVT2 is INTEGER
            The leading dimension of the array VT2.  LDVT2 >= M.
            </code>
            </param>
            <param name="idxp">
            <code>
            IDXP is INTEGER array, dimension (N)
            This will contain the permutation used to place deflated
            values of D at the end of the array. On output IDXP(2:K)
            points to the nondeflated D-values and IDXP(K+1:N)
            points to the deflated singular values.
            </code>
            </param>
            <param name="idx">
            <code>
            IDX is INTEGER array, dimension (N)
            This will contain the permutation used to sort the contents of
            D into ascending order.
            </code>
            </param>
            <param name="idxc">
            <code>
            IDXC is INTEGER array, dimension (N)
            This will contain the permutation used to arrange the columns
            of the deflated U matrix into three groups:  the first group
            contains non-zero entries only at and above NL, the second
            contains non-zero entries only below NL+2, and the third is
            dense.
            </code>
            </param>
            <param name="idxq">
            <code>
            IDXQ is INTEGER array, dimension (N)
            This contains the permutation which separately sorts the two
            sub-problems in D into ascending order.  Note that entries in
            the first hlaf of this permutation must first be moved one
            position backward; and entries in the second half
            must first have NL+1 added to their values.
            </code>
            </param>
            <param name="coltyp">
            <code>
            COLTYP is INTEGER array, dimension (N)
            As workspace, this will contain a label which will indicate
            which of the following types a column in the U2 matrix or a
            row in the VT2 matrix is:
            1 : non-zero in the upper half only
            2 : non-zero in the lower half only
            3 : dense
            4 : deflated
            On exit, it is an array of dimension 4, with COLTYP(I) being
            the dimension of the I-th type columns.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            singular values are close together or if there is a tiny entry in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.
            SLASD2 is called from SLASD1.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaed6(System.Int32,System.Boolean,System.Single,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Single,System.Single@,System.Int32@)">
            <summary>
            <para>
            Computes the positive or negative root (closest to the origin)
            of
                             z(1)        z(2)        z(3)
            f(x) =   rho + --------- + ---------- + ---------
                            d(1)-x      d(2)-x      d(3)-x
            It is assumed that
                  if ORGATI = .</para>
            </summary>
            <param name="kniter">
            <code>
            KNITER is INTEGER
                 Refer to SLAED4 for its significance.
            </code>
            </param>
            <param name="orgati">
            <code>
            ORGATI is LOGICAL
                 If ORGATI is true, the needed root is between d(2) and
                 d(3); otherwise it is between d(1) and d(2).  See
                 SLAED4 for further details.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
                 Refer to the equation f(x) above.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (3)
                 D satisfies d(1) &amp;lt; d(2) &amp;lt; d(3).
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (3)
                 Each of the elements in z must be positive.
            </code>
            </param>
            <param name="finit">
            <code>
            FINIT is REAL
                 The value of f at 0. It is more accurate than the one
                 evaluated inside this routine (if someone wants to do
                 so).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL
                 The root of the equation f(x).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
                 = 0: successful exit
                 > 0: if INFO = 1, failure to converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            true. the root is between d(2) and d(3);
                  otherwise it is between d(1) and d(2)
            This routine will be called by SLAED4 when necessary. In most cases,
            the root sought is the smallest in magnitude, though it might not be
            in some extremely rare situations.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            10/02/03: This version has a few statements commented out for thread
            safety (machine parameters are computed on each entry). SJH.
            05/10/06: Modified from a new version of Ren-Cang Li, use
               Gragg-Thornton-Warner cubic convergent scheme for better stability.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ren-Cang Li, Computer Science Division, University of California
                at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasd5(System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Single,System.Single@,Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Subroutine computes the square root of the I-th eigenvalue
            of a positive symmetric rank-one modification of a 2-by-2 diagonal
            matrix
                       diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .</para>
            </summary>
            <param name="i">
            <code>
            I is INTEGER
            The index of the eigenvalue to be computed.  I = 1 or I = 2.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (2)
            The original eigenvalues.  We assume 0 &amp;lt;= D(1) &amp;lt; D(2).
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (2)
            The components of the updating vector.
            </code>
            </param>
            <param name="delta">
            <code>
            DELTA is REAL array, dimension (2)
            Contains (D(j) - sigma_I) in its  j-th component.
            The vector DELTA contains the information necessary
            to construct the eigenvectors.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            The scalar in the symmetric updating formula.
            </code>
            </param>
            <param name="dsigma">
            <code>
            DSIGMA is REAL
            The computed sigma_I, the I-th updated eigenvalue.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (2)
            WORK contains (D(j) + sigma_I) in its  j-th component.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The diagonal entries in the array D are assumed to satisfy
                       0 &amp;lt;= D(i) &amp;lt; D(j)  for  i &amp;lt; j .
            We also assume RHO > 0 and that the Euclidean norm of the vector
            Z is one.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ren-Cang Li, Computer Science Division, University of California
                at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasd4(System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Single,System.Single@,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Subroutine computes the square root of the I-th updated
            eigenvalue of a positive symmetric rank-one modification to
            a positive diagonal matrix whose entries are given as the squares
            of the corresponding entries in the array d, and that
                   0 &amp;lt;= D(i) &amp;lt; D(j)  for  i &amp;lt; j
            and that RHO > 0.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The length of all arrays.
            </code>
            </param>
            <param name="i">
            <code>
            I is INTEGER
            The index of the eigenvalue to be computed.  1 &amp;lt;= I &amp;lt;= N.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension ( N )
            The original eigenvalues.  It is assumed that they are in
            order, 0 &amp;lt;= D(I) &amp;lt; D(J)  for I &amp;lt; J.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension ( N )
            The components of the updating vector.
            </code>
            </param>
            <param name="delta">
            <code>
            DELTA is REAL array, dimension ( N )
            If N .ne. 1, DELTA contains (D(j) - sigma_I) in its  j-th
            component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
            contains the information necessary to construct the
            (singular) eigenvectors.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            The scalar in the symmetric updating formula.
            </code>
            </param>
            <param name="sigma">
            <code>
            SIGMA is REAL
            The computed sigma_I, the I-th updated eigenvalue.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension ( N )
            If N .ne. 1, WORK contains (D(j) + sigma_I) in its  j-th
            component.  If N = 1, then WORK( 1 ) = 1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            > 0:  if INFO = 1, the updating process failed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is arranged by the calling routine, and is
            no loss in generality.  The rank-one modified system is thus
                   diag( D ) * diag( D ) +  RHO * Z * Z_transpose.
            where we assume the Euclidean norm of Z is 1.
            The method consists of approximating the rational functions in the
            secular equation by simpler interpolating rational functions.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ren-Cang Li, Computer Science Division, University of California
                at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasd3(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Finds all the square roots of the roots of the secular
            equation, as defined by the values in D and Z.</para>
            </summary>
            <param name="nl">
            <code>
            NL is INTEGER
            The row dimension of the upper block.  NL >= 1.
            </code>
            </param>
            <param name="nr">
            <code>
            NR is INTEGER
            The row dimension of the lower block.  NR >= 1.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: the lower block is an NR-by-NR square matrix.
            = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
            The bidiagonal matrix has N = NL + NR + 1 rows and
            M = N + SQRE >= N columns.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The size of the secular equation, 1 =&amp;lt; K = &amp;lt; N.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension(K)
            On exit the square roots of the roots of the secular equation,
            in ascending order.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array,
                       dimension at least (LDQ,K).
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= K.
            </code>
            </param>
            <param name="dsigma">
            <code>
            DSIGMA is REAL array, dimension(K)
            The first K elements of this array contain the old roots
            of the deflated updating problem.  These are the poles
            of the secular equation.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension (LDU, N)
            The last N - K columns of this matrix contain the deflated
            left singular vectors.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= N.
            </code>
            </param>
            <param name="u2">
            <code>
            U2 is REAL array, dimension (LDU2, N)
            The first K columns of this matrix contain the non-deflated
            left singular vectors for the split problem.
            </code>
            <code>
            LDU2 is INTEGER
            The leading dimension of the array U2.  LDU2 >= N.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is REAL array, dimension (LDVT, M)
            The last M - K columns of VT**T contain the deflated
            right singular vectors.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= N.
            </code>
            </param>
            <param name="vt2">
            <code>
            VT2 is REAL array, dimension (LDVT2, N)
            The first K columns of VT2**T contain the non-deflated
            right singular vectors for the split problem.
            </code>
            <code>
            LDVT2 is INTEGER
            The leading dimension of the array VT2.  LDVT2 >= N.
            </code>
            </param>
            <param name="idxc">
            <code>
            IDXC is INTEGER array, dimension (N)
            The permutation used to arrange the columns of U (and rows of
            VT) into three groups:  the first group contains non-zero
            entries only at and above (or before) NL +1; the second
            contains non-zero entries only at and below (or after) NL+2;
            and the third is dense. The first column of U and the row of
            VT are treated separately, however.
            The rows of the singular vectors found by SLASD4
            must be likewise permuted before the matrix multiplies can
            take place.
            </code>
            </param>
            <param name="ctot">
            <code>
            CTOT is INTEGER array, dimension (4)
            A count of the total number of the various types of columns
            in U (or rows in VT), as described in IDXC. The fourth column
            type is any column which has been deflated.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (K)
            The first K elements of this array contain the components
            of the deflation-adjusted updating row vector.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It makes the
            appropriate calls to SLASD4 and then updates the singular
            vectors by matrix multiplication.
            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            SLASD3 is called from SLASD1.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasd1(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},System.Single@,System.Single@,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the SVD of an upper bidiagonal N-by-M matrix B,
            where N = NL + NR + 1 and M = N + SQRE.</para>
            </summary>
            <param name="nl">
            <code>
            NL is INTEGER
            The row dimension of the upper block.  NL >= 1.
            </code>
            </param>
            <param name="nr">
            <code>
            NR is INTEGER
            The row dimension of the lower block.  NR >= 1.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: the lower block is an NR-by-NR square matrix.
            = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
            The bidiagonal matrix has row dimension N = NL + NR + 1,
            and column dimension M = N + SQRE.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (NL+NR+1).
            N = NL+NR+1
            On entry D(1:NL,1:NL) contains the singular values of the
            upper block; and D(NL+2:N) contains the singular values of
            the lower block. On exit D(1:N) contains the singular values
            of the modified matrix.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is REAL
            Contains the diagonal element associated with the added row.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is REAL
            Contains the off-diagonal element associated with the added
            row.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension (LDU,N)
            On entry U(1:NL, 1:NL) contains the left singular vectors of
            the upper block; U(NL+2:N, NL+2:N) contains the left singular
            vectors of the lower block. On exit U contains the left
            singular vectors of the bidiagonal matrix.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= max( 1, N ).
            </code>
            </param>
            <param name="vt">
            <code>
            VT is REAL array, dimension (LDVT,M)
            where M = N + SQRE.
            On entry VT(1:NL+1, 1:NL+1)**T contains the right singular
            vectors of the upper block; VT(NL+2:M, NL+2:M)**T contains
            the right singular vectors of the lower block. On exit
            VT**T contains the right singular vectors of the
            bidiagonal matrix.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= max( 1, M ).
            </code>
            </param>
            <param name="idxq">
            <code>
            IDXQ is INTEGER array, dimension (N)
            This contains the permutation which will reintegrate the
            subproblem just solved back into sorted order, i.e.
            D( IDXQ( I = 1, N ) ) will be in ascending order.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (4*N)
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (3*M**2+2*M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            SLASD1 is called from SLASD0.
            A related subroutine SLASD7 handles the case in which the singular
            values (and the singular vectors in factored form) are desired.
            SLASD1 computes the SVD as follows:
                          ( D1(in)    0    0       0 )
              B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
                          (   0       0   D2(in)   0 )
                = U(out) * ( D(out) 0) * VT(out)
            where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
            with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
            elsewhere; and the entry b is empty if SQRE = 0.
            The left singular vectors of the original matrix are stored in U, and
            the transpose of the right singular vectors are stored in VT, and the
            singular values are in D.  The algorithm consists of three stages:
               The first stage consists of deflating the size of the problem
               when there are multiple singular values or when there are zeros in
               the Z vector.  For each such occurence the dimension of the
               secular equation problem is reduced by one.  This stage is
               performed by the routine SLASD2.
               The second stage consists of calculating the updated
               singular values. This is done by finding the square roots of the
               roots of the secular equation via the routine SLASD4 (as called
               by SLASD3). This routine also calculates the singular vectors of
               the current problem.
               The final stage consists of computing the updated singular vectors
               directly using the updated singular values.  The singular vectors
               for the current problem are multiplied with the singular vectors
               from the overall problem.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slas2(System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            <para>
            Computes the singular values of the 2-by-2 matrix
               [  F   G  ]
               [  0   H  ].</para>
            </summary>
            <param name="f">
            <code>
            F is REAL
            The (1,1) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="g">
            <code>
            G is REAL
            The (1,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="h">
            <code>
            H is REAL
            The (2,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="ssmin">
            <code>
            SSMIN is REAL
            The smaller singular value.
            </code>
            </param>
            <param name="ssmax">
            <code>
            SSMAX is REAL
            The larger singular value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On return, SSMIN is the smaller singular value and SSMAX is the
            larger singular value.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Barring over/underflow, all output quantities are correct to within
            a few units in the last place (ulps), even in the absence of a guard
            digit in addition/subtraction.
            In IEEE arithmetic, the code works correctly if one matrix element is
            infinite.
            Overflow will not occur unless the largest singular value itself
            overflows, or is within a few ulps of overflow. (On machines with
            partial overflow, like the Cray, overflow may occur if the largest
            singular value is within a factor of 2 of overflow.)
            Underflow is harmless if underflow is gradual. Otherwise, results
            may correspond to a matrix modified by perturbations of size near
            the underflow threshold.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasq4(System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single@,System.Int32@,System.Single@)">
            <summary>
            <para>
            Computes an approximation TAU to the smallest eigenvalue
            using values of d from the previous transform.</para>
            </summary>
            <param name="i0">
            <code>
            I0 is INTEGER
            irst index.
            </code>
            </param>
            <param name="n0">
            <code>
            N0 is INTEGER
            ast index.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension ( 4*N )
            Z holds the qd array.
            </code>
            </param>
            <param name="pp">
            <code>
            PP is INTEGER
            P=0 for ping, PP=1 for pong.
            </code>
            </param>
            <param name="n0in">
            <code>
            N0IN is INTEGER
            he value of N0 at start of EIGTEST.
            </code>
            </param>
            <param name="dmin">
            <code>
            DMIN is REAL
            inimum value of d.
            </code>
            </param>
            <param name="dmin1">
            <code>
            DMIN1 is REAL
            inimum value of d, excluding D( N0 ).
            </code>
            </param>
            <param name="dmin2">
            <code>
            DMIN2 is REAL
            inimum value of d, excluding D( N0 ) and D( N0-1 ).
            </code>
            </param>
            <param name="dn">
            <code>
            DN is REAL
            (N)
            </code>
            </param>
            <param name="dn1">
            <code>
            DN1 is REAL
            (N-1)
            </code>
            </param>
            <param name="dn2">
            <code>
            DN2 is REAL
            (N-2)
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL
            his is the shift.
            </code>
            </param>
            <param name="ttype">
            <code>
            TTYPE is INTEGER
            hift type.
            </code>
            </param>
            <param name="g">
            <code>
            G is REAL
            G is passed as an argument in order to save its value between
            calls to SLASQ4.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            CNST1 = 9/16
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasq5(System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32,System.Single,System.Single,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Boolean,System.Single)">
            <summary>
            <para>
            Computes one dqds transform in ping-pong form, one
            version for IEEE machines another for non IEEE machines.</para>
            </summary>
            <param name="i0">
            <code>
            I0 is INTEGER
            irst index.
            </code>
            </param>
            <param name="n0">
            <code>
            N0 is INTEGER
            ast index.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension ( 4*N )
            Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
            an extra argument.
            </code>
            </param>
            <param name="pp">
            <code>
            PP is INTEGER
            P=0 for ping, PP=1 for pong.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL
            his is the shift.
            </code>
            </param>
            <param name="dmin">
            <code>
            DMIN is REAL
            inimum value of d.
            </code>
            </param>
            <param name="dmin1">
            <code>
            DMIN1 is REAL
            inimum value of d, excluding D( N0 ).
            </code>
            </param>
            <param name="dmin2">
            <code>
            DMIN2 is REAL
            inimum value of d, excluding D( N0 ) and D( N0-1 ).
            </code>
            </param>
            <param name="dn">
            <code>
            DN is REAL
            (N0), the last value of d.
            </code>
            </param>
            <param name="dnm1">
            <code>
            DNM1 is REAL
            (N0-1).
            </code>
            </param>
            <param name="dnm2">
            <code>
            DNM2 is REAL
            (N0-2).
            </code>
            </param>
            <param name="ieee">
            <code>
            IEEE is LOGICAL
            lag for IEEE or non IEEE arithmetic.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasq6(System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            <para>
            Computes one dqd (shift equal to zero) transform in
            ping-pong form, with protection against underflow and overflow.</para>
            </summary>
            <param name="i0">
            <code>
            I0 is INTEGER
            irst index.
            </code>
            </param>
            <param name="n0">
            <code>
            N0 is INTEGER
            ast index.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension ( 4*N )
            Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
            an extra argument.
            </code>
            </param>
            <param name="pp">
            <code>
            PP is INTEGER
            P=0 for ping, PP=1 for pong.
            </code>
            </param>
            <param name="dmin">
            <code>
            DMIN is REAL
            inimum value of d.
            </code>
            </param>
            <param name="dmin1">
            <code>
            DMIN1 is REAL
            inimum value of d, excluding D( N0 ).
            </code>
            </param>
            <param name="dmin2">
            <code>
            DMIN2 is REAL
            inimum value of d, excluding D( N0 ) and D( N0-1 ).
            </code>
            </param>
            <param name="dn">
            <code>
            DN is REAL
            (N0), the last value of d.
            </code>
            </param>
            <param name="dnm1">
            <code>
            DNM1 is REAL
            (N0-1).
            </code>
            </param>
            <param name="dnm2">
            <code>
            DNM2 is REAL
            (N0-2).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasq3(System.Int32,System.Int32@,Extreme.Collections.Array1D{System.Single},System.Int32@,System.Single@,System.Single@,System.Single@,System.Single,System.Int32@,System.Int32@,System.Int32@,System.Boolean,System.Int32@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            <para>
            Checks for deflation, computes a shift (TAU) and calls dqds.</para>
            </summary>
            <param name="i0">
            <code>
            I0 is INTEGER
            First index.
            </code>
            </param>
            <param name="n0">
            <code>
            N0 is INTEGER
            Last index.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension ( 4*N )
            Z holds the qd array.
            </code>
            </param>
            <param name="pp">
            <code>
            PP is INTEGER
            PP=0 for ping, PP=1 for pong.
            PP=2 indicates that flipping was applied to the Z array
            and that the initial tests for deflation should not be
            performed.
            </code>
            </param>
            <param name="dmin">
            <code>
            DMIN is REAL
            Minimum value of d.
            </code>
            </param>
            <param name="sigma">
            <code>
            SIGMA is REAL
            Sum of shifts used in current segment.
            </code>
            </param>
            <param name="desig">
            <code>
            DESIG is REAL
            Lower order part of SIGMA
            </code>
            </param>
            <param name="qmax">
            <code>
            QMAX is REAL
            Maximum value of q.
            </code>
            </param>
            <param name="nfail">
            <code>
            NFAIL is INTEGER
            Number of times shift was too big.
            </code>
            </param>
            <param name="iter">
            <code>
            ITER is INTEGER
            Number of iterations.
            </code>
            </param>
            <param name="ndiv">
            <code>
            NDIV is INTEGER
            Number of divisions.
            </code>
            </param>
            <param name="ieee">
            <code>
            IEEE is LOGICAL
            Flag for IEEE or non IEEE arithmetic (passed to SLASQ5).
            </code>
            </param>
            <param name="ttype">
            <code>
            TTYPE is INTEGER
            Shift type.
            </code>
            </param>
            <param name="dmin1">
            <code>
            DMIN1 is REAL
            </code>
            </param>
            <param name="dmin2">
            <code>
            DMIN2 is REAL
            </code>
            </param>
            <param name="dn">
            <code>
            DN is REAL
            </code>
            </param>
            <param name="dn1">
            <code>
            DN1 is REAL
            </code>
            </param>
            <param name="dn2">
            <code>
            DN2 is REAL
            </code>
            </param>
            <param name="g">
            <code>
            G is REAL
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL
            These are passed as arguments in order to save their values
            between calls to SLASQ3.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            In case of failure it changes shifts, and tries again until output
            is positive.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasrt(System.Char,System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            The numbers in D in increasing order (if ID = 'I') or
            in decreasing order (if ID = 'D' ).</para>
            </summary>
            <param name="id">
            <code>
            ID is CHARACTER*1
            = 'I': sort D in increasing order;
            = 'D': sort D in decreasing order.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The length of the array D.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the array to be sorted.
            On exit, D has been sorted into increasing order
            (D(1) &amp;lt;= ... &amp;lt;= D(N) ) or into decreasing order
            (D(1) >= ... >= D(N) ), depending on ID.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Use Quick Sort, reverting to Insertion sort on arrays of
            size &amp;lt;= 20. Dimension of STACK limits N to about 2**32.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasq2(System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes all the eigenvalues of the symmetric positive
            definite tridiagonal matrix associated with the qd array Z to high
            relative accuracy are computed to high relative accuracy, in the
            absence of denormalization, underflow and overflow.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            he number of rows and columns in the matrix. N >= 0.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension ( 4*N )
            n entry Z holds the qd array. On exit, entries 1 to N hold
            the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
            trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
            N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
            holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
            shifts that failed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if the i-th argument is a scalar and had an illegal
                 value, then INFO = -i, if the i-th argument is an
                 array and the j-entry had an illegal value, then
                 INFO = -(i*100+j)
            > 0: the algorithm failed
                  = 1, a split was marked by a positive value in E
                  = 2, current block of Z not diagonalized after 100*N
                       iterations (in inner while loop).  On exit Z holds
                       a qd array with the same eigenvalues as the given Z.
                  = 3, termination criterion of outer while loop not met
                       (program created more than N unreduced blocks)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            To see the relation of Z to the tridiagonal matrix, let L be a
            unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
            let U be an upper bidiagonal matrix with 1's above and diagonal
            Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
            symmetric tridiagonal to which it is similar.
            Note : SLASQ2 defines a logical variable, IEEE, which is true
            on machines which follow ieee-754 floating-point standard in their
            handling of infinities and NaNs, and false otherwise. This variable
            is passed to SLASQ3.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Local Variables: I0:N0 defines a current unreduced segment of Z.
            The shifts are accumulated in SIGMA. Iteration count is in ITER.
            Ping-pong is controlled by PP (alternates between 0 and 1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasq1(System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the singular values of a real N-by-N bidiagonal
            matrix with diagonal D and off-diagonal E.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            he number of rows and columns in the matrix. N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            n entry, D contains the diagonal elements of the
            bidiagonal matrix whose SVD is desired. On normal exit,
            D contains the singular values in decreasing order.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N)
            n entry, elements E(1:N-1) contain the off-diagonal elements
            of the bidiagonal matrix whose SVD is desired.
            On exit, E is overwritten.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (4*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: the algorithm failed
                 = 1, a split was marked by a positive value in E
                 = 2, current block of Z not diagonalized after 100*N
                      iterations (in inner while loop)  On exit D and E
                      represent a matrix with the same singular values
                      which the calling subroutine could use to finish the
                      computation, or even feed back into SLASQ1
                 = 3, termination criterion of outer while loop not met
                      (program created more than N unreduced blocks)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The singular values
            are computed to high relative accuracy, in the absence of
            denormalization, underflow and overflow. The algorithm was first
            presented in
            "Accurate singular values and differential qd algorithms" by K. V.
            Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
            1994,
            and the present implementation is described in "An implementation of
            the dqds Algorithm (Positive Case)", LAPACK Working Note.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasr(Extreme.Mathematics.MatrixOperationSide,System.Char,System.Char,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Applies a sequence of plane rotations to a real matrix A,
            from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            Specifies whether the plane rotation matrix P is applied to
            A on the left or the right.
            = 'L':  Left, compute A := P*A
            = 'R':  Right, compute A:= A*P**T
            </code>
            </param>
            <param name="pivot">
            <code>
            PIVOT is CHARACTER*1
            Specifies the plane for which P(k) is a plane rotation
            matrix.
            = 'V':  Variable pivot, the plane (k,k+1)
            = 'T':  Top pivot, the plane (1,k+1)
            = 'B':  Bottom pivot, the plane (k,z)
            </code>
            </param>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Specifies whether P is a forward or backward sequence of
            plane rotations.
            = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
            = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  If m &amp;lt;= 1, an immediate
            return is effected.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  If n &amp;lt;= 1, an
            immediate return is effected.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension
                    (M-1) if SIDE = 'L'
                    (N-1) if SIDE = 'R'
            The cosines c(k) of the plane rotations.
            </code>
            </param>
            <param name="s">
            <code>
            S is REAL array, dimension
                    (M-1) if SIDE = 'L'
                    (N-1) if SIDE = 'R'
            The sines s(k) of the plane rotations.  The 2-by-2 plane
            rotation part of the matrix P(k), R(k), has the form
            R(k) = (  c(k)  s(k) )
                   ( -s(k)  c(k) ).
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The M-by-N matrix A.  On exit, A is overwritten by P*A if
            SIDE = 'R' or by A*P**T if SIDE = 'L'.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            When SIDE = 'L', the transformation takes the form
               A := P*A
            and when SIDE = 'R', the transformation takes the form
               A := A*P**T
            where P is an orthogonal matrix consisting of a sequence of z plane
            rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
            and P**T is the transpose of P.
            When DIRECT = 'F' (Forward sequence), then
               P = P(z-1) * ... * P(2) * P(1)
            and when DIRECT = 'B' (Backward sequence), then
               P = P(1) * P(2) * ... * P(z-1)
            where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
               R(k) = (  c(k)  s(k) )
                    = ( -s(k)  c(k) ).
            When PIVOT = 'V' (Variable pivot), the rotation is performed
            for the plane (k,k+1), i.e., P(k) has the form
               P(k) = (  1                                            )
                      (       ...                                     )
                      (              1                                )
                      (                   c(k)  s(k)                  )
                      (                  -s(k)  c(k)                  )
                      (                                1              )
                      (                                     ...       )
                      (                                            1  )
            where R(k) appears as a rank-2 modification to the identity matrix in
            rows and columns k and k+1.
            When PIVOT = 'T' (Top pivot), the rotation is performed for the
            plane (1,k+1), so P(k) has the form
               P(k) = (  c(k)                    s(k)                 )
                      (         1                                     )
                      (              ...                              )
                      (                     1                         )
                      ( -s(k)                    c(k)                 )
                      (                                 1             )
                      (                                      ...      )
                      (                                             1 )
            where R(k) appears in rows and columns 1 and k+1.
            Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
            performed for the plane (k,z), giving P(k) the form
               P(k) = ( 1                                             )
                      (      ...                                      )
                      (             1                                 )
                      (                  c(k)                    s(k) )
                      (                         1                     )
                      (                              ...              )
                      (                                     1         )
                      (                 -s(k)                    c(k) )
            where R(k) appears in rows and columns k and z.  The rotations are
            performed without ever forming P(k) explicitly.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasv2(System.Single,System.Single,System.Single,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            <para>
            Computes the singular value decomposition of a 2-by-2
            triangular matrix
               [  F   G  ]
               [  0   H  ].</para>
            </summary>
            <param name="f">
            <code>
            F is REAL
            The (1,1) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="g">
            <code>
            G is REAL
            The (1,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="h">
            <code>
            H is REAL
            The (2,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="ssmin">
            <code>
            SSMIN is REAL
            abs(SSMIN) is the smaller singular value.
            </code>
            </param>
            <param name="ssmax">
            <code>
            SSMAX is REAL
            abs(SSMAX) is the larger singular value.
            </code>
            </param>
            <param name="snl">
            <code>
            SNL is REAL
            </code>
            </param>
            <param name="csl">
            <code>
            CSL is REAL
            The vector (CSL, SNL) is a unit left singular vector for the
            singular value abs(SSMAX).
            </code>
            </param>
            <param name="snr">
            <code>
            SNR is REAL
            </code>
            </param>
            <param name="csr">
            <code>
            CSR is REAL
            The vector (CSR, SNR) is a unit right singular vector for the
            singular value abs(SSMAX).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
            smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
            right singular vectors for abs(SSMAX), giving the decomposition
               [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
               [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Any input parameter may be aliased with any output parameter.
            Barring over/underflow and assuming a guard digit in subtraction, all
            output quantities are correct to within a few units in the last
            place (ulps).
            In IEEE arithmetic, the code works correctly if one matrix element is
            infinite.
            Overflow will not occur unless the largest singular value itself
            overflows or is within a few ulps of overflow. (On machines with
            partial overflow, like the Cray, overflow may occur if the largest
            singular value is within a factor of 2 of overflow.)
            Underflow is harmless if underflow is gradual. Otherwise, results
            may correspond to a matrix modified by perturbations of size near
            the underflow threshold.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasdq(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a real
            (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
            E, accumulating the transformations if desired.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            n entry, UPLO specifies whether the input bidiagonal matrix
            is upper or lower bidiagonal, and wether it is square are
            not.
               UPLO = 'U' or 'u'   B is upper bidiagonal.
               UPLO = 'L' or 'l'   B is lower bidiagonal.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: then the input matrix is N-by-N.
            = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
                 (N+1)-by-N if UPLU = 'L'.
            The bidiagonal matrix has
            N = NL + NR + 1 rows and
            M = N + SQRE >= N columns.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            n entry, N specifies the number of rows and columns
            in the matrix. N must be at least 0.
            </code>
            </param>
            <param name="ncvt">
            <code>
            NCVT is INTEGER
            n entry, NCVT specifies the number of columns of
            the matrix VT. NCVT must be at least 0.
            </code>
            </param>
            <param name="nru">
            <code>
            NRU is INTEGER
            n entry, NRU specifies the number of rows of
            the matrix U. NRU must be at least 0.
            </code>
            </param>
            <param name="ncc">
            <code>
            NCC is INTEGER
            n entry, NCC specifies the number of columns of
            the matrix C. NCC must be at least 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            n entry, D contains the diagonal entries of the
            bidiagonal matrix whose SVD is desired. On normal exit,
            D contains the singular values in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array.
            imension is (N-1) if SQRE = 0 and N if SQRE = 1.
            On entry, the entries of E contain the offdiagonal entries
            of the bidiagonal matrix whose SVD is desired. On normal
            exit, E will contain 0. If the algorithm does not converge,
            D and E will contain the diagonal and superdiagonal entries
            of a bidiagonal matrix orthogonally equivalent to the one
            given as input.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is REAL array, dimension (LDVT, NCVT)
            n entry, contains a matrix which on exit has been
            premultiplied by P**T, dimension N-by-NCVT if SQRE = 0
            and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).
            </code>
            <code>
            LDVT is INTEGER
            n entry, LDVT specifies the leading dimension of VT as
            declared in the calling (sub) program. LDVT must be at
            least 1. If NCVT is nonzero LDVT must also be at least N.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension (LDU, N)
            n entry, contains a  matrix which on exit has been
            postmultiplied by Q, dimension NRU-by-N if SQRE = 0
            and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).
            </code>
            <code>
            LDU is INTEGER
            n entry, LDU  specifies the leading dimension of U as
            declared in the calling (sub) program. LDU must be at
            least max( 1, NRU ) .
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC, NCC)
            n entry, contains an N-by-NCC matrix which on exit
            has been premultiplied by Q**T  dimension N-by-NCC if SQRE = 0
            and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).
            </code>
            <code>
            LDC is INTEGER
            n entry, LDC  specifies the leading dimension of C as
            declared in the calling (sub) program. LDC must be at
            least 1. If NCC is nonzero, LDC must also be at least N.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (4*N)
            orkspace. Only referenced if one of NCVT, NRU, or NCC is
            nonzero, and if N is at least 2.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            n exit, a value of 0 indicates a successful exit.
            If INFO &amp;lt; 0, argument number -INFO is illegal.
            If INFO > 0, the algorithm did not converge, and INFO
            specifies how many superdiagonals did not converge.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Letting B denote
            the input bidiagonal matrix, the algorithm computes orthogonal
            matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose
            of P). The singular values S are overwritten on D.
            The input matrix U  is changed to U  * Q  if desired.
            The input matrix VT is changed to P**T * VT if desired.
            The input matrix C  is changed to Q**T * C  if desired.
            See "Computing  Small Singular Values of Bidiagonal Matrices With
            Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
            LAPACK Working Note #3, for a detailed description of the algorithm.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasdt(System.Int32,System.Int32@,System.Int32@,Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32)">
            <summary>
            <para>
            Creates a tree of subproblems for bidiagonal divide and
            conquer.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            On entry, the number of diagonal elements of the
            bidiagonal matrix.
            </code>
            </param>
            <param name="lvl">
            <code>
            LVL is INTEGER
            On exit, the number of levels on the computation tree.
            </code>
            </param>
            <param name="nd">
            <code>
            ND is INTEGER
            On exit, the number of nodes on the tree.
            </code>
            </param>
            <param name="inode">
            <code>
            INODE is INTEGER array, dimension ( N )
            On exit, centers of subproblems.
            </code>
            </param>
            <param name="ndiml">
            <code>
            NDIML is INTEGER array, dimension ( N )
            On exit, row dimensions of left children.
            </code>
            </param>
            <param name="ndimr">
            <code>
            NDIMR is INTEGER array, dimension ( N )
            On exit, row dimensions of right children.
            </code>
            </param>
            <param name="msub">
            <code>
            MSUB is INTEGER
            On entry, the maximum row dimension each subproblem at the
            bottom of the tree can be of.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasd0(System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32,Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            A divide and conquer approach, SLASD0 computes the singular
            value decomposition (SVD) of a real upper bidiagonal N-by-M
            matrix B with diagonal D and offdiagonal E, where M = N + SQRE.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            On entry, the row dimension of the upper bidiagonal matrix.
            This is also the dimension of the main diagonal array D.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            Specifies the column dimension of the bidiagonal matrix.
            = 0: The bidiagonal matrix has column dimension M = N;
            = 1: The bidiagonal matrix has column dimension M = N+1;
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry D contains the main diagonal of the bidiagonal
            matrix.
            On exit D, if INFO = 0, contains its singular values.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (M-1)
            Contains the subdiagonal entries of the bidiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension at least (LDQ, N)
            On exit, U contains the left singular vectors.
            </code>
            <code>
            LDU is INTEGER
            On entry, leading dimension of U.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is REAL array, dimension at least (LDVT, M)
            On exit, VT**T contains the right singular vectors.
            </code>
            <code>
            LDVT is INTEGER
            On entry, leading dimension of VT.
            </code>
            </param>
            <param name="smlsiz">
            <code>
            SMLSIZ is INTEGER
            On entry, maximum size of the subproblems at the
            bottom of the computation tree.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (8*N)
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (3*M**2+2*M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The algorithm computes orthogonal matrices U and VT such that
            B = U * S * VT. The singular values S are overwritten on D.
            A related subroutine, SLASDA, computes only the singular values,
            and optionally, the singular vectors in compact form.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasd7(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Single,System.Single,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@,Extreme.Collections.Array2D{System.Int32},System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32,System.Single@,System.Single@,System.Int32@)">
            <summary>
            <para>
            Merges the two sets of singular values together into a single
            sorted set.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            Specifies whether singular vectors are to be computed
            in compact form, as follows:
            = 0: Compute singular values only.
            = 1: Compute singular vectors of upper
                 bidiagonal matrix in compact form.
            </code>
            </param>
            <param name="nl">
            <code>
            NL is INTEGER
            The row dimension of the upper block. NL >= 1.
            </code>
            </param>
            <param name="nr">
            <code>
            NR is INTEGER
            The row dimension of the lower block. NR >= 1.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: the lower block is an NR-by-NR square matrix.
            = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
            The bidiagonal matrix has
            N = NL + NR + 1 rows and
            M = N + SQRE >= N columns.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            Contains the dimension of the non-deflated matrix, this is
            the order of the related secular equation. 1 &amp;lt;= K &amp;lt;=N.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension ( N )
            On entry D contains the singular values of the two submatrices
            to be combined. On exit D contains the trailing (N-K) updated
            singular values (those which were deflated) sorted into
            increasing order.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension ( M )
            On exit Z contains the updating row vector in the secular
            equation.
            </code>
            </param>
            <param name="zw">
            <code>
            ZW is REAL array, dimension ( M )
            Workspace for Z.
            </code>
            </param>
            <param name="vf">
            <code>
            VF is REAL array, dimension ( M )
            On entry, VF(1:NL+1) contains the first components of all
            right singular vectors of the upper block; and VF(NL+2:M)
            contains the first components of all right singular vectors
            of the lower block. On exit, VF contains the first components
            of all right singular vectors of the bidiagonal matrix.
            </code>
            </param>
            <param name="vfw">
            <code>
            VFW is REAL array, dimension ( M )
            Workspace for VF.
            </code>
            </param>
            <param name="vl">
            <code>
            VL is REAL array, dimension ( M )
            On entry, VL(1:NL+1) contains the  last components of all
            right singular vectors of the upper block; and VL(NL+2:M)
            contains the last components of all right singular vectors
            of the lower block. On exit, VL contains the last components
            of all right singular vectors of the bidiagonal matrix.
            </code>
            </param>
            <param name="vlw">
            <code>
            VLW is REAL array, dimension ( M )
            Workspace for VL.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is REAL
            Contains the diagonal element associated with the added row.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is REAL
            Contains the off-diagonal element associated with the added
            row.
            </code>
            </param>
            <param name="dsigma">
            <code>
            DSIGMA is REAL array, dimension ( N )
            Contains a copy of the diagonal elements (K-1 singular values
            and one zero) in the secular equation.
            </code>
            </param>
            <param name="idx">
            <code>
            IDX is INTEGER array, dimension ( N )
            This will contain the permutation used to sort the contents of
            D into ascending order.
            </code>
            </param>
            <param name="idxp">
            <code>
            IDXP is INTEGER array, dimension ( N )
            This will contain the permutation used to place deflated
            values of D at the end of the array. On output IDXP(2:K)
            points to the nondeflated D-values and IDXP(K+1:N)
            points to the deflated singular values.
            </code>
            </param>
            <param name="idxq">
            <code>
            IDXQ is INTEGER array, dimension ( N )
            This contains the permutation which separately sorts the two
            sub-problems in D into ascending order.  Note that entries in
            the first half of this permutation must first be moved one
            position backward; and entries in the second half
            must first have NL+1 added to their values.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension ( N )
            The permutations (from deflation and sorting) to be applied
            to each singular block. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER
            The number of Givens rotations which took place in this
            subproblem. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="ldgcol">
            <code>
            LDGCOL is INTEGER
            The leading dimension of GIVCOL, must be at least N.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is REAL array, dimension ( LDGNUM, 2 )
            Each number indicates the C or S value to be used in the
            corresponding Givens rotation. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="ldgnum">
            <code>
            LDGNUM is INTEGER
            The leading dimension of GIVNUM, must be at least N.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL
            C contains garbage if SQRE =0 and the C-value of a Givens
            rotation related to the right null space if SQRE = 1.
            </code>
            </param>
            <param name="s">
            <code>
            S is REAL
            S contains garbage if SQRE =0 and the S-value of a Givens
            rotation related to the right null space if SQRE = 1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Then it tries to deflate the size of the problem. There
            are two ways in which deflation can occur:  when two or more singular
            values are close together or if there is a tiny entry in the Z
            vector. For each such occurrence the order of the related
            secular equation problem is reduced by one.
            SLASD7 is called from SLASD6.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasd8(System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Finds the square roots of the roots of the secular equation,
            as defined by the values in DSIGMA and Z.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            Specifies whether singular vectors are to be computed in
            factored form in the calling routine:
            = 0: Compute singular values only.
            = 1: Compute singular vectors in factored form as well.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of terms in the rational function to be solved
            by SLASD4.  K >= 1.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension ( K )
            On output, D contains the updated singular values.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension ( K )
            On entry, the first K elements of this array contain the
            components of the deflation-adjusted updating row vector.
            On exit, Z is updated.
            </code>
            </param>
            <param name="vf">
            <code>
            VF is REAL array, dimension ( K )
            On entry, VF contains  information passed through DBEDE8.
            On exit, VF contains the first K components of the first
            components of all right singular vectors of the bidiagonal
            matrix.
            </code>
            </param>
            <param name="vl">
            <code>
            VL is REAL array, dimension ( K )
            On entry, VL contains  information passed through DBEDE8.
            On exit, VL contains the first K components of the last
            components of all right singular vectors of the bidiagonal
            matrix.
            </code>
            </param>
            <param name="difl">
            <code>
            DIFL is REAL array, dimension ( K )
            On exit, DIFL(I) = D(I) - DSIGMA(I).
            </code>
            </param>
            <param name="difr">
            <code>
            DIFR is REAL array,
                     dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
                     dimension ( K ) if ICOMPQ = 0.
            On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
            defined and will not be referenced.
            If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
            normalizing factors for the right singular vector matrix.
            </code>
            <code>
            LDDIFR is INTEGER
            The leading dimension of DIFR, must be at least K.
            </code>
            </param>
            <param name="dsigma">
            <code>
            DSIGMA is REAL array, dimension ( K )
            On entry, the first K elements of this array contain the old
            roots of the deflated updating problem.  These are the poles
            of the secular equation.
            On exit, the elements of DSIGMA may be very slightly altered
            in value.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension at least 3 * K
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It makes the appropriate
            calls to SLASD4, and stores, for each  element in D, the distance
            to its two nearest poles (elements in DSIGMA). It also updates
            the arrays VF and VL, the first and last components of all the
            right singular vectors of the original bidiagonal matrix.
            SLASD8 is called from SLASD6.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasd6(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Single@,System.Single@,Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@,Extreme.Collections.Array2D{System.Int32},System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@,System.Single@,System.Single@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the SVD of an updated upper bidiagonal matrix B
            obtained by merging two smaller ones by appending a row.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            Specifies whether singular vectors are to be computed in
            factored form:
            = 0: Compute singular values only.
            = 1: Compute singular vectors in factored form as well.
            </code>
            </param>
            <param name="nl">
            <code>
            NL is INTEGER
            The row dimension of the upper block.  NL >= 1.
            </code>
            </param>
            <param name="nr">
            <code>
            NR is INTEGER
            The row dimension of the lower block.  NR >= 1.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: the lower block is an NR-by-NR square matrix.
            = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
            The bidiagonal matrix has row dimension N = NL + NR + 1,
            and column dimension M = N + SQRE.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (NL+NR+1).
            On entry D(1:NL,1:NL) contains the singular values of the
            upper block, and D(NL+2:N) contains the singular values
            of the lower block. On exit D(1:N) contains the singular
            values of the modified matrix.
            </code>
            </param>
            <param name="vf">
            <code>
            VF is REAL array, dimension (M)
            On entry, VF(1:NL+1) contains the first components of all
            right singular vectors of the upper block; and VF(NL+2:M)
            contains the first components of all right singular vectors
            of the lower block. On exit, VF contains the first components
            of all right singular vectors of the bidiagonal matrix.
            </code>
            </param>
            <param name="vl">
            <code>
            VL is REAL array, dimension (M)
            On entry, VL(1:NL+1) contains the  last components of all
            right singular vectors of the upper block; and VL(NL+2:M)
            contains the last components of all right singular vectors of
            the lower block. On exit, VL contains the last components of
            all right singular vectors of the bidiagonal matrix.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is REAL
            Contains the diagonal element associated with the added row.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is REAL
            Contains the off-diagonal element associated with the added
            row.
            </code>
            </param>
            <param name="idxq">
            <code>
            IDXQ is INTEGER array, dimension (N)
            This contains the permutation which will reintegrate the
            subproblem just solved back into sorted order, i.e.
            D( IDXQ( I = 1, N ) ) will be in ascending order.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension ( N )
            The permutations (from deflation and sorting) to be applied
            to each block. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER
            The number of Givens rotations which took place in this
            subproblem. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="ldgcol">
            <code>
            LDGCOL is INTEGER
            leading dimension of GIVCOL, must be at least N.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is REAL array, dimension ( LDGNUM, 2 )
            Each number indicates the C or S value to be used in the
            corresponding Givens rotation. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="ldgnum">
            <code>
            LDGNUM is INTEGER
            The leading dimension of GIVNUM and POLES, must be at least N.
            </code>
            </param>
            <param name="poles">
            <code>
            POLES is REAL array, dimension ( LDGNUM, 2 )
            On exit, POLES(1,*) is an array containing the new singular
            values obtained from solving the secular equation, and
            POLES(2,*) is an array containing the poles in the secular
            equation. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="difl">
            <code>
            DIFL is REAL array, dimension ( N )
            On exit, DIFL(I) is the distance between I-th updated
            (undeflated) singular value and the I-th (undeflated) old
            singular value.
            </code>
            </param>
            <param name="difr">
            <code>
            DIFR is REAL array,
                    dimension ( LDGNUM, 2 ) if ICOMPQ = 1 and
                    dimension ( N ) if ICOMPQ = 0.
            On exit, DIFR(I, 1) is the distance between I-th updated
            (undeflated) singular value and the I+1-th (undeflated) old
            singular value.
            If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
            normalizing factors for the right singular vector matrix.
            See SLASD8 for details on DIFL and DIFR.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension ( M )
            The first elements of this array contain the components
            of the deflation-adjusted updating row vector.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            Contains the dimension of the non-deflated matrix,
            This is the order of the related secular equation. 1 &amp;lt;= K &amp;lt;=N.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL
            C contains garbage if SQRE =0 and the C-value of a Givens
            rotation related to the right null space if SQRE = 1.
            </code>
            </param>
            <param name="s">
            <code>
            S is REAL
            S contains garbage if SQRE =0 and the S-value of a Givens
            rotation related to the right null space if SQRE = 1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension ( 4 * M )
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension ( 3 * N )
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This
            routine is used only for the problem which requires all singular
            values and optionally singular vector matrices in factored form.
            B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
            A related subroutine, SLASD1, handles the case in which all singular
            values and singular vectors of the bidiagonal matrix are desired.
            SLASD6 computes the SVD as follows:
                          ( D1(in)    0    0       0 )
              B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
                          (   0       0   D2(in)   0 )
                = U(out) * ( D(out) 0) * VT(out)
            where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
            with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
            elsewhere; and the entry b is empty if SQRE = 0.
            The singular values of B can be computed using D1, D2, the first
            components of all the right singular vectors of the lower block, and
            the last components of all the right singular vectors of the upper
            block. These components are stored and updated in VF and VL,
            respectively, in SLASD6. Hence U and VT are not explicitly
            referenced.
            The singular values are stored in D. The algorithm consists of two
            stages:
                  The first stage consists of deflating the size of the problem
                  when there are multiple singular values or if there is a zero
                  in the Z vector. For each such occurence the dimension of the
                  secular equation problem is reduced by one. This stage is
                  performed by the routine SLASD7.
                  The second stage consists of calculating the updated
                  singular values. This is done by finding the roots of the
                  secular equation via the routine SLASD4 (as called by SLASD8).
                  This routine also updates VF and VL and computes the distances
                  between the updated singular values and the old singular
                  values.
            SLASD6 is called from SLASDA.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasda(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Int32},System.Int32,Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            A divide and conquer approach, SLASDA computes the singular
            value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
            B with diagonal D and offdiagonal E, where M = N + SQRE.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            Specifies whether singular vectors are to be computed
            in compact form, as follows
            = 0: Compute singular values only.
            = 1: Compute singular vectors of upper bidiagonal
                 matrix in compact form.
            </code>
            </param>
            <param name="smlsiz">
            <code>
            SMLSIZ is INTEGER
            The maximum size of the subproblems at the bottom of the
            computation tree.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The row dimension of the upper bidiagonal matrix. This is
            also the dimension of the main diagonal array D.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            Specifies the column dimension of the bidiagonal matrix.
            = 0: The bidiagonal matrix has column dimension M = N;
            = 1: The bidiagonal matrix has column dimension M = N + 1.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension ( N )
            On entry D contains the main diagonal of the bidiagonal
            matrix. On exit D, if INFO = 0, contains its singular values.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension ( M-1 )
            Contains the subdiagonal entries of the bidiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array,
            dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
            if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
            singular vector matrices of all subproblems at the bottom
            level.
            </code>
            <code>
            LDU is INTEGER, LDU = > N.
            The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
            GIVNUM, and Z.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is REAL array,
            dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
            if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT**T contains the right
            singular vector matrices of all subproblems at the bottom
            level.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER array, dimension ( N )
            if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.
            If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
            secular equation on the computation tree.
            </code>
            </param>
            <param name="difl">
            <code>
            DIFL is REAL array, dimension ( LDU, NLVL ),
            where NLVL = floor(log_2 (N/SMLSIZ))).
            </code>
            </param>
            <param name="difr">
            <code>
            DIFR is REAL array,
                    dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and
                    dimension ( N ) if ICOMPQ = 0.
            If ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)
            record distances between singular values on the I-th
            level and singular values on the (I -1)-th level, and
            DIFR(1:N, 2 * I ) contains the normalizing factors for
            the right singular vector matrix. See SLASD8 for details.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array,
                    dimension ( LDU, NLVL ) if ICOMPQ = 1 and
                    dimension ( N ) if ICOMPQ = 0.
            The first K elements of Z(1, I) contain the components of
            the deflation-adjusted updating row vector for subproblems
            on the I-th level.
            </code>
            </param>
            <param name="poles">
            <code>
            POLES is REAL array,
            dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced
            if ICOMPQ = 0. If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and
            POLES(1, 2*I) contain  the new and old singular values
            involved in the secular equations on the I-th level.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER array,
            dimension ( N ) if ICOMPQ = 1, and not referenced if
            ICOMPQ = 0. If ICOMPQ = 1, on exit, GIVPTR( I ) records
            the number of Givens rotations performed on the I-th
            problem on the computation tree.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array,
            dimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not
            referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
            GIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations
            of Givens rotations performed on the I-th level on the
            computation tree.
            </code>
            </param>
            <param name="ldgcol">
            <code>
            LDGCOL is INTEGER, LDGCOL = > N.
            The leading dimension of arrays GIVCOL and PERM.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension ( LDGCOL, NLVL )
            if ICOMPQ = 1, and not referenced
            if ICOMPQ = 0. If ICOMPQ = 1, on exit, PERM(1, I) records
            permutations done on the I-th level of the computation tree.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is REAL array,
            dimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not
            referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
            GIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-
            values of Givens rotations performed on the I-th level on
            the computation tree.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array,
            dimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.
            If ICOMPQ = 1 and the I-th subproblem is not square, on exit,
            C( I ) contains the C-value of a Givens rotation related to
            the right null space of the I-th subproblem.
            </code>
            </param>
            <param name="s">
            <code>
            S is REAL array, dimension ( N ) if
            ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
            and the I-th subproblem is not square, on exit, S( I )
            contains the S-value of a Givens rotation related to
            the right null space of the I-th subproblem.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension
            (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (7*N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The
            algorithm computes the singular values in the SVD B = U * S * VT.
            The orthogonal matrices U and VT are optionally computed in
            compact form.
            A related subroutine, SLASD0, computes the singular values and
            the singular vectors in explicit form.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slabrd(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Reduces the first NB rows and columns of a real general
            m by n matrix A to upper or lower bidiagonal form by an orthogonal
            transformation Q**T * A * P, and returns the matrices X and Y which
            are needed to apply the transformation to the unreduced part of A.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of leading rows and columns of A to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit, the first NB rows and columns of the matrix are
            overwritten; the rest of the array is unchanged.
            If m >= n, elements on and below the diagonal in the first NB
              columns, with the array TAUQ, represent the orthogonal
              matrix Q as a product of elementary reflectors; and
              elements above the diagonal in the first NB rows, with the
              array TAUP, represent the orthogonal matrix P as a product
              of elementary reflectors.
            If m &amp;lt; n, elements below the diagonal in the first NB
              columns, with the array TAUQ, represent the orthogonal
              matrix Q as a product of elementary reflectors, and
              elements on and above the diagonal in the first NB rows,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (NB)
            The diagonal elements of the first NB rows and columns of
            the reduced matrix.  D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (NB)
            The off-diagonal elements of the first NB rows and columns of
            the reduced matrix.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is REAL array dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is REAL array, dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix P. See Further Details.
            </code>
            </param>
            <param name="x">
            <code>
            X is REAL array, dimension (LDX,NB)
            The m-by-nb matrix X required to update the unreduced part
            of A.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of the array X. LDX >= max(1,M).
            </code>
            </param>
            <param name="y">
            <code>
            Y is REAL array, dimension (LDY,NB)
            The n-by-nb matrix Y required to update the unreduced part
            of A.
            </code>
            <code>
            LDY is INTEGER
            The leading dimension of the array Y. LDY >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, A is reduced to upper bidiagonal form; if m &amp;lt; n, to lower
            bidiagonal form.
            This is an auxiliary routine called by SGEBRD
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
               Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
            where tauq and taup are real scalars, and v and u are real vectors.
            If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
            A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
            A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
            A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
            A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            The elements of the vectors v and u together form the m-by-nb matrix
            V and the nb-by-n matrix U**T which are needed, with X and Y, to apply
            the transformation to the unreduced part of the matrix, using a block
            update of the form:  A := A - V*Y**T - X*U**T.
            The contents of A on exit are illustrated by the following examples
            with nb = 2:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
              (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
              (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
              (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
              (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
              (  v1  v2  a   a   a  )
            where a denotes an element of the original matrix which is unchanged,
            vi denotes an element of the vector defining H(i), and ui an element
            of the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slapmt(System.Boolean,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32})">
            <summary>
            <para>
            Rearranges the columns of the M by N matrix X as specified
            by the permutation K(1),K(2),.</para>
            </summary>
            <param name="forwrd">
            <code>
            FORWRD is LOGICAL
            = .TRUE., forward permutation
            = .FALSE., backward permutation
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix X. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix X. N >= 0.
            </code>
            </param>
            <param name="x">
            <code>
            X is REAL array, dimension (LDX,N)
            On entry, the M by N matrix X.
            On exit, X contains the permuted matrix X.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of the array X, LDX >= MAX(1,M).
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER array, dimension (N)
            On entry, K contains the permutation vector. K is used as
            internal workspace, but reset to its original value on
            output.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If FORWRD = .TRUE.,  forward permutation:
                 X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
            If FORWRD = .FALSE., backward permutation:
                 X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slags2(System.Boolean,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            <para>
            Computes 2-by-2 orthogonal matrices U, V and Q, such
            that if ( UPPER ) then
                      U**T *A*Q = U**T *( A1 A2 )*Q = ( x  0  )
                                        ( 0  A3 )     ( x  x  )
            and
                      V**T*B*Q = V**T *( B1 B2 )*Q = ( x  0  )
                                       ( 0  B3 )     ( x  x  )
            or if ( .</para>
            </summary>
            <param name="upper">
            <code>
            UPPER is LOGICAL
            = .TRUE.: the input matrices A and B are upper triangular.
            = .FALSE.: the input matrices A and B are lower triangular.
            </code>
            </param>
            <param name="a1">
            <code>
            A1 is REAL
            </code>
            </param>
            <param name="a2">
            <code>
            A2 is REAL
            </code>
            </param>
            <param name="a3">
            <code>
            A3 is REAL
            On entry, A1, A2 and A3 are elements of the input 2-by-2
            upper (lower) triangular matrix A.
            </code>
            </param>
            <param name="b1">
            <code>
            B1 is REAL
            </code>
            </param>
            <param name="b2">
            <code>
            B2 is REAL
            </code>
            </param>
            <param name="b3">
            <code>
            B3 is REAL
            On entry, B1, B2 and B3 are elements of the input 2-by-2
            upper (lower) triangular matrix B.
            </code>
            </param>
            <param name="csu">
            <code>
            CSU is REAL
            </code>
            </param>
            <param name="snu">
            <code>
            SNU is REAL
            The desired orthogonal matrix U.
            </code>
            </param>
            <param name="csv">
            <code>
            CSV is REAL
            </code>
            </param>
            <param name="snv">
            <code>
            SNV is REAL
            The desired orthogonal matrix V.
            </code>
            </param>
            <param name="csq">
            <code>
            CSQ is REAL
            </code>
            </param>
            <param name="snq">
            <code>
            SNQ is REAL
            The desired orthogonal matrix Q.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            NOT.UPPER ) then
                      U**T *A*Q = U**T *( A1 0  )*Q = ( x  x  )
                                        ( A2 A3 )     ( 0  x  )
            and
                      V**T*B*Q = V**T*( B1 0  )*Q = ( x  x  )
                                      ( B2 B3 )     ( 0  x  )
            The rows of the transformed A and B are parallel, where
              U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )
                  ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )
            Z**T denotes the transpose of Z.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slapll(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single@)">
            <summary>
            <para>
            Two column vectors X and Y, let
                                 A = ( X Y ).</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The length of the vectors X and Y.
            </code>
            </param>
            <param name="x">
            <code>
            X is REAL array,
                           dimension (1+(N-1)*INCX)
            On entry, X contains the N-vector X.
            On exit, X is overwritten.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive elements of X. INCX > 0.
            </code>
            </param>
            <param name="y">
            <code>
            Y is REAL array,
                           dimension (1+(N-1)*INCY)
            On entry, Y contains the N-vector Y.
            On exit, Y is overwritten.
            </code>
            <code>
            INCY is INTEGER
            The increment between successive elements of Y. INCY > 0.
            </code>
            </param>
            <param name="ssmin">
            <code>
            SSMIN is REAL
            The smallest singular value of the N-by-2 matrix A = ( X Y ).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The subroutine first computes the QR factorization of A = Q*R,
            and then computes the SVD of the 2-by-2 upper triangular matrix R.
            The smaller singular value of R is returned in SSMIN, which is used
            as the measurement of the linear dependency of the vectors X and Y.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Stgsja(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single,System.Single,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@,System.Int32@)">
            <summary>
            <para>
            Computes the generalized singular value decomposition (GSVD)
            of two real upper triangular (or trapezoidal) matrices A and B.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  U must contain an orthogonal matrix U1 on entry, and
                    the product U1*U is returned;
            = 'I':  U is initialized to the unit matrix, and the
                    orthogonal matrix U is returned;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  V must contain an orthogonal matrix V1 on entry, and
                    the product V1*V is returned;
            = 'I':  V is initialized to the unit matrix, and the
                    orthogonal matrix V is returned;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Q must contain an orthogonal matrix Q1 on entry, and
                    the product Q1*Q is returned;
            = 'I':  Q is initialized to the unit matrix, and the
                    orthogonal matrix Q is returned;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            K and L specify the subblocks in the input matrices A and B:
            A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,N-L+1:N)
            of A and B, whose GSVD is going to be computed by STGSJA.
            See Further Details.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
            matrix R or part of R.  See Purpose for details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
            a part of R.  See Purpose for details.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="tola">
            <code>
            TOLA is REAL
            </code>
            </param>
            <param name="tolb">
            <code>
            TOLB is REAL
            TOLA and TOLB are the convergence criteria for the Jacobi-
            Kogbetliantz iteration procedure. Generally, they are the
            same as used in the preprocessing step, say
                TOLA = max(M,N)*norm(A)*MACHEPS,
                TOLB = max(P,N)*norm(B)*MACHEPS.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is REAL array, dimension (N)
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is REAL array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L >= 0,
              ALPHA(K+1:K+L) = diag(C),
              BETA(K+1:K+L)  = diag(S),
            or if M-K-L &amp;lt; 0,
              ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
              BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
            Furthermore, if K+L &amp;lt; N,
              ALPHA(K+L+1:N) = 0 and
              BETA(K+L+1:N)  = 0.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension (LDU,M)
            On entry, if JOBU = 'U', U must contain a matrix U1 (usually
            the orthogonal matrix returned by SGGSVP).
            On exit,
            if JOBU = 'I', U contains the orthogonal matrix U;
            if JOBU = 'U', U contains the product U1*U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension (LDV,P)
            On entry, if JOBV = 'V', V must contain a matrix V1 (usually
            the orthogonal matrix returned by SGGSVP).
            On exit,
            if JOBV = 'I', V contains the orthogonal matrix V;
            if JOBV = 'V', V contains the product V1*V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ,N)
            On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
            the orthogonal matrix returned by SGGSVP).
            On exit,
            if JOBQ = 'I', Q contains the orthogonal matrix Q;
            if JOBQ = 'Q', Q contains the product Q1*Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (2*N)
            </code>
            </param>
            <param name="ncycle">
            <code>
            NCYCLE is INTEGER
            The number of cycles required for convergence.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1:  the procedure does not converge after MAXIT cycles.
            </code>
            <code>
            l Parameters
            =============
            T   INTEGER
                MAXIT specifies the total loops that the iterative procedure
                may take. If after MAXIT cycles, the routine fails to
                converge, we return INFO = 1.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On entry, it is assumed that matrices A and B have the following
            forms, which may be obtained by the preprocessing subroutine SGGSVP
            from a general M-by-N matrix A and P-by-N matrix B:
                         N-K-L  K    L
               A =    K ( 0    A12  A13 ) if M-K-L >= 0;
                      L ( 0     0   A23 )
                  M-K-L ( 0     0    0  )
                       N-K-L  K    L
               A =  K ( 0    A12  A13 ) if M-K-L &amp;lt; 0;
                  M-K ( 0     0   A23 )
                       N-K-L  K    L
               B =  L ( 0     0   B13 )
                  P-L ( 0     0    0  )
            where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
            upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
            otherwise A23 is (M-K)-by-L upper trapezoidal.
            On exit,
                   U**T *A*Q = D1*( 0 R ),    V**T *B*Q = D2*( 0 R ),
            where U, V and Q are orthogonal matrices.
            R is a nonsingular upper triangular matrix, and D1 and D2 are
            ``diagonal'' matrices, which are of the following structures:
            If M-K-L >= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                              K  L
                   D2 = L   ( 0  S )
                        P-L ( 0  0 )
                           N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 ) K
                        L (  0    0   R22 ) L
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &amp;lt; 0,
                           K M-K K+L-M
                D1 =   K ( I  0    0   )
                     M-K ( 0  C    0   )
                             K M-K K+L-M
                D2 =   M-K ( 0  S    0   )
                     K+L-M ( 0  0    I   )
                       P-L ( 0  0    0   )
                           N-K-L  K   M-K  K+L-M
            ( 0 R ) =    K ( 0    R11  R12  R13  )
                      M-K ( 0     0   R22  R23  )
                    K+L-M ( 0     0    0   R33  )
            where
            C = diag( ALPHA(K+1), ... , ALPHA(M) ),
            S = diag( BETA(K+1),  ... , BETA(M) ),
            C**2 + S**2 = I.
            R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
                (  0  R22 R23 )
            in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The computation of the orthogonal transformation matrices U, V or Q
            is optional.  These matrices may either be formed explicitly, or they
            may be postmultiplied into input matrices U1, V1, or Q1.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            STGSJA essentially uses a variant of Kogbetliantz algorithm to reduce
            min(L,M-K)-by-L triangular (or trapezoidal) matrix A23 and L-by-L
            matrix B13 to the form:
                     U1**T *A13*Q1 = C1*R1; V1**T *B13*Q1 = S1*R1,
            where U1, V1 and Q1 are orthogonal matrix, and Z**T is the transpose
            of Z.  C1 and S1 are diagonal matrices satisfying
                          C1**2 + S1**2 = I,
            and R1 is an L-by-L nonsingular upper triangular matrix.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.TriangularMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            trapezoidal or triangular matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in SLANTR as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower trapezoidal.
            = 'U':  Upper trapezoidal
            = 'L':  Lower trapezoidal
            Note that A is triangular instead of trapezoidal if M = N.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A has unit diagonal.
            = 'N':  Non-unit diagonal
            = 'U':  Unit diagonal
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0, and if
            UPLO = 'U', M &amp;lt;= N.  When M = 0, SLANTR is set to zero.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0, and if
            UPLO = 'L', N &amp;lt;= M.  When N = 0, SLANTR is set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The trapezoidal matrix A (A is triangular if M = N).
            If UPLO = 'U', the leading m by n upper trapezoidal part of
            the array A contains the upper trapezoidal matrix, and the
            strictly lower triangular part of A is not referenced.
            If UPLO = 'L', the leading m by n lower trapezoidal part of
            the array A contains the lower trapezoidal matrix, and the
            strictly upper triangular part of A is not referenced.  Note
            that when DIAG = 'U', the diagonal elements of A are not
            referenced and are assumed to be one.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(M,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK)),
            where LWORK >= M when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            SLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slauu2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the product U * U**T or L**T * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the triangular factor U or L.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U**T;
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L**T * L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.
            This is the unblocked form of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slauum(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the product U * U**T or L**T * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the triangular factor U or L.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U**T;
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L**T * L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.
            This is the blocked form of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slasyf(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes a partial factorization of a real symmetric matrix A
            using the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The maximum number of columns of the matrix A that should be
            factored.  NB should be at least 2 to allow for 2-by-2 pivot
            blocks.
            </code>
            </param>
            <param name="kb">
            <code>
            KB is INTEGER
            The number of columns of A that were actually factored.
            KB is either NB-1 or NB, or N if N &amp;lt;= NB.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, A contains details of the partial factorization.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If UPLO = 'U', only the last KB elements of IPIV are set;
            if UPLO = 'L', only the first KB elements are set.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="w">
            <code>
            W is REAL array, dimension (LDW,NB)
            </code>
            <code>
            LDW is INTEGER
            The leading dimension of the array W.  LDW >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
                 has been completed, but the block diagonal matrix D is
                 exactly singular.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The partial
            factorization has the form:
            A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
                  ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
            A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
                  ( L21  I ) (  0  A22 ) (  0       I    )
            where the order of D is at most NB. The actual order is returned in
            the argument KB, and is either NB or NB-1, or N if N &amp;lt;= NB.
            SLASYF is an auxiliary routine called by SSYTRF. It uses blocked code
            (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
            A22 (if UPLO = 'L').
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.SymmetricMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real symmetric matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in SLANSY as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is to be referenced.
            = 'U':  Upper triangular part of A is referenced
            = 'L':  Lower triangular part of A is referenced
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, SLANSY is
            set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The symmetric matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(N,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
            WORK is not referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            SLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaed2(System.Int32@,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Single@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Merges the two sets of eigenvalues together into a single
            sorted set.</para>
            </summary>
            <param name="k">
            <code>
            K is INTEGER
            The number of non-deflated eigenvalues, and the order of the
            related secular equation. 0 &amp;lt;= K &amp;lt;=N.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="n1">
            <code>
            N1 is INTEGER
            The location of the last eigenvalue in the leading sub-matrix.
            min(1,N) &amp;lt;= N1 &amp;lt;= N/2.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, D contains the eigenvalues of the two submatrices to
            be combined.
            On exit, D contains the trailing (N-K) updated eigenvalues
            (those which were deflated) sorted into increasing order.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ, N)
            On entry, Q contains the eigenvectors of two submatrices in
            the two square blocks with corners at (1,1), (N1,N1)
            and (N1+1, N1+1), (N,N).
            On exit, Q contains the trailing (N-K) updated eigenvectors
            (those which were deflated) in its last N-K columns.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            The permutation which separately sorts the two sub-problems
            in D into ascending order.  Note that elements in the second
            half of this permutation must first have N1 added to their
            values. Destroyed on exit.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            On entry, the off-diagonal element associated with the rank-1
            cut which originally split the two submatrices which are now
            being recombined.
            On exit, RHO has been modified to the value required by
            SLAED3.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (N)
            On entry, Z contains the updating vector (the last
            row of the first sub-eigenvector matrix and the first row of
            the second sub-eigenvector matrix).
            On exit, the contents of Z have been destroyed by the updating
            process.
            </code>
            </param>
            <param name="dlamda">
            <code>
            DLAMDA is REAL array, dimension (N)
            A copy of the first K eigenvalues which will be used by
            SLAED3 to form the secular equation.
            </code>
            </param>
            <param name="w">
            <code>
            W is REAL array, dimension (N)
            The first k values of the final deflation-altered z-vector
            which will be passed to SLAED3.
            </code>
            </param>
            <param name="q2">
            <code>
            Q2 is REAL array, dimension (N1**2+(N-N1)**2)
            A copy of the first K eigenvectors which will be used by
            SLAED3 in a matrix multiply (SGEMM) to solve for the new
            eigenvectors.
            </code>
            </param>
            <param name="indx">
            <code>
            INDX is INTEGER array, dimension (N)
            The permutation used to sort the contents of DLAMDA into
            ascending order.
            </code>
            </param>
            <param name="indxc">
            <code>
            INDXC is INTEGER array, dimension (N)
            The permutation used to arrange the columns of the deflated
            Q matrix into three groups:  the first group contains non-zero
            elements only at and above N1, the second contains
            non-zero elements only below N1, and the third is dense.
            </code>
            </param>
            <param name="indxp">
            <code>
            INDXP is INTEGER array, dimension (N)
            The permutation used to place deflated values of D at the end
            of the array.  INDXP(1:K) points to the nondeflated D-values
            and INDXP(K+1:N) points to the deflated eigenvalues.
            </code>
            </param>
            <param name="coltyp">
            <code>
            COLTYP is INTEGER array, dimension (N)
            During execution, a label which will indicate which of the
            following types a column in the Q2 matrix is:
            1 : non-zero in the upper half only;
            2 : dense;
            3 : non-zero in the lower half only;
            4 : deflated.
            On exit, COLTYP(i) is the number of columns of type i,
            for i=1 to 4 only.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny entry in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaed5(System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Single,System.Single@)">
            <summary>
            <para>
            Subroutine computes the I-th eigenvalue of a symmetric rank-one
            modification of a 2-by-2 diagonal matrix
                       diag( D )  +  RHO * Z * transpose(Z) .</para>
            </summary>
            <param name="i">
            <code>
            I is INTEGER
            The index of the eigenvalue to be computed.  I = 1 or I = 2.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (2)
            The original eigenvalues.  We assume D(1) &amp;lt; D(2).
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (2)
            The components of the updating vector.
            </code>
            </param>
            <param name="delta">
            <code>
            DELTA is REAL array, dimension (2)
            The vector DELTA contains the information necessary
            to construct the eigenvectors.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            The scalar in the symmetric updating formula.
            </code>
            </param>
            <param name="dlam">
            <code>
            DLAM is REAL
            The computed lambda_I, the I-th updated eigenvalue.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The diagonal elements in the array D are assumed to satisfy
                       D(i) &amp;lt; D(j)  for  i &amp;lt; j .
            We also assume RHO > 0 and that the Euclidean norm of the vector
            Z is one.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ren-Cang Li, Computer Science Division, University of California
                at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaed4(System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Single,System.Single@,System.Int32@)">
            <summary>
            <para>
            Subroutine computes the I-th updated eigenvalue of a symmetric
            rank-one modification to a diagonal matrix whose elements are
            given in the array d, and that
                       D(i) &amp;lt; D(j)  for  i &amp;lt; j
            and that RHO > 0.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The length of all arrays.
            </code>
            </param>
            <param name="i">
            <code>
            I is INTEGER
            The index of the eigenvalue to be computed.  1 &amp;lt;= I &amp;lt;= N.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            The original eigenvalues.  It is assumed that they are in
            order, D(I) &amp;lt; D(J)  for I &amp;lt; J.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (N)
            The components of the updating vector.
            </code>
            </param>
            <param name="delta">
            <code>
            DELTA is REAL array, dimension (N)
            If N .GT. 2, DELTA contains (D(j) - lambda_I) in its  j-th
            component.  If N = 1, then DELTA(1) = 1. If N = 2, see SLAED5
            for detail. The vector DELTA contains the information necessary
            to construct the eigenvectors by SLAED3 and SLAED9.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            The scalar in the symmetric updating formula.
            </code>
            </param>
            <param name="dlam">
            <code>
            DLAM is REAL
            The computed lambda_I, the I-th updated eigenvalue.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            > 0:  if INFO = 1, the updating process failed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is arranged by the calling routine, and is
            no loss in generality.  The rank-one modified system is thus
                       diag( D )  +  RHO * Z * Z_transpose.
            where we assume the Euclidean norm of Z is 1.
            The method consists of approximating the rational functions in the
            secular equation by simpler interpolating rational functions.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ren-Cang Li, Computer Science Division, University of California
                at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaed3(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Finds the roots of the secular equation, as defined by the
            values in D, W, and RHO, between 1 and K.</para>
            </summary>
            <param name="k">
            <code>
            K is INTEGER
            The number of terms in the rational function to be solved by
            SLAED4.  K >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of rows and columns in the Q matrix.
            N >= K (deflation may result in N>K).
            </code>
            </param>
            <param name="n1">
            <code>
            N1 is INTEGER
            The location of the last eigenvalue in the leading submatrix.
            min(1,N) &amp;lt;= N1 &amp;lt;= N/2.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            D(I) contains the updated eigenvalues for
            1 &amp;lt;= I &amp;lt;= K.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ,N)
            Initially the first K columns are used as workspace.
            On output the columns 1 to K contain
            the updated eigenvectors.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            The value of the parameter in the rank one update equation.
            RHO >= 0 required.
            </code>
            </param>
            <param name="dlamda">
            <code>
            DLAMDA is REAL array, dimension (K)
            The first K elements of this array contain the old roots
            of the deflated updating problem.  These are the poles
            of the secular equation. May be changed on output by
            having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
            Cray-2, or Cray C-90, as described above.
            </code>
            </param>
            <param name="q2">
            <code>
            Q2 is REAL array, dimension (LDQ2, N)
            The first K columns of this matrix contain the non-deflated
            eigenvectors for the split problem.
            </code>
            </param>
            <param name="indx">
            <code>
            INDX is INTEGER array, dimension (N)
            The permutation used to arrange the columns of the deflated
            Q matrix into three groups (see SLAED2).
            The rows of the eigenvectors found by SLAED4 must be likewise
            permuted before the matrix multiply can take place.
            </code>
            </param>
            <param name="ctot">
            <code>
            CTOT is INTEGER array, dimension (4)
            A count of the total number of the various types of columns
            in Q, as described in INDX.  The fourth column type is any
            column which has been deflated.
            </code>
            </param>
            <param name="w">
            <code>
            W is REAL array, dimension (K)
            The first K elements of this array contain the components
            of the deflation-adjusted updating vector. Destroyed on
            output.
            </code>
            </param>
            <param name="s">
            <code>
            S is REAL array, dimension (N1 + 1)*K
            Will contain the eigenvectors of the repaired matrix which
            will be multiplied by the previously accumulated eigenvectors
            to update the system.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It makes the
            appropriate calls to SLAED4 and then updates the eigenvectors by
            multiplying the matrix of eigenvectors of the pair of eigensystems
            being combined by the matrix of eigenvectors of the K-by-K system
            which is solved here.
            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaed1(System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Single,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the eigenvalues of the rank-1-perturbed matrix.
            On exit, the eigenvalues of the repaired matrix.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ,N)
            On entry, the eigenvectors of the rank-1-perturbed matrix.
            On exit, the eigenvectors of the repaired tridiagonal matrix.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            On entry, the permutation which separately sorts the two
            subproblems in D into ascending order.
            On exit, the permutation which will reintegrate the
            subproblems back into sorted order,
            i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            The subdiagonal entry used to create the rank-1 modification.
            </code>
            </param>
            <param name="cutpnt">
            <code>
            CUTPNT is INTEGER
            The location of the last eigenvalue in the leading sub-matrix.
            min(1,N) &amp;lt;= CUTPNT &amp;lt;= N/2.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (4*N + N**2)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (4*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This
            routine is used only for the eigenproblem which requires all
            eigenvalues and eigenvectors of a tridiagonal matrix.  SLAED7 handles
            the case in which eigenvalues only or eigenvalues and eigenvectors
            of a full symmetric matrix (which was reduced to tridiagonal form)
            are desired.
              T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
               where Z = Q**T*u, u is a vector of length N with ones in the
               CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:
                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine SLAED2.
                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine SLAED4 (as called by SLAED3).
                  This routine also calculates the eigenvectors of the current
                  problem.
                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaed8(System.Int32,System.Int32@,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Single@,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@,Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Merges the two sets of eigenvalues together into a single
            sorted set.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            = 0:  Compute eigenvalues only.
            = 1:  Compute eigenvectors of original dense symmetric matrix
                  also.  On entry, Q contains the orthogonal matrix used
                  to reduce the original matrix to tridiagonal form.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of non-deflated eigenvalues, and the order of the
            related secular equation.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the orthogonal matrix used to reduce
            the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the eigenvalues of the two submatrices to be
            combined.  On exit, the trailing (N-K) updated eigenvalues
            (those which were deflated) sorted into increasing order.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ,N)
            If ICOMPQ = 0, Q is not referenced.  Otherwise,
            on entry, Q contains the eigenvectors of the partially solved
            system which has been previously updated in matrix
            multiplies with other partially solved eigensystems.
            On exit, Q contains the trailing (N-K) updated eigenvectors
            (those which were deflated) in its last N-K columns.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            The permutation which separately sorts the two sub-problems
            in D into ascending order.  Note that elements in the second
            half of this permutation must first have CUTPNT added to
            their values in order to be accurate.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            On entry, the off-diagonal element associated with the rank-1
            cut which originally split the two submatrices which are now
            being recombined.
            On exit, RHO has been modified to the value required by
            SLAED3.
            </code>
            </param>
            <param name="cutpnt">
            <code>
            CUTPNT is INTEGER
            The location of the last eigenvalue in the leading
            sub-matrix.  min(1,N) &amp;lt;= CUTPNT &amp;lt;= N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (N)
            On entry, Z contains the updating vector (the last row of
            the first sub-eigenvector matrix and the first row of the
            second sub-eigenvector matrix).
            On exit, the contents of Z are destroyed by the updating
            process.
            </code>
            </param>
            <param name="dlamda">
            <code>
            DLAMDA is REAL array, dimension (N)
            A copy of the first K eigenvalues which will be used by
            SLAED3 to form the secular equation.
            </code>
            </param>
            <param name="q2">
            <code>
            Q2 is REAL array, dimension (LDQ2,N)
            If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
            a copy of the first K eigenvectors which will be used by
            SLAED7 in a matrix multiply (SGEMM) to update the new
            eigenvectors.
            </code>
            <code>
            LDQ2 is INTEGER
            The leading dimension of the array Q2.  LDQ2 >= max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is REAL array, dimension (N)
            The first k values of the final deflation-altered z-vector and
            will be passed to SLAED3.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension (N)
            The permutations (from deflation and sorting) to be applied
            to each eigenblock.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER
            The number of Givens rotations which took place in this
            subproblem.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension (2, N)
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is REAL array, dimension (2, N)
            Each number indicates the S value to be used in the
            corresponding Givens rotation.
            </code>
            </param>
            <param name="indxp">
            <code>
            INDXP is INTEGER array, dimension (N)
            The permutation used to place deflated values of D at the end
            of the array.  INDXP(1:K) points to the nondeflated D-values
            and INDXP(K+1:N) points to the deflated eigenvalues.
            </code>
            </param>
            <param name="indx">
            <code>
            INDX is INTEGER array, dimension (N)
            The permutation used to sort the contents of D into ascending
            order.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny element in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaed9(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Finds the roots of the secular equation, as defined by the
            values in D, Z, and RHO, between KSTART and KSTOP.</para>
            </summary>
            <param name="k">
            <code>
            K is INTEGER
            The number of terms in the rational function to be solved by
            SLAED4.  K >= 0.
            </code>
            </param>
            <param name="kstart">
            <code>
            KSTART is INTEGER
            </code>
            </param>
            <param name="kstop">
            <code>
            KSTOP is INTEGER
            The updated eigenvalues Lambda(I), KSTART &amp;lt;= I &amp;lt;= KSTOP
            are to be computed.  1 &amp;lt;= KSTART &amp;lt;= KSTOP &amp;lt;= K.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of rows and columns in the Q matrix.
            N >= K (delation may result in N > K).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            D(I) contains the updated eigenvalues
            for KSTART &amp;lt;= I &amp;lt;= KSTOP.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ,N)
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max( 1, N ).
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            The value of the parameter in the rank one update equation.
            RHO >= 0 required.
            </code>
            </param>
            <param name="dlamda">
            <code>
            DLAMDA is REAL array, dimension (K)
            The first K elements of this array contain the old roots
            of the deflated updating problem.  These are the poles
            of the secular equation.
            </code>
            </param>
            <param name="w">
            <code>
            W is REAL array, dimension (K)
            The first K elements of this array contain the components
            of the deflation-adjusted updating vector.
            </code>
            </param>
            <param name="s">
            <code>
            S is REAL array, dimension (LDS, K)
            Will contain the eigenvectors of the repaired matrix which
            will be stored for subsequent Z vector calculation and
            multiplied by the previously accumulated eigenvectors
            to update the system.
            </code>
            <code>
            LDS is INTEGER
            The leading dimension of S.  LDS >= max( 1, K ).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It makes the
            appropriate calls to SLAED4 and then stores the new matrix of
            eigenvectors for use in calculating the next level of Z vectors.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaeda(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the Z vector corresponding to the merge step in the
            CURLVLth step of the merge process with TLVLS steps for the CURPBMth
            problem.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="tlvls">
            <code>
            TLVLS is INTEGER
            The total number of merging levels in the overall divide and
            conquer tree.
            </code>
            </param>
            <param name="curlvl">
            <code>
            CURLVL is INTEGER
            The current level in the overall merge routine,
            0 &amp;lt;= curlvl &amp;lt;= tlvls.
            </code>
            </param>
            <param name="curpbm">
            <code>
            CURPBM is INTEGER
            The current problem in the current level in the overall
            merge routine (counting from upper left to lower right).
            </code>
            </param>
            <param name="prmptr">
            <code>
            PRMPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in PERM a
            level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
            indicates the size of the permutation and incidentally the
            size of the full, non-deflated problem.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension (N lg N)
            Contains the permutations (from deflation and sorting) to be
            applied to each eigenblock.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in GIVCOL a
            level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
            indicates the number of Givens rotations.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension (2, N lg N)
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is REAL array, dimension (2, N lg N)
            Each number indicates the S value to be used in the
            corresponding Givens rotation.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (N**2)
            Contains the square eigenblocks from previous levels, the
            starting positions for blocks are given by QPTR.
            </code>
            </param>
            <param name="qptr">
            <code>
            QPTR is INTEGER array, dimension (N+2)
            Contains a list of pointers which indicate where in Q an
            eigenblock is stored.  SQRT( QPTR(i+1) - QPTR(i) ) indicates
            the size of the block.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (N)
            On output this vector contains the updating vector (the last
            row of the first sub-eigenvector matrix and the first row of
            the second sub-eigenvector matrix).
            </code>
            </param>
            <param name="ztemp">
            <code>
            ZTEMP is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaed7(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Single,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            = 0:  Compute eigenvalues only.
            = 1:  Compute eigenvectors of original dense symmetric matrix
                  also.  On entry, Q contains the orthogonal matrix used
                  to reduce the original matrix to tridiagonal form.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the orthogonal matrix used to reduce
            the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
            </code>
            </param>
            <param name="tlvls">
            <code>
            TLVLS is INTEGER
            The total number of merging levels in the overall divide and
            conquer tree.
            </code>
            </param>
            <param name="curlvl">
            <code>
            CURLVL is INTEGER
            The current level in the overall merge routine,
            0 &amp;lt;= CURLVL &amp;lt;= TLVLS.
            </code>
            </param>
            <param name="curpbm">
            <code>
            CURPBM is INTEGER
            The current problem in the current level in the overall
            merge routine (counting from upper left to lower right).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the eigenvalues of the rank-1-perturbed matrix.
            On exit, the eigenvalues of the repaired matrix.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ, N)
            On entry, the eigenvectors of the rank-1-perturbed matrix.
            On exit, the eigenvectors of the repaired tridiagonal matrix.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            The permutation which will reintegrate the subproblem just
            solved back into sorted order, i.e., D( INDXQ( I = 1, N ) )
            will be in ascending order.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is REAL
            The subdiagonal element used to create the rank-1
            modification.
            </code>
            </param>
            <param name="cutpnt">
            <code>
            CUTPNT is INTEGER
            Contains the location of the last eigenvalue in the leading
            sub-matrix.  min(1,N) &amp;lt;= CUTPNT &amp;lt;= N.
            </code>
            </param>
            <param name="qstore">
            <code>
            QSTORE is REAL array, dimension (N**2+1)
            Stores eigenvectors of submatrices encountered during
            divide and conquer, packed together. QPTR points to
            beginning of the submatrices.
            </code>
            </param>
            <param name="qptr">
            <code>
            QPTR is INTEGER array, dimension (N+2)
            List of indices pointing to beginning of submatrices stored
            in QSTORE. The submatrices are numbered starting at the
            bottom left of the divide and conquer tree, from left to
            right and bottom to top.
            </code>
            </param>
            <param name="prmptr">
            <code>
            PRMPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in PERM a
            level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
            indicates the size of the permutation and also the size of
            the full, non-deflated problem.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension (N lg N)
            Contains the permutations (from deflation and sorting) to be
            applied to each eigenblock.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in GIVCOL a
            level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
            indicates the number of Givens rotations.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension (2, N lg N)
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is REAL array, dimension (2, N lg N)
            Each number indicates the S value to be used in the
            corresponding Givens rotation.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (3*N+2*QSIZ*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (4*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This
            routine is used only for the eigenproblem which requires all
            eigenvalues and optionally eigenvectors of a dense symmetric matrix
            that has been reduced to tridiagonal form.  SLAED1 handles
            the case in which all eigenvalues and eigenvectors of a symmetric
            tridiagonal matrix are desired.
              T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
               where Z = Q**Tu, u is a vector of length N with ones in the
               CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:
                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine SLAED8.
                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine SLAED4 (as called by SLAED9).
                  This routine also calculates the eigenvectors of the current
                  problem.
                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slae2(System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            <para>
            Computes the eigenvalues of a 2-by-2 symmetric matrix
               [  A   B  ]
               [  B   C  ].</para>
            </summary>
            <param name="a">
            <code>
            A is REAL
            The (1,1) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL
            The (1,2) and (2,1) elements of the 2-by-2 matrix.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL
            The (2,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="rt1">
            <code>
            RT1 is REAL
            The eigenvalue of larger absolute value.
            </code>
            </param>
            <param name="rt2">
            <code>
            RT2 is REAL
            The eigenvalue of smaller absolute value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On return, RT1 is the eigenvalue of larger absolute value, and RT2
            is the eigenvalue of smaller absolute value.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            RT1 is accurate to a few ulps barring over/underflow.
            RT2 may be inaccurate if there is massive cancellation in the
            determinant A*C-B*B; higher precision or correctly rounded or
            correctly truncated arithmetic would be needed to compute RT2
            accurately in all cases.
            Overflow is possible only if RT1 is within a factor of 5 of overflow.
            Underflow is harmless if the input data is 0 or exceeds
               underflow_threshold / macheps.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaev2(System.Single,System.Single,System.Single,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            <para>
            Computes the eigendecomposition of a 2-by-2 symmetric matrix
               [  A   B  ]
               [  B   C  ].</para>
            </summary>
            <param name="a">
            <code>
            A is REAL
            The (1,1) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL
            The (1,2) element and the conjugate of the (2,1) element of
            the 2-by-2 matrix.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL
            The (2,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="rt1">
            <code>
            RT1 is REAL
            The eigenvalue of larger absolute value.
            </code>
            </param>
            <param name="rt2">
            <code>
            RT2 is REAL
            The eigenvalue of smaller absolute value.
            </code>
            </param>
            <param name="cs1">
            <code>
            CS1 is REAL
            </code>
            </param>
            <param name="sn1">
            <code>
            SN1 is REAL
            The vector (CS1, SN1) is a unit right eigenvector for RT1.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
            eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
            eigenvector for RT1, giving the decomposition
               [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
               [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            RT1 is accurate to a few ulps barring over/underflow.
            RT2 may be inaccurate if there is massive cancellation in the
            determinant A*C-B*B; higher precision or correctly rounded or
            correctly truncated arithmetic would be needed to compute RT2
            accurately in all cases.
            CS1 and SN1 are accurate to a few ulps barring over/underflow.
            Overflow is possible only if RT1 is within a factor of 5 of overflow.
            Underflow is harmless if the input data is 0 or exceeds
               underflow_threshold / macheps.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slaed0(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and corresponding eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            = 0:  Compute eigenvalues only.
            = 1:  Compute eigenvectors of original dense symmetric matrix
                  also.  On entry, Q contains the orthogonal matrix used
                  to reduce the original matrix to tridiagonal form.
            = 2:  Compute eigenvalues and eigenvectors of tridiagonal
                  matrix.
            </code>
            </param>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the orthogonal matrix used to reduce
            the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the main diagonal of the tridiagonal matrix.
            On exit, its eigenvalues.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ, N)
            On entry, Q must contain an N-by-N orthogonal matrix.
            If ICOMPQ = 0    Q is not referenced.
            If ICOMPQ = 1    On entry, Q is a subset of the columns of the
                             orthogonal matrix used to reduce the full
                             matrix to tridiagonal form corresponding to
                             the subset of the full matrix which is being
                             decomposed at this time.
            If ICOMPQ = 2    On entry, Q will be the identity matrix.
                             On exit, Q contains the eigenvectors of the
                             tridiagonal matrix.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  If eigenvectors are
            desired, then  LDQ >= max(1,N).  In any case,  LDQ >= 1.
            </code>
            </param>
            <param name="qstore">
            <code>
            QSTORE is REAL array, dimension (LDQS, N)
            Referenced only when ICOMPQ = 1.  Used to store parts of
            the eigenvector matrix when the updating matrix multiplies
            take place.
            </code>
            </param>
            <param name="ldqs">
            <code>
            LDQS is INTEGER
            The leading dimension of the array QSTORE.  If ICOMPQ = 1,
            then  LDQS >= max(1,N).  In any case,  LDQS >= 1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array,
            If ICOMPQ = 0 or 1, the dimension of WORK must be at least
                        1 + 3*N + 2*N*lg N + 3*N**2
                        ( lg( N ) = smallest integer k
                                    such that 2^k >= N )
            If ICOMPQ = 2, the dimension of WORK must be at least
                        4*N + N**2.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array,
            If ICOMPQ = 0 or 1, the dimension of IWORK must be at least
                           6 + 6*N + 5*N*lg N.
                           ( lg( N ) = smallest integer k
                                       such that 2^k >= N )
            If ICOMPQ = 2, the dimension of IWORK must be at least
                           3 + 5*N.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slatrd(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Reduces NB rows and columns of a real symmetric matrix A to
            symmetric tridiagonal form by an orthogonal similarity
            transformation Q**T * A * Q, and returns the matrices V and W which are
            needed to apply the transformation to the unreduced part of A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U': Upper triangular
            = 'L': Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of rows and columns to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit:
            if UPLO = 'U', the last NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements above the diagonal
              with the array TAU, represent the orthogonal matrix Q as a
              product of elementary reflectors;
            if UPLO = 'L', the first NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements below the diagonal
              with the array TAU, represent the  orthogonal matrix Q as a
              product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= (1,N).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
            elements of the last NB columns of the reduced matrix;
            if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
            the first NB columns of the reduced matrix.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (N-1)
            The scalar factors of the elementary reflectors, stored in
            TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
            See Further Details.
            </code>
            </param>
            <param name="w">
            <code>
            W is REAL array, dimension (LDW,NB)
            The n-by-nb matrix W required to update the unreduced part
            of A.
            </code>
            <code>
            LDW is INTEGER
            The leading dimension of the array W. LDW >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U', SLATRD reduces the last NB rows and columns of a
            matrix, of which the upper triangle is supplied;
            if UPLO = 'L', SLATRD reduces the first NB rows and columns of a
            matrix, of which the lower triangle is supplied.
            This is an auxiliary routine called by SSYTRD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n) H(n-1) . . . H(n-nb+1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
            and tau in TAU(i-1).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(nb).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
            and tau in TAU(i).
            The elements of the vectors v together form the n-by-nb matrix V
            which is needed, with W, to apply the transformation to the unreduced
            part of the matrix, using a symmetric rank-2k update of the form:
            A := A - V*W**T - W*V**T.
            The contents of A on exit are illustrated by the following examples
            with n = 5 and nb = 2:
            if UPLO = 'U':                       if UPLO = 'L':
              (  a   a   a   v4  v5 )              (  d                  )
              (      a   a   v4  v5 )              (  1   d              )
              (          a   1   v5 )              (  v1  1   a          )
              (              d   1  )              (  v1  v2  a   a      )
              (                  d  )              (  v1  v2  a   a   a  )
            where d denotes a diagonal element of the reduced matrix, a denotes
            an element of the original matrix that is unchanged, and vi denotes
            an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.TriangularBandMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n triangular band matrix A,  with ( k + 1 ) diagonals.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in SLANTB as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, SLANTB is
            set to zero.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of super-diagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals of the matrix A if UPLO = 'L'.
            K >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first k+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+k).
            Note that when DIAG = 'U', the elements of the array AB
            corresponding to the diagonal elements of the matrix A are
            not referenced, but are assumed to be one.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= K+1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            SLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Scsum1(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Takes the sum of the absolute values of a complex
            vector and returns a single precision result.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of elements in the vector CX.
            </code>
            </param>
            <param name="cx">
            <code>
            CX is COMPLEX array, dimension (N)
            The vector whose elements will be summed.
            </code>
            <code>
            INCX is INTEGER
            The spacing between successive values of CX.  INCX > 0.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Based on SCASUM from the Level 1 BLAS.
            The change is to use the 'genuine' absolute value.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Nick Higham for use with CLACON.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Slapy3(System.Single,System.Single,System.Single)">
            <summary>
            <para>
            Returns sqrt(x**2+y**2+z**2), taking care not to cause
            unnecessary overflow.</para>
            </summary>
            <param name="x">
            <code>
            X is REAL
            </code>
            </param>
            <param name="y">
            <code>
            Y is REAL
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL
            X, Y and Z specify the values x, y and z.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sbdsqr(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the singular values and, optionally, the right and/or
            left singular vectors from the singular value decomposition (SVD) of
            a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
            zero-shift QR algorithm.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  B is upper bidiagonal;
            = 'L':  B is lower bidiagonal.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix B.  N >= 0.
            </code>
            </param>
            <param name="ncvt">
            <code>
            NCVT is INTEGER
            The number of columns of the matrix VT. NCVT >= 0.
            </code>
            </param>
            <param name="nru">
            <code>
            NRU is INTEGER
            The number of rows of the matrix U. NRU >= 0.
            </code>
            </param>
            <param name="ncc">
            <code>
            NCC is INTEGER
            The number of columns of the matrix C. NCC >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the n diagonal elements of the bidiagonal matrix B.
            On exit, if INFO=0, the singular values of B in decreasing
            order.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            On entry, the N-1 offdiagonal elements of the bidiagonal
            matrix B.
            On exit, if INFO = 0, E is destroyed; if INFO > 0, D and E
            will contain the diagonal and superdiagonal elements of a
            bidiagonal matrix orthogonally equivalent to the one given
            as input.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is REAL array, dimension (LDVT, NCVT)
            On entry, an N-by-NCVT matrix VT.
            On exit, VT is overwritten by P**T * VT.
            Not referenced if NCVT = 0.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.
            LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension (LDU, N)
            On entry, an NRU-by-N matrix U.
            On exit, U is overwritten by U * Q.
            Not referenced if NRU = 0.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= max(1,NRU).
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC, NCC)
            On entry, an N-by-NCC matrix C.
            On exit, C is overwritten by Q**T * C.
            Not referenced if NCC = 0.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C.
            LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (4*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  If INFO = -i, the i-th argument had an illegal value
            > 0:
               if NCVT = NRU = NCC = 0,
                  = 1, a split was marked by a positive value in E
                  = 2, current block of Z not diagonalized after 30*N
                       iterations (in inner while loop)
                  = 3, termination criterion of outer while loop not met
                       (program created more than N unreduced blocks)
               else NCVT = NRU = NCC = 0,
                     the algorithm did not converge; D and E contain the
                     elements of a bidiagonal matrix which is orthogonally
                     similar to the input matrix B;  if INFO = i, i
                     elements of E have not converged to zero.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The SVD of B has the form
               B = Q * S * P**T
            where S is the diagonal matrix of singular values, Q is an orthogonal
            matrix of left singular vectors, and P is an orthogonal matrix of
            right singular vectors.  If left singular vectors are requested, this
            subroutine actually returns U*Q instead of Q, and, if right singular
            vectors are requested, this subroutine returns P**T*VT instead of
            P**T, for given real input matrices U and VT.  When U and VT are the
            orthogonal matrices that reduce a general matrix A to bidiagonal
            form:  A = U*B*VT, as computed by SGEBRD, then
               A = (U*Q) * S * (P**T*VT)
            is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
            for a given real input matrix C.
            See "Computing  Small Singular Values of Bidiagonal Matrices With
            Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
            LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
            no. 5, pp. 873-912, Sept 1990) and
            "Accurate singular values and differential qd algorithms," by
            B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
            Department, University of California at Berkeley, July 1992
            for a detailed description of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sbdsdc(Extreme.Mathematics.MatrixTriangle,System.Char,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a real
            N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
            using a divide and conquer method, where S is a diagonal matrix
            with non-negative diagonal elements (the singular values of B), and
            U and VT are orthogonal matrices of left and right singular vectors,
            respectively.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  B is upper bidiagonal.
            = 'L':  B is lower bidiagonal.
            </code>
            </param>
            <param name="compq">
            <code>
            COMPQ is CHARACTER*1
            Specifies whether singular vectors are to be computed
            as follows:
            = 'N':  Compute singular values only;
            = 'P':  Compute singular values and compute singular
                    vectors in compact form;
            = 'I':  Compute singular values and singular vectors.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix B.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the n diagonal elements of the bidiagonal matrix B.
            On exit, if INFO=0, the singular values of B.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            On entry, the elements of E contain the offdiagonal
            elements of the bidiagonal matrix whose SVD is desired.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension (LDU,N)
            If  COMPQ = 'I', then:
               On exit, if INFO = 0, U contains the left singular vectors
               of the bidiagonal matrix.
            For other values of COMPQ, U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= 1.
            If singular vectors are desired, then LDU >= max( 1, N ).
            </code>
            </param>
            <param name="vt">
            <code>
            VT is REAL array, dimension (LDVT,N)
            If  COMPQ = 'I', then:
               On exit, if INFO = 0, VT**T contains the right singular
               vectors of the bidiagonal matrix.
            For other values of COMPQ, VT is not referenced.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= 1.
            If singular vectors are desired, then LDVT >= max( 1, N ).
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ)
            If  COMPQ = 'P', then:
               On exit, if INFO = 0, Q and IQ contain the left
               and right singular vectors in a compact form,
               requiring O(N log N) space instead of 2*N**2.
               In particular, Q contains all the REAL data in
               LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
               words of memory, where SMLSIZ is returned by ILAENV and
               is equal to the maximum size of the subproblems at the
               bottom of the computation tree (usually about 25).
            For other values of COMPQ, Q is not referenced.
            </code>
            </param>
            <param name="iq">
            <code>
            IQ is INTEGER array, dimension (LDIQ)
            If  COMPQ = 'P', then:
               On exit, if INFO = 0, Q and IQ contain the left
               and right singular vectors in a compact form,
               requiring O(N log N) space instead of 2*N**2.
               In particular, IQ contains all INTEGER data in
               LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
               words of memory, where SMLSIZ is returned by ILAENV and
               is equal to the maximum size of the subproblems at the
               bottom of the computation tree (usually about 25).
            For other values of COMPQ, IQ is not referenced.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            If COMPQ = 'N' then LWORK >= (4 * N).
            If COMPQ = 'P' then LWORK >= (6 * N).
            If COMPQ = 'I' then LWORK >= (3 * N**2 + 4 * N).
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (8*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute a singular value.
                  The update process of divide and conquer failed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            SBDSDC can be used to compute all singular values,
            and optionally, singular vectors or singular vectors in compact form.
            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See SLASD3 for details.
            The code currently calls SLASDQ if singular values only are desired.
            However, it can be slightly modified to compute singular values
            using the divide and conquer method.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.LUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{System.Single},System.Single,System.Single@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a general
            real matrix A, in either the 1-norm or the infinity-norm, using
            the LU factorization computed by SGETRF.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by SGETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is REAL
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (4*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgetf2(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a general m-by-n matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the m by n matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, U(k,k) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = P * L * U
            where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m > n), and U is upper
            triangular (upper trapezoidal if m &amp;lt; n).
            This is the right-looking Level 2 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.LUDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = P * L * U
            where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m > n), and U is upper
            triangular (upper trapezoidal if m &amp;lt; n).
            This is the right-looking Level 3 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.LUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B  or  A**T * X = B
            with a general N-by-N matrix A using the LU factorization computed
            by SGETRF.</para>
            </summary>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A**T* X = B  (Transpose)
            = 'C':  A**T* X = B  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by SGETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices from SGETRF; for 1&amp;lt;=i&amp;lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.LUInvert(System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a matrix using the LU factorization
            computed by SGETRF.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by SGETRF.
            On exit, if INFO = 0, the inverse of the original matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices from SGETRF; for 1&amp;lt;=i&amp;lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimal performance LWORK >= N*NB, where NB is
            the optimal blocksize returned by ILAENV.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This method inverts U and then computes inv(A) by solving the system
            inv(A)*L = inv(U) for inv(A).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgebak(System.Char,Extreme.Mathematics.MatrixOperationSide,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Single},System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Forms the right or left eigenvectors of a real general matrix
            by backward transformation on the computed eigenvectors of the
            balanced matrix output by SGEBAL.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
            Specifies the type of backward transformation required:
            = 'N', do nothing, return immediately;
            = 'P', do backward transformation for permutation only;
            = 'S', do backward transformation for scaling only;
            = 'B', do backward transformations for both permutation and
                   scaling.
            JOB must be the same as the argument JOB supplied to SGEBAL.
            </code>
            </param>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'R':  V contains right eigenvectors;
            = 'L':  V contains left eigenvectors.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of rows of the matrix V.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            The integers ILO and IHI determined by SGEBAL.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL array, dimension (N)
            Details of the permutation and scaling factors, as returned
            by SGEBAL.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of columns of the matrix V.  M >= 0.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension (LDV,M)
            On entry, the matrix of right or left eigenvectors to be
            transformed, as returned by SHSEIN or STREVC.
            On exit, V is overwritten by the transformed eigenvectors.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgebal(System.Char,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@,System.Int32@,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Balances a general real matrix A.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
            Specifies the operations to be performed on A:
            = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
                    for i = 1,...,N;
            = 'P':  permute only;
            = 'S':  scale only;
            = 'B':  both permute and scale.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the input matrix A.
            On exit,  A is overwritten by the balanced matrix.
            If JOB = 'N', A is not referenced.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI are set to integers such that on exit
            A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
            If JOB = 'N' or 'S', ILO = 1 and IHI = N.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is REAL array, dimension (N)
            Details of the permutations and scaling factors applied to
            A.  If P(j) is the index of the row and column interchanged
            with row and column j and D(j) is the scaling factor
            applied to row and column j, then
            SCALE(j) = P(j)    for j = 1,...,ILO-1
                     = D(j)    for j = ILO,...,IHI
                     = P(j)    for j = IHI+1,...,N.
            The order in which the interchanges are made is N to IHI+1,
            then 1 to ILO-1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This involves, first,
            permuting A by a similarity transformation to isolate eigenvalues
            in the first 1 to ILO-1 and last IHI+1 to N elements on the
            diagonal; and second, applying a diagonal similarity transformation
            to rows and columns ILO to IHI to make the rows and columns as
            close in norm as possible.  Both steps are optional.
            Balancing may reduce the 1-norm of the matrix, and improve the
            accuracy of the computed eigenvalues and/or eigenvectors.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The permutations consist of row and column interchanges which put
            the matrix in the form
                       ( T1   X   Y  )
               P A P = (  0   B   Z  )
                       (  0   0   T2 )
            where T1 and T2 are upper triangular matrices whose eigenvalues lie
            along the diagonal.  The column indices ILO and IHI mark the starting
            and ending columns of the submatrix B. Balancing consists of applying
            a diagonal similarity transformation inv(D) * B * D to make the
            1-norms of each row of B and its corresponding column nearly equal.
            The output matrix is
               ( T1     X*D          Y    )
               (  0  inv(D)*B*D  inv(D)*Z ).
               (  0      0           T2   )
            Information about the permutations P and the diagonal matrix D is
            returned in the vector SCALE.
            This subroutine is based on the EISPACK routine BALANC.
            Modified by Tzu-Yi Chen, Computer Science Division, University of
              California at Berkeley, USA
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgehd2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Reduces a real general matrix A to upper Hessenberg form H by
            an orthogonal similarity transformation:  Q**T * A * Q = H .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to SGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= max(1,N).
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the n by n general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the orthogonal matrix Q as a product of elementary
            reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of (ihi-ilo) elementary
            reflectors
               Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
            exit in A(i+2:ihi,i), and tau in TAU(i).
            The contents of A are illustrated by the following example, with
            n = 7, ilo = 2 and ihi = 6:
            on entry,                        on exit,
            ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
            (                         a )    (                          a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgehrd(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a real general matrix A to upper Hessenberg form H by
            an orthogonal similarity transformation:  Q**T * A * Q = H .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to SGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the N-by-N general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the orthogonal matrix Q as a product of elementary
            reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
            zero.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of (ihi-ilo) elementary
            reflectors
               Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
            exit in A(i+2:ihi,i), and tau in TAU(i).
            The contents of A are illustrated by the following example, with
            n = 7, ilo = 2 and ihi = 6:
            on entry,                        on exit,
            ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
            (                         a )    (                          a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            This file is a slight modification of LAPACK-3.0's DGEHRD
            subroutine incorporating improvements proposed by Quintana-Orti and
            Van de Geijn (2006). (See DLAHR2.)
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgeev(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes for an N-by-N real nonsymmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
            </summary>
            <param name="jobvl">
            <code>
            JOBVL is CHARACTER*1
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.
            </code>
            </param>
            <param name="jobvr">
            <code>
            JOBVR is CHARACTER*1
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A. N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="wr">
            <code>
            WR is REAL array, dimension (N)
            </code>
            </param>
            <param name="wi">
            <code>
            WI is REAL array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.
            </code>
            </param>
            <param name="vl">
            <code>
            VL is REAL array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).
            </code>
            <code>
            LDVL is INTEGER
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.
            </code>
            </param>
            <param name="vr">
            <code>
            VR is REAL array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).
            </code>
            <code>
            LDVR is INTEGER
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,3*N), and
            if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
            performance, LWORK must generally be larger.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**H * A = lambda(j) * u(j)**H
            where u(j)**H denotes the conjugate-transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgeqr2(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization of a real m by n matrix A:
            A = Q * R.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(m,n) by n upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization of a real M-by-N matrix A:
            A = Q * R.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization with column pivoting of a
            matrix A:  A*P = Q*R  using Level 3 BLAS.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper trapezoidal matrix R; the elements below
            the diagonal, together with the array TAU, represent the
            orthogonal matrix Q as a product of min(M,N) elementary
            reflectors.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(J).ne.0, the J-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(J)=0,
            the J-th column of A is a free column.
            On exit, if JPVT(J)=K, then the J-th column of A*P was the
            the K-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= 3*N+1.
            For optimal performance LWORK >= 2*N+( N+1 )*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit.
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real/complex vector
            with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
            A(i+1:m,i), and tau in TAU(i).
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgebd2(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Reduces a real general m by n matrix A to upper or lower
            bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the orthogonal matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors;
            if m &amp;lt; n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the orthogonal matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m &amp;lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is REAL array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is REAL array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix P. See Further Details.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (max(M,N))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit.
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, B is upper bidiagonal; if m &amp;lt; n, B is lower bidiagonal.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
            If m >= n,
               Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
            where tauq and taup are real scalars, and v and u are real vectors;
            v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
            u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
            tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n,
               Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
            where tauq and taup are real scalars, and v and u are real vectors;
            v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
            u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
            tauq is stored in TAUQ(i) and taup in TAUP(i).
            The contents of A on exit are illustrated by the following examples:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
              (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
              (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
              (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
              (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
              (  v1  v2  v3  v4  v5 )
            where d and e denote diagonal and off-diagonal elements of B, vi
            denotes an element of the vector defining H(i), and ui an element of
            the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgebrd(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a general real M-by-N matrix A to upper or lower
            bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the orthogonal matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors;
            if m &amp;lt; n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the orthogonal matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m &amp;lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is REAL array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is REAL array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix P. See Further Details.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of the array WORK.  LWORK >= max(1,M,N).
            For optimum performance LWORK >= (M+N)*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, B is upper bidiagonal; if m &amp;lt; n, B is lower bidiagonal.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
            If m >= n,
               Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
            where tauq and taup are real scalars, and v and u are real vectors;
            v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
            u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
            tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n,
               Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
            where tauq and taup are real scalars, and v and u are real vectors;
            v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
            u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
            tauq is stored in TAUQ(i) and taup in TAUP(i).
            The contents of A on exit are illustrated by the following examples:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
              (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
              (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
              (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
              (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
              (  v1  v2  v3  v4  v5 )
            where d and e denote diagonal and off-diagonal elements of B, vi
            denotes an element of the vector defining H(i), and ui an element of
            the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgelq2(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes an LQ factorization of a real m by n matrix A:
            A = L * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m by min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &amp;lt;= n); the elements above the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k) . . . H(2) H(1), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgelqf(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes an LQ factorization of a real M-by-N matrix A:
            A = L * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &amp;lt;= n); the elements above the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,M).
            For optimum performance LWORK >= M*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k) . . . H(2) H(1), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgesdd(System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.</para>
            </summary>
            <param name="jobz">
            <code>
            JOBZ is CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V**T are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V**T are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    on the array A and all rows of V**T are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V**T are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V**T are computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the input matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the input matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M >= N;
                            A is overwritten with the first M rows
                            of V**T (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="s">
            <code>
            S is REAL array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) >= S(i+1).
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &amp;lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &amp;lt; N, U contains the M-by-M
            orthogonal matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &amp;lt; N, LDU >= M.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is REAL array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            N-by-N orthogonal matrix V**T;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V**T (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &amp;lt; N, or JOBZ = 'N', VT is not referenced.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            if JOBZ = 'S', LDVT >= min(M,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= 1.
            If JOBZ = 'N',
              LWORK >= 3*min(M,N) + max(max(M,N),6*min(M,N)).
            If JOBZ = 'O',
              LWORK >= 3*min(M,N) +
                       max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
            If JOBZ = 'S' or 'A'
              LWORK >= 3*min(M,N) +
                       max(max(M,N),4*min(M,N)*min(M,N)+3*min(M,N)+max(M,N)).
            For good performance, LWORK should generally be larger.
            If LWORK = -1 but other input arguments are legal, WORK(1)
            returns the optimal LWORK.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (8*min(M,N))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  SBDSDC did not converge, updating process failed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                 A = U * SIGMA * transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgeqpf(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Routine is deprecated and has been replaced by routine SGEQP3.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper triangular matrix R; the elements
            below the diagonal, together with the array TAU,
            represent the orthogonal matrix Q as a product of
            min(m,n) elementary reflectors.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(i) = 0,
            the i-th column of A is a free column.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (3*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            SGEQPF computes a QR factorization with column pivoting of a
            real M-by-N matrix A: A*P = Q*R.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(n)
            Each H(i) has the form
               H = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).
            The matrix P is represented in jpvt as follows: If
               jpvt(j) = i
            then the jth column of P is the ith canonical unit vector.
            Partial column norm updating strategy modified by
              Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
              University of Zagreb, Croatia.
            -- April 2011                                                      --
            For more details see LAPACK Working Note 176.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgerq2(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes an RQ factorization of a real m by n matrix A:
            A = R * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, if m &amp;lt;= n, the upper triangle of the subarray
            A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
            if m >= n, the elements on and above the (m-n)-th subdiagonal
            contain the m by n upper trapezoidal matrix R; the remaining
            elements, with the array TAU, represent the orthogonal matrix
            Q as a product of elementary reflectors (see Further
            Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
            A(m-k+i,1:n-k+i-1), and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandLUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Single,System.Single@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a real
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by SGBTRF.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by SGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is REAL
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (3*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sgbtf2(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a real m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&amp;lt;=i&amp;lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U, because of fill-in resulting from the row
            interchanges.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a real m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&amp;lt;=i&amp;lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandLUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B  or  A**T * X = B
            with a general band matrix A using the LU factorization computed
            by SGBTRF.</para>
            </summary>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations.
            = 'N':  A * X = B  (No transpose)
            = 'T':  A**T* X = B  (Transpose)
            = 'C':  A**T* X = B  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by SGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sggsvp(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single,System.Single,System.Int32@,System.Int32@,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes orthogonal matrices U, V and Q such that
                               N-K-L  K    L
             U**T*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;
                            L ( 0     0   A23 )
                        M-K-L ( 0     0    0  )
                             N-K-L  K    L
                    =     K ( 0    A12  A13 )  if M-K-L &amp;lt; 0;
                        M-K ( 0     0   A23 )
                             N-K-L  K    L
             V**T*B*Q =   L ( 0     0   B13 )
                        P-L ( 0     0    0  )
            where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
            upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
            otherwise A23 is (M-K)-by-L upper trapezoidal.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  Orthogonal matrix U is computed;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  Orthogonal matrix V is computed;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Orthogonal matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular (or trapezoidal) matrix
            described in the Purpose section.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains the triangular matrix described in
            the Purpose section.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="tola">
            <code>
            TOLA is REAL
            </code>
            </param>
            <param name="tolb">
            <code>
            TOLB is REAL
            TOLA and TOLB are the thresholds to determine the effective
            numerical rank of matrix B and a subblock of A. Generally,
            they are set to
               TOLA = MAX(M,N)*norm(A)*MACHEPS,
               TOLB = MAX(P,N)*norm(B)*MACHEPS.
            The size of TOLA and TOLB may affect the size of backward
            errors of the decomposition.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose section.
            K + L = effective numerical rank of (A**T,B**T)**T.
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension (LDU,M)
            If JOBU = 'U', U contains the orthogonal matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension (LDV,P)
            If JOBV = 'V', V contains the orthogonal matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the orthogonal matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (N)
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (max(3*N,M,P))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            K+L = the effective
            numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T.
            This decomposition is the preprocessing step for computing the
            Generalized Singular Value Decomposition (GSVD), see subroutine
            SGGSVD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
             The subroutine uses LAPACK subroutine SGEQPF for the QR factorization
             with column pivoting to detect the effective numerical rank of the
             a matrix. It may be replaced by a better rank determination strategy.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sggsvd(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the generalized singular value decomposition (GSVD)
            of an M-by-N real matrix A and P-by-N real matrix B:
                  U**T*A*Q = D1*( 0 R ),    V**T*B*Q = D2*( 0 R )
            where U, V and Q are orthogonal matrices.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  Orthogonal matrix U is computed;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  Orthogonal matrix V is computed;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Orthogonal matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose.
            K + L = effective numerical rank of (A**T,B**T)**T.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular matrix R, or part of R.
            See Purpose for details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains the triangular matrix R if M-K-L &amp;lt; 0.
            See Purpose for details.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is REAL array, dimension (N)
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is REAL array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L >= 0,
              ALPHA(K+1:K+L) = C,
              BETA(K+1:K+L)  = S,
            or if M-K-L &amp;lt; 0,
              ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
              BETA(K+1:M) =S, BETA(M+1:K+L) =1
            and
              ALPHA(K+L+1:N) = 0
              BETA(K+L+1:N)  = 0
            </code>
            </param>
            <param name="u">
            <code>
            U is REAL array, dimension (LDU,M)
            If JOBU = 'U', U contains the M-by-M orthogonal matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is REAL array, dimension (LDV,P)
            If JOBV = 'V', V contains the P-by-P orthogonal matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the N-by-N orthogonal matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array,
                        dimension (max(3*N,M,P)+N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            On exit, IWORK stores the sorting information. More
            precisely, the following loop will sort ALPHA
               for I = K+1, min(M,K+L)
                   swap ALPHA(I) and ALPHA(IWORK(I))
               endfor
            such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, the Jacobi-type procedure failed to
                  converge.  For further details, see subroutine STGSJA.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,
            then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
            D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
            following structures, respectively:
            If M-K-L >= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                              K  L
                   D2 =   L ( 0  S )
                        P-L ( 0  0 )
                            N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 )
                        L (  0    0   R22 )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &amp;lt; 0,
                              K M-K K+L-M
                   D1 =   K ( I  0    0   )
                        M-K ( 0  C    0   )
                                K M-K K+L-M
                   D2 =   M-K ( 0  S    0  )
                        K+L-M ( 0  0    I  )
                          P-L ( 0  0    0  )
                               N-K-L  K   M-K  K+L-M
              ( 0 R ) =     K ( 0    R11  R12  R13  )
                          M-K ( 0     0   R22  R23  )
                        K+L-M ( 0     0    0   R33  )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(M) ),
              S = diag( BETA(K+1),  ... , BETA(M) ),
              C**2 + S**2 = I.
              (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
              ( 0  R22 R23 )
              in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The routine computes C, S, R, and optionally the orthogonal
            transformation matrices U, V and Q.
            In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
            A and B implicitly gives the SVD of A*inv(B):
                                 A*inv(B) = U*(D1*inv(D2))*V**T.
            If ( A**T,B**T)**T  has orthonormal columns, then the GSVD of A and B is
            also equal to the CS decomposition of A and B. Furthermore, the GSVD
            can be used to derive the solution of the eigenvalue problem:
                                 A**T*A x = lambda* B**T*B x.
            In some literature, the GSVD of A and B is presented in the form
                             U**T*A*X = ( 0 D1 ),   V**T*B*X = ( 0 D2 )
            where U and V are orthogonal and X is nonsingular, D1 and D2 are
            ``diagonal''.  The former GSVD form can be converted to the latter
            form by taking the nonsingular matrix X as
                                 X = Q*( I   0    )
                                       ( 0 inv(R) ).
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sorm2r(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Overwrites the general real m by n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**T* C  if SIDE = 'L' and TRANS = 'T', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**T if SIDE = 'R' and TRANS = 'T',
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left
            = 'R': apply Q or Q**T from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q**T (Transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEQRF.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by SGEQRF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.QROrthogonalMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGEQRF in the first k columns of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEQRF.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by SGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sormhr(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI must have the same values as in the previous call
            of SGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            If SIDE = 'L', then 1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= M, if M > 0, and
            ILO = 1 and IHI = 0, if M = 0;
            if SIDE = 'R', then 1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0, and
            ILO = 1 and IHI = 0, if N = 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by SGEHRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEHRD.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q is defined as the product of
            IHI-ILO elementary reflectors, as returned by SGEHRD:
            Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sorg2r(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Generates an m by n real matrix Q with orthonormal columns,
            which is defined as the first n columns of a product of k elementary
            reflectors of order m
                  Q  =  H(1) H(2) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. M >= N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by SGEQRF in the first k columns of its array
            argument A.
            On exit, the m-by-n matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEQRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by SGEQRF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sorgqr(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates an M-by-N real matrix Q with orthonormal columns,
            which is defined as the first N columns of a product of K elementary
            reflectors of order M
                  Q  =  H(1) H(2) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. M >= N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by SGEQRF in the first k columns of its array
            argument A.
            On exit, the M-by-N matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEQRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by SGEQRF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sorghr(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates a real orthogonal matrix Q which is defined as the
            product of IHI-ILO elementary reflectors of order N, as returned by
            SGEHRD:
            Q = H(ilo) H(ilo+1) .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix Q. N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI must have the same values as in the previous call
            of SGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by SGEHRD.
            On exit, the N-by-N orthogonal matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (N-1)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEHRD.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= IHI-ILO.
            For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(ihi-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sorgl2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Generates an m by n real matrix Q with orthonormal rows,
            which is defined as the first m rows of a product of k elementary
            reflectors of order n
                  Q  =  H(k) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. N >= M.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by SGELQF in the first k rows of its array argument A.
            On exit, the m-by-n matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGELQF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by SGELQF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sorglq(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates an M-by-N real matrix Q with orthonormal rows,
            which is defined as the first M rows of a product of K elementary
            reflectors of order N
                  Q  =  H(k) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. N >= M.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by SGELQF in the first k rows of its array argument A.
            On exit, the M-by-N matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGELQF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,M).
            For optimum performance LWORK >= M*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by SGELQF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sorgbr(System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates one of the real orthogonal matrices Q or P**T
            determined by SGEBRD when reducing a real matrix A to bidiagonal
            form: A = Q * B * P**T.</para>
            </summary>
            <param name="vect">
            <code>
            VECT is CHARACTER*1
            Specifies whether the matrix Q or the matrix P**T is
            required, as defined in the transformation applied by SGEBRD:
            = 'Q':  generate Q;
            = 'P':  generate P**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q or P**T to be returned.
            M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q or P**T to be returned.
            N >= 0.
            If VECT = 'Q', M >= N >= min(M,K);
            if VECT = 'P', N >= M >= min(N,K).
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            If VECT = 'Q', the number of columns in the original M-by-K
            matrix reduced by SGEBRD.
            If VECT = 'P', the number of rows in the original K-by-N
            matrix reduced by SGEBRD.
            K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by SGEBRD.
            On exit, the M-by-N matrix Q or P**T.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension
                                  (min(M,K)) if VECT = 'Q'
                                  (min(N,K)) if VECT = 'P'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i), which determines Q or P**T, as
            returned by SGEBRD in its array argument TAUQ or TAUP.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,min(M,N)).
            For optimum performance LWORK >= min(M,N)*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q and P**T are defined as products of
            elementary reflectors H(i) or G(i) respectively.
            If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
            is of order M:
            if m >= k, Q = H(1) H(2) . . . H(k) and SORGBR returns the first n
            columns of Q, where m >= n >= k;
            if m &amp;lt; k, Q = H(1) H(2) . . . H(m-1) and SORGBR returns Q as an
            M-by-M matrix.
            If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
            is of order N:
            if k &amp;lt; n, P**T = G(k) . . . G(2) G(1) and SORGBR returns the first m
            rows of P**T, where n >= m >= k;
            if k >= n, P**T = G(n-1) . . . G(2) G(1) and SORGBR returns P**T as
            an N-by-N matrix.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  April 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sorml2(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Overwrites the general real m by n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**T* C  if SIDE = 'L' and TRANS = 'T', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**T if SIDE = 'R' and TRANS = 'T',
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left
            = 'R': apply Q or Q**T from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q**T (Transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGELQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by SGELQF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sormlq(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGELQF in the first k rows of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGELQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by SGELQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sormbr(System.Char,Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            VECT = 'Q', SORMBR overwrites the general real M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            If VECT = 'P', SORMBR overwrites the general real M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      P * C          C * P
            TRANS = 'T':      P**T * C       C * P**T
            Here Q and P**T are the orthogonal matrices determined by SGEBRD when
            reducing a real matrix A to bidiagonal form: A = Q * B * P**T.</para>
            </summary>
            <param name="vect">
            <code>
            VECT is CHARACTER*1
            = 'Q': apply Q or Q**T;
            = 'P': apply P or P**T.
            </code>
            </param>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q, Q**T, P or P**T from the Left;
            = 'R': apply Q, Q**T, P or P**T from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q  or P;
            = 'T':  Transpose, apply Q**T or P**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            If VECT = 'Q', the number of columns in the original
            matrix reduced by SGEBRD.
            If VECT = 'P', the number of rows in the original
            matrix reduced by SGEBRD.
            K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension
                                  (LDA,min(nq,K)) if VECT = 'Q'
                                  (LDA,nq)        if VECT = 'P'
            The vectors which define the elementary reflectors H(i) and
            G(i), whose products determine the matrices Q and P, as
            returned by SGEBRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If VECT = 'Q', LDA >= max(1,nq);
            if VECT = 'P', LDA >= max(1,min(nq,K)).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (min(nq,K))
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i) which determines Q or P, as returned
            by SGEBRD in the array argument TAUQ or TAUP.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
            or P*C or P**T*C or C*P or C*P**T.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q and
            P**T are defined as products of elementary reflectors H(i) and G(i)
            respectively.
            Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
            order of the orthogonal matrix Q or P**T that is applied.
            If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq >= k, Q = H(1) H(2) . . . H(k);
            if nq &amp;lt; k, Q = H(1) H(2) . . . H(nq-1).
            If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
            if k &amp;lt; nq, P = G(1) G(2) . . . G(k);
            if k >= nq, P = G(1) G(2) . . . G(nq-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sormr2(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Overwrites the general real m by n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**T* C  if SIDE = 'L' and TRANS = 'T', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**T if SIDE = 'R' and TRANS = 'T',
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left
            = 'R': apply Q or Q**T from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q' (Transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGERQF in the last k rows of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGERQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by SGERQF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sorm2l(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Overwrites the general real m by n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**T * C  if SIDE = 'L' and TRANS = 'T', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**T if SIDE = 'R' and TRANS = 'T',
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left
            = 'R': apply Q or Q**T from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q**T (Transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGEQLF in the last k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEQLF.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by SGEQLF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sormql(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGEQLF in the last k columns of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEQLF.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sormtr(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U': Upper triangle of A contains elementary reflectors
                   from SSYTRD;
            = 'L': Lower triangle of A contains elementary reflectors
                   from SSYTRD.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by SSYTRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SSYTRD.
            </code>
            </param>
            <param name="c">
            <code>
            C is REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q is defined as the product of
            nq-1 elementary reflectors, as returned by SSYTRD:
            if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
            if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandCholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Single,System.Single@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite band matrix using the
            Cholesky factorization A = U**T*U or A = L*L**T computed by SPBTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**T*U or A = L*L**T of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is REAL
            The 1-norm (or infinity-norm) of the symmetric band matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (3*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Spbtf2(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite band matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of super-diagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the symmetric band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U**T*U or A = L*L**T of the band
            matrix A, in the same storage format as A.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**T * U ,  if UPLO = 'U', or
               A = L  * L**T,  if UPLO = 'L',
            where U is an upper triangular matrix, U**T is the transpose of U, and
            L is lower triangular.
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandCholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite band matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the symmetric band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U**T*U or A = L*L**T of the band
            matrix A, in the same storage format as A.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**T * U,  if UPLO = 'U', or
               A = L  * L**T,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
             Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.BandCholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite band matrix A using the Cholesky factorization
            A = U**T*U or A = L*L**T computed by SPBTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**T*U or A = L*L**T of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Spotf2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n by n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**T *U  or A = L*L**T.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**T * U ,  if UPLO = 'U', or
               A = L  * L**T,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.CholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},System.Single,System.Single@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite matrix using the
            Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**T*U or A = L*L**T, as computed by SPOTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is REAL
            The 1-norm (or infinity-norm) of the symmetric matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (3*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.CholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**T*U or A = L*L**T.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**T * U,  if UPLO = 'U', or
               A = L  * L**T,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            This is the block version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.CholeskyInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real symmetric positive definite
            matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
            computed by SPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U**T*U or A = L*L**T, as computed by
            SPOTRF.
            On exit, the upper or lower triangle of the (symmetric)
            inverse of A, overwriting the input factor U or L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.CholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite matrix A using the Cholesky factorization
            A = U**T*U or A = L*L**T computed by SPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**T*U or A = L*L**T, as computed by SPOTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ssytf2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a real symmetric matrix A using
            the Bunch-Kaufman diagonal pivoting method:
               A = U*D*U**T  or  A = L*D*L**T
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, U**T is the transpose of U, and D is symmetric and
            block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
                 has been completed, but the block diagonal matrix D is
                 exactly singular, and division by zero will occur if it
                 is used to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', then A = U*D*U**T, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L**T, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            <code>
            09-29-06 - patch from
              Bobby Cheng, MathWorks
              Replace l.204 and l.372
                   IF( MAX( ABSAKK, COLMAX ).EQ.ZERO ) THEN
              by
                   IF( (MAX( ABSAKK, COLMAX ).EQ.ZERO) .OR. SISNAN(ABSAKK) ) THEN
            01-01-96 - Based on modifications by
              J. Lewis, Boeing Computer Services Company
              A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
            1-96 - Based on modifications by J. Lewis, Boeing Computer Services
                   Company
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.SymmetricDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a real symmetric matrix A using
            the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of WORK.  LWORK >=1.  For best performance
            LWORK >= N*NB, where NB is the block size returned by ILAENV.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The form of the
            factorization is
               A = U*D*U**T  or  A = L*D*L**T
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is symmetric and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', then A = U*D*U**T, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L**T, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.SymmetricSolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a real
            symmetric matrix A using the factorization A = U*D*U**T or
            A = L*D*L**T computed by SSYTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**T;
            = 'L':  Lower triangular, form is A = L*D*L**T.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by SSYTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by SSYTRF.
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.SymmetricInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real symmetric indefinite matrix
            A using the factorization A = U*D*U**T or A = L*D*L**T computed by
            SSYTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**T;
            = 'L':  Lower triangular, form is A = L*D*L**T.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by SSYTRF.
            On exit, if INFO = 0, the (symmetric) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by SSYTRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.SymmetricEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Single,System.Single@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric matrix A using the factorization
            A = U*D*U**T or A = L*D*L**T computed by SSYTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**T;
            = 'L':  Lower triangular, form is A = L*D*L**T.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by SSYTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by SSYTRF.
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is REAL
            The 1-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (2*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ssytd2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Reduces a real symmetric matrix A to symmetric tridiagonal
            form T by an orthogonal similarity transformation: Q**T * A * Q = T.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the orthogonal
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the orthogonal matrix Q as a product
            of elementary reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n-1) . . . H(2) H(1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
            A(1:i-1,i+1), and tau in TAU(i).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(n-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
            and tau in TAU(i).
            The contents of A on exit are illustrated by the following examples
            with n = 5:
            if UPLO = 'U':                       if UPLO = 'L':
              (  d   e   v2  v3  v4 )              (  d                  )
              (      d   e   v3  v4 )              (  e   d              )
              (          d   e   v4 )              (  v1  e   d          )
              (              d   e  )              (  v1  v2  e   d      )
              (                  d  )              (  v1  v2  v3  e   d  )
            where d and e denote diagonal and off-diagonal elements of T, and vi
            denotes an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ssytrd(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a real symmetric matrix A to real symmetric
            tridiagonal form T by an orthogonal similarity transformation:
            Q**T * A * Q = T.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the orthogonal
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the orthogonal matrix Q as a product
            of elementary reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is REAL array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= 1.
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n-1) . . . H(2) H(1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
            A(1:i-1,i+1), and tau in TAU(i).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(n-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
            and tau in TAU(i).
            The contents of A on exit are illustrated by the following examples
            with n = 5:
            if UPLO = 'U':                       if UPLO = 'L':
              (  d   e   v2  v3  v4 )              (  d                  )
              (      d   e   v3  v4 )              (  e   d              )
              (          d   e   v4 )              (  v1  e   d          )
              (              d   e  )              (  v1  v2  e   d      )
              (                  d  )              (  v1  v2  v3  e   d  )
            where d and e denote diagonal and off-diagonal elements of T, and vi
            denotes an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ssyevd(System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            real symmetric matrix A.</para>
            </summary>
            <param name="jobz">
            <code>
            JOBZ is CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is REAL array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array,
                                           dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If N &amp;lt;= 1,               LWORK must be at least 1.
            If JOBZ = 'N' and N > 1, LWORK must be at least 2*N+1.
            If JOBZ = 'V' and N > 1, LWORK must be at least
                                                  1 + 6*N + 2*N**2.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK and IWORK
            arrays, returns these values as the first entries of the WORK
            and IWORK arrays, and no error message related to LWORK or
            LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </code>
            </param>
            <param name="liwork">
            <code>
            LIWORK is INTEGER
            The dimension of the array IWORK.
            If N &amp;lt;= 1,                LIWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
            If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK and
            IWORK arrays, returns these values as the first entries of
            the WORK and IWORK arrays, and no error message related to
            LWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the submatrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            Because of large use of BLAS of level 3, SSYEVD needs N**2 more
            workspace than SSYEVX.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee \n
             Modified description of INFO. Sven, 16 Feb 05. \n
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ssteqr(System.Char,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the implicit QL or QR method.</para>
            </summary>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'V':  Compute eigenvalues and eigenvectors of the original
                    symmetric matrix.  On entry, Z must contain the
                    orthogonal matrix used to reduce the original matrix
                    to tridiagonal form.
            = 'I':  Compute eigenvalues and eigenvectors of the
                    tridiagonal matrix.  Z is initialized to the identity
                    matrix.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (LDZ, N)
            On entry, if  COMPZ = 'V', then Z contains the orthogonal
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original symmetric matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If COMPZ = 'N', then Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z.  LDZ >= 1, and if
            eigenvectors are desired, then  LDZ >= max(1,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (max(1,2*N-2))
            If COMPZ = 'N', then WORK is not referenced.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm has failed to find all the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero; on exit, D
                  and E contain the elements of a symmetric tridiagonal
                  matrix which is orthogonally similar to the original
                  matrix.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The eigenvectors of a full or band symmetric matrix can also be found
            if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to
            tridiagonal form.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Ssterf(System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues of a symmetric tridiagonal matrix
            using the Pal-Walker-Kahan variant of the QL or QR algorithm.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the n diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm failed to find all of the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Sstedc(System.Char,System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.</para>
            </summary>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'I':  Compute eigenvectors of tridiagonal matrix also.
            = 'V':  Compute eigenvectors of original dense symmetric
                    matrix also.  On entry, Z contains the orthogonal
                    matrix used to reduce the original matrix to
                    tridiagonal form.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is REAL array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is REAL array, dimension (N-1)
            On entry, the subdiagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (LDZ,N)
            On entry, if COMPZ = 'V', then Z contains the orthogonal
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original symmetric matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If  COMPZ = 'N', then Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z.  LDZ >= 1.
            If eigenvectors are desired, then LDZ >= max(1,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If COMPZ = 'N' or N &amp;lt;= 1 then LWORK must be at least 1.
            If COMPZ = 'V' and N > 1 then LWORK must be at least
                           ( 1 + 3*N + 2*N*lg N + 4*N**2 ),
                           where lg( N ) = smallest integer k such
                           that 2**k >= N.
            If COMPZ = 'I' and N > 1 then LWORK must be at least
                           ( 1 + 4*N + N**2 ).
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LWORK need
            only be max(1,2*(N-1)).
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </code>
            </param>
            <param name="liwork">
            <code>
            LIWORK is INTEGER
            The dimension of the array IWORK.
            If COMPZ = 'N' or N &amp;lt;= 1 then LIWORK must be at least 1.
            If COMPZ = 'V' and N > 1 then LIWORK must be at least
                           ( 6 + 6*N + 5*N*lg N ).
            If COMPZ = 'I' and N > 1 then LIWORK must be at least
                           ( 3 + 5*N ).
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LIWORK
            need only be 1.
            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal size of the IWORK array,
            returns this value as the first entry of the IWORK array, and
            no error message related to LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The eigenvectors of a full or band real symmetric matrix can also be
            found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this
            matrix to tridiagonal form.
            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See SLAED3 for details.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Strti2(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real upper or lower triangular
            matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading n by n upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the Level 2 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.TriangularInvert(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real upper or lower triangular
            matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                 matrix is singular and its inverse can not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the Level 3 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Strexc(System.Char,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@,System.Int32@,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Reorders the real Schur factorization of a real matrix
            A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
            moved to row ILST.</para>
            </summary>
            <param name="compq">
            <code>
            COMPQ is CHARACTER*1
            = 'V':  update the matrix Q of Schur vectors;
            = 'N':  do not update Q.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix T. N >= 0.
            </code>
            </param>
            <param name="t">
            <code>
            T is REAL array, dimension (LDT,N)
            On entry, the upper quasi-triangular matrix T, in Schur
            Schur canonical form.
            On exit, the reordered upper quasi-triangular matrix, again
            in Schur canonical form.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
            </code>
            </param>
            <param name="q">
            <code>
            Q is REAL array, dimension (LDQ,N)
            On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
            On exit, if COMPQ = 'V', Q has been postmultiplied by the
            orthogonal transformation matrix Z which reorders T.
            If COMPQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="ifst">
            <code>
            IFST is INTEGER
            </code>
            </param>
            <param name="ilst">
            <code>
            ILST is INTEGER
            Specify the reordering of the diagonal blocks of T.
            The block with row index IFST is moved to row ILST, by a
            sequence of transpositions between adjacent blocks.
            On exit, if IFST pointed on entry to the second row of a
            2-by-2 block, it is changed to point to the first row; ILST
            always points to the first row of the block in its final
            position (which may differ from its input value by +1 or -1).
            1 &amp;lt;= IFST &amp;lt;= N; 1 &amp;lt;= ILST &amp;lt;= N.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            = 1:  two adjacent blocks were too close to swap (the problem
                  is very ill-conditioned); T may have been partially
                  reordered, and ILST points to the first row of the
                  current position of the block being moved.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The real Schur form T is reordered by an orthogonal similarity
            transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
            is updated by postmultiplying it with Z.
            T must be in Schur canonical form (as returned by SHSEQR), that is,
            block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
            2-by-2 diagonal block has its diagonal elements equal and its
            off-diagonal elements of opposite sign.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Strevc(Extreme.Mathematics.MatrixOperationSide,System.Char,Extreme.Collections.Array1D{System.Boolean},System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32,System.Int32@,Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes some or all of the right and/or left eigenvectors of
            a real upper quasi-triangular matrix T.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'R':  compute right eigenvectors only;
            = 'L':  compute left eigenvectors only;
            = 'B':  compute both right and left eigenvectors.
            </code>
            </param>
            <param name="howmny">
            <code>
            HOWMNY is CHARACTER*1
            = 'A':  compute all right and/or left eigenvectors;
            = 'B':  compute all right and/or left eigenvectors,
                    backtransformed by the matrices in VR and/or VL;
            = 'S':  compute selected right and/or left eigenvectors,
                    as indicated by the logical array SELECT.
            </code>
            </param>
            <param name="select">
            <code>
            SELECT is LOGICAL array, dimension (N)
            If HOWMNY = 'S', SELECT specifies the eigenvectors to be
            computed.
            If w(j) is a real eigenvalue, the corresponding real
            eigenvector is computed if SELECT(j) is .TRUE..
            If w(j) and w(j+1) are the real and imaginary parts of a
            complex eigenvalue, the corresponding complex eigenvector is
            computed if either SELECT(j) or SELECT(j+1) is .TRUE., and
            on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to
            .FALSE..
            Not referenced if HOWMNY = 'A' or 'B'.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix T. N >= 0.
            </code>
            </param>
            <param name="t">
            <code>
            T is REAL array, dimension (LDT,N)
            The upper quasi-triangular matrix T in Schur canonical form.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
            </code>
            </param>
            <param name="vl">
            <code>
            VL is REAL array, dimension (LDVL,MM)
            On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
            contain an N-by-N matrix Q (usually the orthogonal matrix Q
            of Schur vectors returned by SHSEQR).
            On exit, if SIDE = 'L' or 'B', VL contains:
            if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
            if HOWMNY = 'B', the matrix Q*Y;
            if HOWMNY = 'S', the left eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VL, in the same order as their
                             eigenvalues.
            A complex eigenvector corresponding to a complex eigenvalue
            is stored in two consecutive columns, the first holding the
            real part, and the second the imaginary part.
            Not referenced if SIDE = 'R'.
            </code>
            <code>
            LDVL is INTEGER
            The leading dimension of the array VL.  LDVL >= 1, and if
            SIDE = 'L' or 'B', LDVL >= N.
            </code>
            </param>
            <param name="vr">
            <code>
            VR is REAL array, dimension (LDVR,MM)
            On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
            contain an N-by-N matrix Q (usually the orthogonal matrix Q
            of Schur vectors returned by SHSEQR).
            On exit, if SIDE = 'R' or 'B', VR contains:
            if HOWMNY = 'A', the matrix X of right eigenvectors of T;
            if HOWMNY = 'B', the matrix Q*X;
            if HOWMNY = 'S', the right eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VR, in the same order as their
                             eigenvalues.
            A complex eigenvector corresponding to a complex eigenvalue
            is stored in two consecutive columns, the first holding the
            real part and the second the imaginary part.
            Not referenced if SIDE = 'L'.
            </code>
            <code>
            LDVR is INTEGER
            The leading dimension of the array VR.  LDVR >= 1, and if
            SIDE = 'R' or 'B', LDVR >= N.
            </code>
            </param>
            <param name="mm">
            <code>
            MM is INTEGER
            The number of columns in the arrays VL and/or VR. MM >= M.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of columns in the arrays VL and/or VR actually
            used to store the eigenvectors.
            If HOWMNY = 'A' or 'B', M is set to N.
            Each selected real eigenvector occupies one column and each
            selected complex eigenvector occupies two columns.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (3*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Matrices of this type are produced by the Schur factorization of
            a real general matrix:  A = Q*T*Q**T, as computed by SHSEQR.
            The right eigenvector x and the left eigenvector y of T corresponding
            to an eigenvalue w are defined by:
               T*x = w*x,     (y**T)*T = w*(y**T)
            where y**T denotes the transpose of y.
            The eigenvalues are not input to this routine, but are read directly
            from the diagonal blocks of T.
            This routine returns the matrices X and/or Y of right and left
            eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
            input matrix.  If Q is the orthogonal factor that reduces a matrix
            A to Schur form T, then Q*X and Q*Y are the matrices of right and
            left eigenvectors of A.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The algorithm used in this program is basically backward (forward)
            substitution, with scaling to make the the code robust against
            possible overflow.
            Each eigenvector is normalized so that the element of largest
            magnitude has magnitude 1; here the magnitude of a complex number
            (x,y) is taken to be |x| + |y|.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.TriangularEstimateCondition(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},System.Single@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a
            triangular matrix A, in either the 1-norm or the infinity-norm.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (3*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.TriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B  or  A**T * X = B,
            where A is a triangular matrix of order N, and B is an N-by-NRHS
            matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is REAL array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, the i-th diagonal element of A is zero,
                 indicating that the matrix is singular and the solutions
                 X have not been computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            A check is made to verify that A is nonsingular.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Stbcon(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Single@,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a
            triangular band matrix A, in either the 1-norm or the infinity-norm.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of the array. The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is REAL
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (3*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Stbtrs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B  or  A**T * X = B,
            where A is a triangular band matrix of order N, and B is an
            N-by NRHS matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is REAL array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="b">
            <code>
            B is REAL array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the i-th diagonal element of A is zero,
                  indicating that the matrix is singular and the
                  solutions X have not been computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            A check is made to verify that A is nonsingular.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Managed.SingleLapack.Shseqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**T, where T is an upper quasi-triangular matrix (the
               Schur form), and Z is the orthogonal matrix of Schur vectors.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
             = 'E':  compute eigenvalues only;
             = 'S':  compute eigenvalues and the Schur form T.
            </code>
            </param>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
             = 'N':  no Schur vectors are computed;
             = 'I':  Z is initialized to the unit matrix and the matrix Z
                     of Schur vectors of H is returned;
             = 'V':  Z must contain an orthogonal matrix Q on entry, and
                     the product Q*Z is returned.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
             set by a previous call to SGEBAL, and then passed to ZGEHRD
             when the matrix output by SGEBAL is reduced to Hessenberg
             form. Otherwise ILO and IHI should be set to 1 and N
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is REAL array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and JOB = 'S', then H contains the
             upper quasi-triangular matrix T from the Schur decomposition
             (the Schur form); 2-by-2 diagonal blocks (corresponding to
             complex conjugate pairs of eigenvalues) are returned in
             standard form, with H(i,i) = H(i+1,i+1) and
             H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and JOB = 'E', the
             contents of H are unspecified on exit.  (The output value of
             H when INFO.GT.0 is given under the description of INFO
             below.)
             Unlike earlier versions of SHSEQR, this subroutine may
             explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1
             or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="wr">
            <code>
            WR is REAL array, dimension (N)
            </code>
            </param>
            <param name="wi">
            <code>
            WI is REAL array, dimension (N)
             The real and imaginary parts, respectively, of the computed
             eigenvalues. If two eigenvalues are computed as a complex
             conjugate pair, they are stored in consecutive elements of
             WR and WI, say the i-th and (i+1)th, with WI(i) .GT. 0 and
             WI(i+1) .LT. 0. If JOB = 'S', the eigenvalues are stored in
             the same order as on the diagonal of the Schur form returned
             in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
             diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
             WI(i+1) = -WI(i).
            </code>
            </param>
            <param name="z">
            <code>
            Z is REAL array, dimension (LDZ,N)
             If COMPZ = 'N', Z is not referenced.
             If COMPZ = 'I', on entry Z need not be set and on exit,
             if INFO = 0, Z contains the orthogonal matrix Z of the Schur
             vectors of H.  If COMPZ = 'V', on entry Z must contain an
             N-by-N matrix Q, which is assumed to be equal to the unit
             matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
             if INFO = 0, Z contains Q*Z.
             Normally Q is the orthogonal matrix generated by SORGHR
             after the call to SGEHRD which formed the Hessenberg matrix
             H. (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if COMPZ = 'I' or
             COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is REAL array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient and delivers very good and sometimes
             optimal performance.  However, LWORK as large as 11*N
             may be required for optimal performance.  A workspace
             query is recommended to determine the optimal workspace
             size.
             If LWORK = -1, then SHSEQR does a workspace query.
             In this case, SHSEQR checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal
                      value
             .GT. 0:  if INFO = i, SHSEQR failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and JOB = 'E', then on exit, the
                  remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and JOB   = 'S', then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is an orthogonal matrix.  The final
                  value of H is upper Hessenberg and quasi-triangular
                  in rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and COMPZ = 'V', then on exit
                    (final value of Z)  =  (initial value of Z)*U
                  where U is the orthogonal matrix in (*) (regard-
                  less of the value of JOB.)
                  If INFO .GT. 0 and COMPZ = 'I', then on exit
                        (final value of Z)  = U
                  where U is the orthogonal matrix in (*) (regard-
                  less of the value of JOB.)
                  If INFO .GT. 0 and COMPZ = 'N', then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Optionally Z may be postmultiplied into an input orthogonal
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Default values supplied by
            ILAENV(ISPEC,'SHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).
            It is suggested that these defaults be adjusted in order
            to attain best performance in each particular
            computational environment.
            ISPEC=12: The SLAHQR vs SLAQR0 crossover point.
                      Default: 75. (Must be at least 11.)
            ISPEC=13: Recommended deflation window size.
                      This depends on ILO, IHI and NS.  NS is the
                      number of simultaneous shifts returned
                      by ILAENV(ISPEC=15).  (See ISPEC=15 below.)
                      The default for (IHI-ILO+1).LE.500 is NS.
                      The default for (IHI-ILO+1).GT.500 is 3*NS/2.
            ISPEC=14: Nibble crossover point. (See IPARMQ for
                      details.)  Default: 14% of deflation window
                      size.
            ISPEC=15: Number of simultaneous shifts in a multishift
                      QR iteration.
                      If IHI-ILO+1 is ...
                      greater than      ...but less    ... the
                      or equal to ...      than        default is
                           1               30          NS =   2(+)
                          30               60          NS =   4(+)
                          60              150          NS =  10(+)
                         150              590          NS =  **
                         590             3000          NS =  64
                        3000             6000          NS = 128
                        6000             infinity      NS = 256
                  (+)  By default some or all matrices of this order
                       are passed to the implicit double shift routine
                       SLAHQR and this parameter is ignored.  See
                       ISPEC=12 above and comments in IPARMQ for
                       details.
                 (**)  The asterisks (**) indicate an ad-hoc
                       function of N increasing from 10 to 64.
            ISPEC=16: Select structured matrix multiply.
                      If the number of simultaneous shifts (specified
                      by ISPEC=15) is less than 14, then the default
                      for ISPEC=16 is 0.  Otherwise the default for
                      ISPEC=16 is 2.
            </code>
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle">
            <summary>
            Contains the default implementation for the 
            BLAS for float-precision real numbers.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.#ctor">
            <summary>
            Constructs a new managed linear algebra implementation 
            for float-precision real and complex vectors and matrices.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Sum(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the sum of all elements in the array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <returns>The sum of the elements of <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Max(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the maximum of all elements in the array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <returns>The maximum of the elements of <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Min(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the minimum of all elements in the array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <returns>The minimum of the elements of <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Add(System.Int32,Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Adds a value to each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="value">The number to compare to.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.SubtractFrom(System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Subtracts each element of an array from a value.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="value">The number to compare to.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Multiply(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Multiplies each element of an array by the corresponding element in another array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="first">The array that holds the first operands.</param>
            <param name="second">The array that holds the second operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Divide(System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Divides a number by each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="value">The number to compare to.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Divide(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Divides each element of an array by the corresponding element in another array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="first">The array that holds the first operands.</param>
            <param name="second">The array that holds the second operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Abs(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the absolute value of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Ceiling(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the smallest integer greather than or equal to each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Floor(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the largest integer less than or equal to each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Max(System.Int32,Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the maximum of a number and each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="value">The number to compare to.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Min(System.Int32,Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the minimum of a number and each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="value">The number to compare to.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Exp(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the exponential of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Log(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the natural logarithm of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Sqrt(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the square root of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Pow(System.Int32,Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Raises each element in an array to the specified power.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="exponent">The exponent.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Pow(System.Int32,Extreme.Collections.ArraySlice{System.Single},System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Raises each element in an array to the specified power.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="exponent">The exponent.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Hypot(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the square root of the sum of the squared corresponding elements
            of two matrices.
            </summary>
            <param name="length">The number of elements in the arrays.</param>
            <param name="first">A vector.</param>
            <param name="second">A vector.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Sin(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the sine of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Cos(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the cosine of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Tan(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the tangent of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Asin(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the inverse sine of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Acos(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the inverse cosine of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Atan(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the inverse tangent of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Atan2(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the four-quadrant inverse tangent of each pair of corresponding elements of two arrays.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="y">The array that holds the y-values.</param>
            <param name="x">The array that holds the x-values.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Sinh(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the hyperbolic sine of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Cosh(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the hyperbolic cosine of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Tanh(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the hyperbolic tangent of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Asinh(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the inverse hyperbolic sine of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Acosh(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the inverse hyperbolic cosine of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedArrayFunctionsOfSingle.Atanh(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the inverse hyperbolic tangent of each element of an array.
            </summary>
            <param name="length">The number of elements in the array.</param>
            <param name="operand">The array that holds the operands.</param>
            <param name="result">The array that holds the results.</param>
        </member>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle">
            <summary>
            Contains the default implementation for the 
            BLAS for float-precision real numbers.
            </summary>
            <summary>
            Contains the default implementation for the Level 2
            BLAS for float-precision real numbers.
            </summary>
            <summary>
            Contains the default implementation for the Level 3
            BLAS for float-precision real numbers.
            </summary>
            <summary>
            Contains the default implementation for the 
            BLAS for float-precision real numbers.
            </summary>
            <summary>
            Contains the default implementation for the Level 2
            BLAS for complex float-precision real numbers.
            </summary>
            <summary>
            Specifies the methods that must be implemented by a
            class to support level 3 BLAS routines.
            </summary>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Name">
            <inheritdoc/>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Platform">
            <inheritdoc/>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.#ctor">
            <summary>
            Constructs a new managed linear algebra implementation 
            for float-precision real and complex vectors and matrices.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyInPlace(System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Evaluates the product of a scalar and a vector.
            </summary>
            <param name="n">The number of elements in the vector
            <paramref name="x"/>.</param>
            <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Evaluates a vector plus the product of a scalar and a vector
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.DotProduct(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the inner product of two vectors.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
            <returns>The dot product of the two vectors.</returns>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Swap(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Exchanges the elements of two vectors.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Copy(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Copies a vector.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the elements of <paramref name="x"/>.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TwoNorm(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the square root of sum of the squares of
            the elements of a vector.
            </summary>
            <param name="n">The number of elements in the vector
            <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.OneNorm(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the sum of the absolute values of
            the elements of a vector.
            </summary>
            <param name="n">The number of elements in the vector <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.AbsoluteMaxIndex(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the index of the element of a vector with
            maximum absolute value.
            </summary>
            <param name="n">The number of elements in the vector <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.CreateGivensRotation(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Generates the elements for a Givens plane rotation.
            </summary>
            <param name="a">The first element of the input vector.
            On exit, this value is overwritten with the rotated
            element <i>r</i>.</param>
            <param name="b">The second element of the input vector.
            On exit, this value is overwritten with the
            reconstruction value <i>z</i>.</param>
            <param name="c">On exit, this value is overwritten with
            the first rotation element, the cosine of the rotation
            angle.</param>
            <param name="s">On exit, this value is overwritten with
            the second rotation element, the sine of the rotation
            angle.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Rotate(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,System.Single)">
            <summary>
            Applies a Givens plane rotation.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="c">The first rotation element,
            the cosine of the rotation angle.</param>
            <param name="s">The second rotation element,
            the sine of the rotation angle.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.CreateModifiedGivensRotation(System.Single@,System.Single@,System.Single@,System.Single,System.Single[])">
            <summary>
            Applies a modified Givens rotation.
            </summary>
            <param name="d1">The first scale factor for the modified
            Givens transform.</param>
            <param name="d2">The second scale factor for the modified
            Givens transform.</param>
            <param name="x1">The first element of the input vector.
            On exit, this value is overwritten with the rotated
            element.</param>
            <param name="y1">The second element of the input
            vector.</param>
            <param name="param">An array defining the type of transform
            matrix H used.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.ApplyModifiedGivensRotation(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single[])">
            <summary>
            Applies a modified Givens rotation.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="param">An array defining the type of transform
            matrix H used.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Sum of the product of a general matrix and vector and a scaled vector.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a triangular matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Solves a triangular system of equations.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a symmetric matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.RankUpdate(System.Int32,System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a rank one update of a matrix.
            </summary>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a rank one update of a symmetric matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the
            matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a symmetric rank two update of a symmetric matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandMultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Sum of the product of a general band matrix and vector and a scaled vector.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="ku">The upper bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="kl">The lower bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandSymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a symmetric band matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="k">The bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a triangular band matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="k">The bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Solves a triangular band system of equations.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="k">The bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            Sum of the product of two general matrices and a scaled matrix.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="transB">Specifies the operation to be
            performed on the matrix <paramref name="b"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="transA"/>,
            and the matrix <paramref name="c"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>
            transformed as specified by <paramref name="transB"/>,
            and the matrix <paramref name="c"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="transA"/>,
            and the number of rows of the matrix <paramref name="b"/>
            transformed as specified by <paramref name="transB"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            Sum of the product of a symmetric and a general matrix and a scaled matrix.
            </summary>
            <param name="side">Specifies on which side the symmetric
            matrix <paramref name="a"/> is to be multiplied.</param>
            <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="m">The number of rows in the matrix <paramref name="b"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Product of a triangular and a general matrix.
            </summary>
            <param name="side">Specifies on which side the triangular
            matrix <paramref name="a"/> is to be multiplied.</param>
            <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="transA"/>,
            and the matrix <paramref name="b"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularSolveInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Solution of a triangular linear system with
            multiple right-hand sides.
            </summary>
            <param name="side">Specifies on which side the triangular
            matrix <paramref name="a"/> is to be multiplied.</param>
            <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a rank <i>k</i> update of a symmetric matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="trans">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="n">The number of rows and columns in
            the matrix <paramref name="c"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="trans"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a rank <i>2k</i> update of a symmetric matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="trans">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="n">The number of rows and columns in
            the matrix <paramref name="c"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="trans"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where  alpha and beta are scalars, A is a symmetric matrix and  B and
            C are m by n matrices.</para>
            </summary>
            <param name="side">
            <pre>
             On entry,  SIDE  specifies whether  the  symmetric matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
            </param>
            <param name="storedTriangle">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  symmetric  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    symmetric matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    symmetric matrix is to be referenced.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is n  otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least max( 1, n ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Performs one of the symmetric rank k operations
               C := alpha*A*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
            and  A  is an  n by k  matrix in the first case and a  k by n  matrix
            in the second case.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>T</sup> + beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*A + beta*C.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Performs one of the symmetric rank 2k operations
               C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
            and  A and B  are  n by k  matrices  in the  first  case  and  k by n
            matrices in the second case.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'    C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> +
                                           beta*C.
                TRANS = 'T' or 't'    C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                           beta*C.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Copy(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Copies all or part of a two-dimensional matrix A to another
            matrix B.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper triangle
            or trapezoid is accessed; if UPLO = 'L', only the lower
            triangle or trapezoid is accessed.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,M).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,M).
            </pre>
            </param>
            <remarks>
            This method corresponds to the LAPACK routine <c>DLACPY</c>.
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.FullMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real matrix A.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies the value to be returned in DLANGE as described
            above.
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.  When M = 0,
            DLANGE is set to zero.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.  When N = 0,
            DLANGE is set to zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The m by n matrix A.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(M,1).
            </pre>
            </param>
            <remarks>
            <pre>
            DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </pre>
            <para>This method corresponds to the LAPACK routine <c>DLANGE</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            trapezoidal or triangular matrix A.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies the value to be returned in DLANTR as described
            above.
            </pre>
            </param>
            <param name="storedTriangle">
            <pre>
            Specifies whether the matrix A is upper or lower trapezoidal.
            = 'U':  Upper trapezoidal
            = 'L':  Lower trapezoidal
            Note that A is triangular instead of trapezoidal if M = N.
            </pre>
            </param>
            <param name="diag">
            <pre>
            Specifies whether or not the matrix A has unit diagonal.
            = 'N':  Non-unit diagonal
            = 'U':  Unit diagonal
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0, and if
            UPLO = 'U', M &lt;= N.  When M = 0, DLANTR is set to zero.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0, and if
            UPLO = 'L', N &lt;= M.  When N = 0, DLANTR is set to zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The trapezoidal matrix A (A is triangular if M = N).
            If UPLO = 'U', the leading m by n upper trapezoidal part of
            the array A contains the upper trapezoidal matrix, and the
            strictly lower triangular part of A is not referenced.
            If UPLO = 'L', the leading m by n lower trapezoidal part of
            the array A contains the lower trapezoidal matrix, and the
            strictly upper triangular part of A is not referenced.  Note
            that when DIAG = 'U', the diagonal elements of A are not
            referenced and are assumed to be one.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(M,1).
            </pre>
            </param>
            <remarks>
            <pre>
            DLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </pre>
            <para>This method corresponds to the LAPACK routine <c>DLANTR</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real symmetric matrix A.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies the value to be returned in DLANSY as described
            above.
            </pre>
            </param>
            <param name="storedTriangle">
            <pre>
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is to be referenced.
            = 'U':  Upper triangular part of A is referenced
            = 'L':  Lower triangular part of A is referenced
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.  When N = 0, DLANSY is
            set to zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The symmetric matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(N,1).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            DLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </pre>
            </para> 
            <para>This method corresponds to the LAPACK routine <c>DLANSY</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.ComplexOneNorm(Extreme.Mathematics.Complex{System.Single})">
            <inheritdoc/>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyInPlace(System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Evaluates the product of a scalar and a vector.
            </summary>
            <param name="n">The number of elements in the vector
            <paramref name="x"/>.</param>
            <param name="a">The scalar value used to multiply
            the elements of <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyInPlace(System.Int32,System.Single,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Scales a vector by a constant.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Evaluates a vector plus the product of a scalar and a vector
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="a">The scalar value used to multiply
            the elements of <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.ConjugateDotProduct(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Returns the inner product of two vectors.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.DotProduct(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Returns the inner product of two vectors.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Swap(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Exchanges the elements of two vectors.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Copy(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Copies a vector.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the elements of <paramref name="x"/>.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TwoNorm(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Returns the square root of sum of the squares of
            the elements of a vector.
            </summary>
            <param name="n">The number of elements in the vector <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.RealOneNorm(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Returns the sum of the absolute values of
            the elements of a vector.
            </summary>
            <param name="n">The number of elements in the vector <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.AbsoluteMaxIndex(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Returns the index of the element of a vector with
            maximum absolute value.
            </summary>
            <param name="n">The number of elements in the vector <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Rotate(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},System.Single,System.Single)">
            <summary>
            <para>
            A plane rotation, where the cos and sin (c and s) are real
            and the vectors cx and cy are complex.</para>
            </summary>
            <param name="n">
            <pre>
             On entry, N specifies the order of the vectors cx and cy.
             N must be at least zero.
            </pre>
            </param>
            <param name="cx">
            <pre>
            Dimension at least
             ( 1 + ( N - 1 )*abs( INCX ) ).
             Before entry, the incremented array CX must contain the n
             element vector cx. On exit, CX is overwritten by the updated
             vector cx.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             CX. INCX must not be zero.
            </pre>
            </param>
            <param name="cy">
            <pre>
            Dimension at least
             ( 1 + ( N - 1 )*abs( INCY ) ).
             Before entry, the incremented array CY must contain the n
             element vector cy. On exit, CY is overwritten by the updated
             vector cy.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             CY. INCY must not be zero.
            </pre>
            </param>
            <param name="c">
            <pre>
             On entry, C specifies the cosine, cos.
            </pre>
            </param>
            <param name="s">
            <pre>
             On entry, S specifies the sine, sin.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            jack dongarra, linpack, 3/11/78.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Sum of the product of a general matrix and vector and a scaled vector.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Product of a triangular matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Solves a triangular system of equations.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Product of a hermitian matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.RankUpdate(System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Performs a rank one update of a matrix.
            </summary>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.ConjugateRankUpdate(System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Performs a rank one update of a matrix.
            </summary>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Single,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Performs a rank one update of a hermitian.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the
            matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Performs a hermitian rank two update of a hermitian matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandMultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,   or
               y := alpha*A<sup>H</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n band matrix, with kl sub-diagonals and ku super-diagonals.</para>
            </summary>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>H</sup>*x + beta*y.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="kl">
            <pre>
             On entry, KL specifies the number of sub-diagonals of the
             matrix A. KL must satisfy  0 .le. KL.
            </pre>
            </param>
            <param name="ku">
            <pre>
             On entry, KU specifies the number of super-diagonals of the
             matrix A. KU must satisfy  0 .le. KU.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry, the leading ( kl + ku + 1 ) by n part of the
             array A must contain the matrix of coefficients, supplied
             column by column, with the leading diagonal of the matrix in
             row ( ku + 1 ) of the array, the first super-diagonal
             starting at position 2 in row ku, the first sub-diagonal
             starting at position 1 in row ( ku + 2 ), and so on.
             Elements in the array A that do not correspond to elements
             in the band matrix (such as the top left ku by ku triangle)
             are not referenced.
             The following program segment will transfer a band matrix
             from conventional full matrix storage to band storage:
                   DO 20, J = 1, N
                      K = KU + 1 - J
                      DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
                         A( K + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( kl + ku + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 Blas routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular band matrix, with ( k + 1 ) diagonals.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is (input/output) COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 Blas routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.BandTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular band matrix, with ( k + 1 )
            diagonals.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
            </para>
            <para>This method is based on the BLAS routine ZTBSV.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Sum of the product of two general matrices and a scaled matrix.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="transB">Specifies the operation to be
            performed on the matrix <paramref name="b"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="transA"/>,
            and the matrix <paramref name="c"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>
            transformed as specified by <paramref name="transB"/>,
            and the matrix <paramref name="c"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="transA"/>,
            and the number of rows of the matrix <paramref name="b"/>
            transformed as specified by <paramref name="transB"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
            <param name="beta">The scalar used to multiply the product of the matrices.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianMultiplyAndAddInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Sum of the product of a hermitian and a general matrix and a scaled matrix.
            </summary>
            <param name="side">Specifies on which side the hermitian
            matrix <paramref name="a"/> is to be multiplied.</param>
            <param name="triangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>
            and the matrix <paramref name="c"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>
            and the matrix <paramref name="c"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Product of a triangular and a general matrix.
            </summary>
            <param name="side">Specifies on which side the triangular
            matrix <paramref name="a"/> is to be multiplied.</param>
            <param name="triangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="transA"/>,
            and the matrix <paramref name="b"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>
            and the matrix <paramref name="b"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularSolveInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Solution of a triangular linear system with
            multiple right-hand sides.
            </summary>
            <param name="side">Specifies on which side the triangular
            matrix <paramref name="a"/> is to be multiplied.</param>
            <param name="triangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>
            and the matrix <paramref name="b"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>
            and the matrix <paramref name="b"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">A complex array that contains the elements of the first
            matrix.</param>
            <param name="b">A complex array that contains the elements of the second
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Performs a rank <i>k</i> update of a hermitian matrix.
            </summary>
            <param name="triangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="trans">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="n">The number of rows and columns in
            the matrix <paramref name="c"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="trans"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Performs a rank <i>2k</i> update of a hermitian matrix.
            </summary>
            <param name="triangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="trans">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="n">The number of rows and columns in
            the matrix <paramref name="c"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="trans"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.Copy(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Copies the specified elements of a complex matrix.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies which part of the matrix should be copied.</param>
            <param name="m">The number of rows of the matrices.</param>
            <param name="n">The number of columns of the matrices.</param>
            <param name="a">A complex array that contains the data for the source matrix.</param>
            <param name="b">A complex array that contains the data for the destination matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.FullMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the norm of a general rectangular matrix.
            </summary>
            <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm"/> that specifies the type of norm to compute.</param>
            <param name="m">The number of rows of the matrix.</param>
            <param name="n">The number of columns of the matrix.</param>
            <param name="a">A complex number array that contains the elements of the matrix.</param>
            <returns>The norm of the matrix.</returns>
            <remarks>This method corresponds to the LAPACK routine <c>?LANGE</c>.</remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.TriangularMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the norm of a triangular matrix.
            </summary>
            <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm"/> that specifies the type of norm to compute.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies whether the
            matrix is upper or lower triangular.</param>
            <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that indicates whether the diagonal
            elements are all equal to one.</param>
            <param name="m">The number of rows of the matrix.</param>
            <param name="n">The number of columns of the matrix.</param>
            <param name="a">A complex number array that contains the elements of the matrix.</param>
            <returns>The norm of the matrix.</returns>
            <remarks>This method corresponds to the LAPACK routine <c>?LANTR</c>.</remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.SymmetricMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the norm of a symmetric matrix.
            </summary>
            <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm"/> that specifies the type of norm to compute.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex number array that contains the elements of the matrix.</param>
            <returns>The norm of the matrix.</returns>
            <remarks>This method corresponds to the LAPACK routine <c>?LANSY</c>.</remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperationsOfSingle.HermitianMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the norm of a Hermitian matrix.
            </summary>
            <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm"/> that specifies the type of norm to compute.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex number array that contains the elements of the matrix.</param>
            <returns>The norm of the matrix.</returns>
            <remarks>This method corresponds to the LAPACK routine <c>?LANHE</c>.</remarks>
        </member>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle">
            <summary>
            SerialBlas implementation. No error checking or special cases.
            </summary>
            <summary>
            SerialBlas implementation. No error checking or special cases.
            </summary>
            <summary>
            SerialBlas implementation. No error checking or special cases.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.MultiplyInPlace(System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Evaluates the product of a scalar and a vector.
            </summary>
            <param name="n">The number of elements in the vector
            <paramref name="x"/>.</param>
            <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.MultiplyAndAddInPlace(System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Evaluates a vector plus the product of a scalar and a vector
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.Swap(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Exchanges the elements of two vectors.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.Copy(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Copies a vector.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the elements of <paramref name="x"/>.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.TwoNorm(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the square root of sum of the squares of
            the elements of a vector.
            </summary>
            <param name="n">The number of elements in the vector
            <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.OneNorm(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the sum of the absolute values of
            the elements of a vector.
            </summary>
            <param name="n">The number of elements in the vector <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.AbsoluteMaxIndex(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the index of the element of a vector with
            maximum absolute value.
            </summary>
            <param name="n">The number of elements in the vector <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.CreateGivensRotation(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Generates the elements for a Givens plane rotation.
            </summary>
            <param name="a">The first element of the input vector.
            On exit, this value is overwritten with the rotated
            element <math>r</math>.</param>
            <param name="b">The second element of the input vector.
            On exit, this value is overwritten with the
            reconstruction value <math>z</math>.</param>
            <param name="c">On exit, this value is overwritten with
            the first rotation element, the cosine of the rotation
            angle.</param>
            <param name="s">On exit, this value is overwritten with
            the second rotation element, the sine of the rotation
            angle.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.Rotate(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,System.Single)">
            <summary>
            Applies a Givens plane rotation.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="c">The first rotation element,
            the cosine of the rotation angle.</param>
            <param name="s">The second rotation element,
            the sine of the rotation angle.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.CreateModifiedGivensRotation(System.Single@,System.Single@,System.Single@,System.Single,System.Single[])">
            <summary>
            Applies a modified Givens rotation.
            </summary>
            <param name="d1">The first scale factor for the modified
            Givens transform.</param>
            <param name="d2">The second scale factor for the modified
            Givens transform.</param>
            <param name="x1">The first element of the input vector.
            On exit, this value is overwritten with the rotated
            element.</param>
            <param name="y1">The second element of the input
            vector.</param>
            <param name="param">An array defining the type of transform
            matrix H used.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.ApplyModifiedGivensRotation(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single[])">
            <summary>
            Applies a modified Givens rotation.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="param">An array defining the type of transform
            matrix H used.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Sum of the product of a general matrix and vector and a scaled vector.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a triangular matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.TriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Solves a triangular system of equations.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a symmetric matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.RankUpdate(System.Int32,System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a rank one update of a matrix.
            </summary>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a rank one update of a symmetric matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the
            matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a symmetric rank two update of a symmetric matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.BandMultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Sum of the product of a general band matrix and vector and a scaled vector.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="ku">The upper bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="kl">The lower bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.BandSymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a symmetric band matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="k">The bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.BandTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a triangular band matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="k">The bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ParallelBlasOfSingle.BandTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Solves a triangular band system of equations.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="k">The bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle">
            <summary>
            SerialBlas implementation. No error checking or special cases.
            </summary>
            <summary>
            SerialBlas implementation. No error checking or special cases.
            </summary>
            <summary>
            SerialBlas implementation. No error checking or special cases.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.MultiplyInPlace(System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Evaluates the product of a scalar and a vector.
            </summary>
            <param name="n">The number of elements in the vector
            <paramref name="x"/>.</param>
            <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.MultiplyAndAddInPlace(System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Evaluates a vector plus the product of a scalar and a vector
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.DotProduct(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the inner product of two vectors.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
            <returns>The dot product of the two vectors.</returns>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.Swap(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Exchanges the elements of two vectors.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.Copy(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Copies a vector.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the elements of <paramref name="x"/>.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.TwoNorm(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the square root of sum of the squares of
            the elements of a vector.
            </summary>
            <param name="n">The number of elements in the vector
            <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.OneNorm(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the sum of the absolute values of
            the elements of a vector.
            </summary>
            <param name="n">The number of elements in the vector <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.AbsoluteMaxIndex(System.Int32,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the index of the element of a vector with
            maximum absolute value.
            </summary>
            <param name="n">The number of elements in the vector <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.CreateGivensRotation(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Generates the elements for a Givens plane rotation.
            </summary>
            <param name="a">The first element of the input vector.
            On exit, this value is overwritten with the rotated
            element <i>r</i>.</param>
            <param name="b">The second element of the input vector.
            On exit, this value is overwritten with the
            reconstruction value <i>z</i>.</param>
            <param name="c">On exit, this value is overwritten with
            the first rotation element, the cosine of the rotation
            angle.</param>
            <param name="s">On exit, this value is overwritten with
            the second rotation element, the sine of the rotation
            angle.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.Rotate(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,System.Single)">
            <summary>
            Applies a Givens plane rotation.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="c">The first rotation element,
            the cosine of the rotation angle.</param>
            <param name="s">The second rotation element,
            the sine of the rotation angle.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.CreateModifiedGivensRotation(System.Single@,System.Single@,System.Single@,System.Single,System.Single[])">
            <summary>
            Applies a modified Givens rotation.
            </summary>
            <param name="d1">The first scale factor for the modified
            Givens transform.</param>
            <param name="d2">The second scale factor for the modified
            Givens transform.</param>
            <param name="x1">The first element of the input vector.
            On exit, this value is overwritten with the rotated
            element.</param>
            <param name="y1">The second element of the input
            vector.</param>
            <param name="param">An array defining the type of transform
            matrix H used.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.ApplyModifiedGivensRotation(System.Int32,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single[])">
            <summary>
            Applies a modified Givens rotation.
            </summary>
            <param name="n">The number of elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="param">An array defining the type of transform
            matrix H used.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Sum of the product of a general matrix and vector and a scaled vector.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a triangular matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.TriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Solves a triangular system of equations.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a symmetric matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.RankUpdate(System.Int32,System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a rank one update of a matrix.
            </summary>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a rank one update of a symmetric matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the
            matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Single,Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a symmetric rank two update of a symmetric matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            outer product.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            </param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.BandMultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Sum of the product of a general band matrix and vector and a scaled vector.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="ku">The upper bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="kl">The lower bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.BandSymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a symmetric band matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="k">The bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.BandTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Product of a triangular band matrix and a vector.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="k">The bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.BandTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Solves a triangular band system of equations.
            </summary>
            <param name="storedTriangle">Specifies whether the matrix is an
            upper or lower triangular matrix.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="n">The number of rows and columns in the matrix <paramref name="a"/>.</param>
            <param name="k">The bandwidth of the matrix <paramref name="a"/>.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            The elements of <paramref name="x"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            Sum of the product of two general matrices and a scaled matrix.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="transB">Specifies the operation to be
            performed on the matrix <paramref name="b"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="transA"/>,
            and the matrix <paramref name="c"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>
            transformed as specified by <paramref name="transB"/>,
            and the matrix <paramref name="c"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="transA"/>,
            and the number of rows of the matrix <paramref name="b"/>
            transformed as specified by <paramref name="transB"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            Sum of the product of a symmetric and a general matrix and a scaled matrix.
            </summary>
            <param name="side">Specifies on which side the symmetric
            matrix <paramref name="a"/> is to be multiplied.</param>
            <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="m">The number of rows in the matrix <paramref name="b"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Product of a triangular and a general matrix.
            </summary>
            <param name="side">Specifies on which side the triangular
            matrix <paramref name="a"/> is to be multiplied.</param>
            <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="transA"/>,
            and the matrix <paramref name="b"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="transA"/>,
            and the matrix <paramref name="b"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.TriangularSolveInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Solution of a triangular linear system with
            multiple right-hand sides.
            </summary>
            <param name="side">Specifies on which side the triangular
            matrix <paramref name="a"/> is to be multiplied.</param>
            <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="diag">Specifies whether or not
            <paramref name="a"/> is unit triangular.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="b"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a rank <i>k</i> update of a symmetric matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="trans">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="n">The number of rows and columns in
            the matrix <paramref name="c"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="trans"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SerialBlasOfSingle.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Single,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            Performs a rank <i>2k</i> update of a symmetric matrix.
            </summary>
            <param name="storedTriangle">Specifies whether the elements of
            the matrix <paramref name="a"/> are stored in the
            upper or lower triangular part.</param>
            <param name="trans">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="n">The number of rows and columns in
            the matrix <paramref name="c"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>
            transformed as specified by <paramref name="trans"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the first
            matrix.</param>
            <param name="b">Reference to the first element in a
            one-dimensional array that contains the elements of the second
            matrix.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">Reference to the first element in a
            one-dimensional array that contains the elements of the third
            matrix.</param>
        </member>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle">
            <summary>
            Specifies the methods that must be implemented by a
            class to support complex float-precision LAPACK routines
            for general matrices.
            </summary>
            <remarks>
            <para>The Linear Algebra PACKage (LAPACK) is the de facto
            standard for more complex linear algebra problems. It complements
            the Basic Linear Algebra Subroutines (BLAS), which defines standards
            for low level vector and matrix operations.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
             ZGETRF computes an LU decomposition of a general M-by-N matrix A
             using partial pivoting with row interchanges.
             <para>
             The decomposition has the form</para>
             <para><center>A = P * L * U</center></para>
             <para>where P is a permutation matrix, L is lower triangular with unit
             diagonal elements (lower trapezoidal if m > n), and U is upper
             triangular (upper trapezoidal if m &lt; n).
             </para>
             <para>
             This is the right-looking Level 3 BLAS version of the algorithm.
             </para>
             </summary>
             <param name="m">An integer specifying the number of rows
             of the matrix <paramref name="a"/>. Must be greater than
             or equal to zero.</param>
             <param name="n">An integer specifying the number of
             columns of the matrix <paramref name="a"/>. Must be
             greater than or equal to zero.
             </param>
             <param name="a">complex float-precision array specifying the
             <paramref name="m"/>-by-<paramref name="n"/> matrix
             to be factored. On exit, the factors L and U from the
             decomposition A = P*L*U; the unit diagonal elements of
             L are not stored.</param>
             <param name="ipiv">Integer array of length
             min(<paramref name="m"/>,<paramref name="n"/>) that
             will hold the pivot indexes. Row <i>i</i> of the
             matrix was interchanged with row
             <paramref name="ipiv"/>[<i>i</i>].</param>
             <param name="info">Reference to an integer containing a
             result code. Zero indicates success. Greater than zero
             indicates U(i,i) is exactly zero. The decomposition
             has been completed, but the factor U is exactly
             singular, and division by zero will occur if it is used
             to solve a system of equations.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
             ZGETRS solves a system of linear equations
                A * X = B  or  A' * X = B
             with a general N-by-N matrix A using the LU decomposition computed
             by ZGETRF.
            
             Arguments
             =========
            
             TRANS   (input) CHARACTER*1
             Specifies the form of the system of equations:
                = 'N':  A * X = B  (No transpose)
                = TransposeOperation.Transpose:  A'* X = B  (Transpose)
                = 'C':  A'* X = B  (Conjugate transpose = Transpose)
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N >= 0.
            
             NRHS    (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS >= 0.
            
             A       (input) ZOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA >= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             B       (input/output) ZOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the right hand side matrix B.
             On exit, the solution matrix X.
            
             LDB     (input) INTEGER
             The leading dimension of the array B.  LDB >= Max(1,N).
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
             =====================================================================
            
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUInvert(System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
             ZGETRI computes the inverse of a matrix using the LU decomposition
             computed by ZGETRF.
            
             This method inverts U and then computes inv(A) by solving the system
             inv(A)*L = inv(U) for inv(A).
            
             Arguments
             =========
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N >= 0.
            
             A       (input/output) ZOUBLE PRECISION array, dimension (LDA,N)
             On entry, the factors L and U from the decomposition
             A = P*L*U as computed by ZGETRF.
             On exit, if INFO = 0, the inverse of the original matrix A.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA >= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             WORK    (workspace/output) ZOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO =0, then WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK >= Max(1,N).
             For optimal performance LWORK >= N*NB, where NB is
             the optimal blocksize returned by ILAENV.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
             > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
             singular and its inverse could not be computed.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,System.Single@,System.Int32@)">
            <summary>
             ZGECON estimates the reciprocal of the condition number of a general
             real matrix A, inthis. either the 1-norm or the infinity-norm, using
             the LU decomposition computed by ZGETRF.
            
             An estimate is obtained for norm(inv(A)), and the reciprocal of the
             condition number is computed as
                RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            
             Arguments
             =========
            
             NORM    (input) CHARACTER*1
             Specifies whether the 1-norm condition number or the
             infinity-norm condition number is required:
                = '1' or 'O':  1-norm;
                = 'I':         Infinity-norm.
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N >= 0.
            
             A       (input) ZOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA >= Max(1,N).
            
             ANORM   (input) ZOUBLE PRECISION
             If NORM = '1' or 'O', the 1-norm of the original matrix A.
             If NORM = 'I', the infinity-norm of the original matrix A.
            
             RCOND   (output) ZOUBLE PRECISION
             The reciprocal of the condition number of the matrix A,
             computed as RCOND = 1/(norm(A) * norm(inv(A))).
            
             WORK    (workspace) ZOUBLE PRECISION array, dimension (4*N)
            
             IWORK   (workspace) INTEGER array, dimension (N)
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
            
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
             ZGEQRF computes a QR decomposition of a real M-by-N matrix A:
             A = Q * R.
            
             Arguments
             =========
            
             M       (input) INTEGER
             The number of rows of the matrix A.  M >= 0.
            
             N       (input) INTEGER
             The number of columns of the matrix A.  N >= 0.
            
             A       (input/output) ZOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the elements on and above the diagonal of the array
             contain the min(M,N)-by-N upper trapezoidal matrix R (R is
             upper triangular if m >= n); the elements below the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of min(m,n) elementary reflectors (see Further
             Zetails).
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA >= max(1,M).
            
             TAU     (output) ZOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Zetails).
            
             WORK    (workspace/output) ZOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK >= max(1,N).
             For optimum performance LWORK >= N*NB, where NB is
             the optimal blocksize.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             INFO    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            
             Further Zetails
             ===============
            
             The matrix Q is represented as a product of elementary reflectors
            
                Q = H(1) H(2) . . . H(k), where k = min(m,n).
            
             Each H(i) has the form
            
                H(i) = I - tau * v * v'
            
             where tau is a real scalar, and v is a real vector with
             v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit inthis. A(i+1:m,i),
             and tau inthis. TAU(i).
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.QRUnitaryMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q<sup>H</sup> * C       C * Q<sup>H</sup>
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <pre>
            = 'L': apply Q or Q<sup>H</sup> from the Left;
            = 'R': apply Q or Q<sup>H</sup> from the Right.
            </pre>
            </param>
            <param name="trans">
            <pre>
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q<sup>H</sup>.
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the matrix C. M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix C. N >= 0.
            </pre>
            </param>
            <param name="k">
            <pre>
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQRF in the first k columns of its array argument A.
            </pre>
            <pre>
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </pre>
            </param>
            <param name="tau">
            <pre>
            Dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQRF.
            </pre>
            </param>
            <param name="c">
            <pre>
            Dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q<sup>H</sup>*C or C*Q<sup>H</sup> or C*Q.
            </pre>
            <pre>
            The leading dimension of the array C. LDC >= max(1,M).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            . . H(k)
            as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            Solves a complex triangular system of equations.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix is upper
            or lower triangular.</param>
            <param name="trans">A <see cref="T:Extreme.Mathematics.TransposeOperation"/> value that indicates if the matrix should be transposed or not.</param>
            <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that indicates whether the matrix is unit diagonal.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="nrhs">The number of right hand sides.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="b">A complex array that contains the components of the right-hand side(s).</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularInvert(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            Computes the inverse of a complex triangular matrix.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix is upper
            or lower triangular.</param>
            <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that indicates whether the matrix is unit diagonal.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularEstimateCondition(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single@,System.Int32@)">
            <summary>
            Approximates the reciprocal of the condition number of a complex triangular matrix.
            </summary>
            <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm"/> value that specifies which norm to use in the expression for the condition number.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix is upper
            or lower triangular.</param>
            <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that indicates whether the matrix is unit diagonal.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            Factors a symmetric positive definite matrix.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            Computes the inverse of a factored hermitian matrix.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            Solves a hermitian system of equations.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="nrhs">The number of right hand sides.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="b">A complex array that contains the components of the right-hand side(s).</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,System.Single@,System.Int32@)">
            <summary>
            Estimates the reciprocal of the condition number of a factored hermitian matrix.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="aNorm">The norm of the matrix.</param>
            <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a complex Hermitian matrix A
            using the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is complex number array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The form of the
            factorization is
               A = U*D*U<sup>H</sup>  or  A = L*D*L<sup>H</sup>
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is Hermitian and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            If UPLO = 'U', then A = U*D*U<sup>H</sup>, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L<sup>H</sup>, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianSolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a complex
            Hermitian matrix A using the factorization A = U*D*U<sup>H</sup> or
            A = L*D*L<sup>H</sup> computed by ZHETRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is complex number array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
            </param>
            <param name="b">
            <pre>
            B is complex number array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a complex Hermitian indefinite matrix
            A using the factorization A = U*D*U<sup>H</sup> or A = L*D*L<sup>H</sup> computed by
            ZHETRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is complex number array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by ZHETRF.
            On exit, if INFO = 0, the (Hermitian) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </pre>
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Single,System.Single@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a complex
            Hermitian matrix A using the factorization A = U*D*U<sup>H</sup> or
            A = L*D*L<sup>H</sup> computed by ZHETRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is complex number array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
            </param>
            <param name="anorm">
            <pre>
            The 1-norm of the original matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.SingularValueDecompose(System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors, by using divide-and-conquer method.</para>
            </summary>
            <param name="jobz">
            <pre>
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V<sup>H</sup> are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V<sup>H</sup> are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    in the array A and all rows of V<sup>H</sup> are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V<sup>H</sup> are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V<sup>H</sup> are computed.
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the input matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the input matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M >= N;
                            A is overwritten with the first M rows
                            of V<sup>H</sup> (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,M).
            </pre>
            </param>
            <param name="s">
            <pre>
            Dimension (min(M,N))
            The singular values of A, sorted so that S(i) >= S(i+1).
            </pre>
            </param>
            <param name="u">
            <pre>
            Dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
            unitary matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
            </pre>
            <pre>
            The leading dimension of the array U.  LDU >= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU >= M.
            </pre>
            </param>
            <param name="vt">
            <pre>
            Dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            N-by-N unitary matrix V<sup>H</sup>;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V<sup>H</sup> (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
            </pre>
            <pre>
            The leading dimension of the array VT.  LDVT >= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            if JOBZ = 'S', LDVT >= min(M,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The updating process of DBDSDC did not converge.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The SVD is written
                 A = U * SIGMA * conjugate-transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V<sup>H</sup>, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.HermitianEigenvalueDecompose(System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            complex Hermitian matrix A.</para>
            </summary>
            <param name="jobz">
            <pre>
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </pre>
            </param>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="w">
            <pre>
            Dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the sub-matrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
             Modified description of INFO. Sven, 16 Feb 05.
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.EigenvalueDecompose(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes for an N-by-N complex non-symmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
            </summary>
            <param name="jobvl">
            <pre>
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of are computed.
            </pre>
            </param>
            <param name="jobvr">
            <pre>
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A. N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="w">
            <pre>
            Dimension (N)
            W contains the computed eigenvalues.
            </pre>
            </param>
            <param name="vl">
            <pre>
            Dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            u(j) = VL(:,j), the j-th column of VL.
            </pre>
            <pre>
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.
            </pre>
            </param>
            <param name="vr">
            <pre>
            Dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            v(j) = VR(:,j), the j-th column of VR.
            </pre>
            <pre>
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements and i+1:N of W contain eigenvalues which have
                  converged.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**H * A = lambda(j) * u(j)**H
            where u(j)**H denotes the conjugate transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a complex m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B,  A<sup>T</sup> * X = B,  or  A<sup>H</sup> * X = B
            with a general band matrix A using the LU factorization computed
            by ZGBTRF.</para>
            </summary>
            <param name="trans">
            <pre>
            Specifies the form of the system of equations.
            = 'N':  A * X = B     (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose)
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},System.Single,System.Single@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a complex
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by ZGBTRF.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="anorm">
            <pre>
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band
            matrix A, in the same storage format as A.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The factorization has the form
               A = U<sup>H</sup> * U,  if UPLO = 'U', or
               A = L  * L<sup>H</sup>,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a Hermitian
            positive definite band matrix A using the Cholesky factorization
            A = U<sup>H</sup> *U or A = L*L<sup>H</sup> computed by ZPBTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>H</sup> *U or A = L*L<sup>H</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},System.Single,System.Single@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite band matrix using
            the Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> computed by
            ZPBTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="anorm">
            <pre>
            The 1-norm (or infinity-norm) of the Hermitian band matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
            </para>
            </remarks>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.Name">
            <summary>
            Gets the name of the implementation.
            </summary>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.Platform">
            <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,M).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The factorization has the form
               A = P * L * U
            where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m > n), and U is upper
            triangular (upper trapezoidal if m &lt; n).
            This is the right-looking Level 3 BLAS version of the algorithm.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGETRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B  or  A<sup>T</sup> * X = B
            with a general N-by-N matrix A using the LU factorization computed
            by DGETRF.</para>
            </summary>
            <param name="trans">
            <pre>
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup>* X = B  (Transpose)
            = 'C':  A<sup>T</sup>* X = B  (Conjugate transpose = Transpose)
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DGETRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUInvert(System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a matrix using the LU factorization
            computed by DGETRF.</para>
            </summary>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by DGETRF.
            On exit, if INFO = 0, the inverse of the original matrix A.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            This method inverts U and then computes inv(A) by solving the system
            inv(A)*L = inv(U) for inv(A).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGETRI</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.LUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{System.Single},System.Single,System.Single@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a general
            real matrix A, in either the 1-norm or the infinity-norm, using
            the LU factorization computed by DGETRF.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="anorm">
            <pre>
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGECON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization of a real M-by-N matrix A:
            A = Q * R.</para>
            </summary>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,M).
            </pre>
            </param>
            <param name="tau">
            <pre>
            Dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            and tau in TAU(i).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGEQRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization with column pivoting of a
            matrix A:  A*P = Q*R  using Level 3 BLAS.</para>
            </summary>
            <param name="m">
            <pre>
            The number of rows of the matrix A. M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper trapezoidal matrix R; the elements below
            the diagonal, together with the array TAU, represent the
            orthogonal matrix Q as a product of min(M,N) elementary
            reflectors.
            </pre>
            <pre>
            The leading dimension of the array A. LDA >= max(1,M).
            </pre>
            </param>
            <param name="jpvt">
            <pre>
            Dimension (N)
            On entry, if JPVT(J).ne.0f, the J-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(J)=0,
            the J-th column of A is a free column.
            On exit, if JPVT(J)=K, then the J-th column of A*P was the
            the K-th column of A.
            </pre>
            </param>
            <param name="tau">
            <pre>
            Dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0: successful exit.
            &lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real/complex scalar, and v is a real/complex vector
            with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
            A(i+1:m,i), and tau in TAU(i).
            </pre>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGEQP3</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.QROrthogonalMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q<sup>T</sup> * C       C * Q<sup>T</sup>
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <pre>
            = 'L': apply Q or Q<sup>T</sup> from the Left;
            = 'R': apply Q or Q<sup>T</sup> from the Right.
            </pre>
            </param>
            <param name="trans">
            <pre>
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q<sup>T</sup>.
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the matrix C. M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix C. N >= 0.
            </pre>
            </param>
            <param name="k">
            <pre>
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </pre>
            <pre>
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </pre>
            </param>
            <param name="tau">
            <pre>
            Dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.
            </pre>
            </param>
            <param name="c">
            <pre>
            Dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q<sup>T</sup>*C or C*Q<sup>T</sup> or C*Q.
            </pre>
            <pre>
            The leading dimension of the array C. LDC >= max(1,M).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            . . H(k)
            as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DORMQR</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a real symmetric matrix A using
            the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The form of the
            factorization is
               A = U*D*U<sup>T</sup>  or  A = L*D*L<sup>T</sup>
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is symmetric and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            If UPLO = 'U', then A = U*D*U<sup>T</sup>, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L<sup>T</sup>, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DSYTRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricSolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a real
            symmetric matrix A using the factorization A = U*D*U<sup>T</sup> or
            A = L*D*L<sup>T</sup> computed by DSYTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DSYTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real symmetric indefinite matrix
            A using the factorization A = U*D*U<sup>T</sup> or A = L*D*L<sup>T</sup> computed by
            DSYTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by DSYTRF.
            On exit, if INFO = 0, the (symmetric) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DSYTRI</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Single,System.Single@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric matrix A using the factorization
            A = U*D*U<sup>T</sup> or A = L*D*L<sup>T</sup> computed by DSYTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
            </param>
            <param name="anorm">
            <pre>
            The 1-norm of the original matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DSYCON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularInvert(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real upper or lower triangular
            matrix A.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
            </param>
            <param name="diag">
            <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                 matrix is singular and its inverse can not be computed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            This is the Level 3 BLAS version of the algorithm.
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B  or  A<sup>T</sup> * X = B,
            where A is a triangular matrix of order N, and B is an N-by-NRHS
            matrix.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
            </param>
            <param name="trans">
            <pre>
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose = Transpose)
            </pre>
            </param>
            <param name="diag">
            <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, the i-th diagonal element of A is zero,
                 indicating that the matrix is singular and the solutions
                 X have not been computed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            A check is made to verify that A is nonsingular.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DTRTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.TriangularEstimateCondition(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{System.Single},System.Single@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a
            triangular matrix A, in either the 1-norm or the infinity-norm.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
            </param>
            <param name="storedTriangle">
            <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
            </param>
            <param name="diag">
            <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DTRCON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},System.Single,System.Single@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite matrix using the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPOTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup>, as computed by DPOTRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="anorm">
            <pre>
            The 1-norm (or infinity-norm) of the symmetric matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DPOCON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite matrix A.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup>.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The factorization has the form
               A = U<sup>T</sup> * U,  if UPLO = 'U', or
               A = L  * L<sup>T</sup>,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            This is the block version of the algorithm, calling Level 3 BLAS.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DPOTRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskyInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real symmetric positive definite
            matrix A using the Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup>
            computed by DPOTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup>, as computed by
            DPOTRF.
            On exit, the upper or lower triangle of the (symmetric)
            inverse of A, overwriting the input factor U or L.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DPOTRI</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.CholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite matrix A using the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPOTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup>, as computed by DPOTRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DPOTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.SingularValueDecompose(System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.</para>
            </summary>
            <param name="jobz">
            <pre>
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V<sup>T</sup> are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V<sup>T</sup> are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    on the array A and all rows of V<sup>T</sup> are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V<sup>T</sup> are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V<sup>T</sup> are computed.
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the input matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the input matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M >= N;
                            A is overwritten with the first M rows
                            of V<sup>T</sup> (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,M).
            </pre>
            </param>
            <param name="s">
            <pre>
            Dimension (min(M,N))
            The singular values of A, sorted so that S(i) >= S(i+1).
            </pre>
            </param>
            <param name="u">
            <pre>
            Dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
            orthogonal matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
            </pre>
            <pre>
            The leading dimension of the array U.  LDU >= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU >= M.
            </pre>
            </param>
            <param name="vt">
            <pre>
            Dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            N-by-N orthogonal matrix V<sup>T</sup>;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V<sup>T</sup> (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
            </pre>
            <pre>
            The leading dimension of the array VT.  LDVT >= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            if JOBZ = 'S', LDVT >= min(M,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  DBDSDC did not converge, updating process failed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                 A = U * SIGMA * transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V<sup>T</sup>, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a real m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>?GBTRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B  or  A<sup>T</sup> * X = B
            with a general band matrix A using the LU factorization computed
            by DGBTRF.</para>
            </summary>
            <param name="trans">
            <pre>
            Specifies the form of the system of equations.
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup>* X = B  (Transpose)
            = 'C':  A<sup>T</sup>* X = B  (Conjugate transpose = Transpose)
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by DGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DGBTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandLUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Int32},System.Single,System.Single@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a real
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by DGBTRF.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by DGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="anorm">
            <pre>
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGBCON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandTriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B  or  A<sup>T</sup> * X = B,
            where A is a triangular band matrix of order N, and B is an
            N-by NRHS matrix.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
            </param>
            <param name="trans">
            <pre>
            Specifies the form the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose = Transpose)
            </pre>
            </param>
            <param name="diag">
            <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the i-th diagonal element of A is zero,
                  indicating that the matrix is singular and the
                  solutions X have not been computed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            A check is made to verify that A is nonsingular.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DTBTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite band matrix A.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            On entry, the upper or lower triangle of the symmetric band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band
            matrix A, in the same storage format as A.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The factorization has the form
               A = U<sup>T</sup> * U,  if UPLO = 'U', or
               A = L  * L<sup>T</sup>,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DPBTRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite band matrix A using the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPBTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>?PBTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.BandCholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{System.Single},System.Single,System.Single@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite band matrix using the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPBTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="aNorm">
            <pre>
            The 1-norm (or infinity-norm) of the symmetric band matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DPBCON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.SymmetricEigenvalueDecompose(System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            real symmetric matrix A.</para>
            </summary>
            <param name="jobz">
            <pre>
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </pre>
            </param>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="w">
            <pre>
            Dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the sub-matrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            Because of large use of BLAS of level 3, DSYEVD needs N**2 more
            workspace than DSYEVX.
            </pre>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee \n
             Modified description of INFO. Sven, 16 Feb 05. \n
            </para>
            <para>This method corresponds to the LAPACK routine <c>DSYEVD</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapackOfSingle.EigenvalueDecompose(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single},System.Int32@)">
            <summary>
            <para>
            Computes for an N-by-N real non-symmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
            </summary>
            <param name="jobvl">
            <pre>
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.
            </pre>
            </param>
            <param name="jobvr">
            <pre>
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A. N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="wr">
            <pre>
            Dimension (N)
            </pre>
            </param>
            <param name="wi">
            <pre>
            Dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.
            </pre>
            </param>
            <param name="vl">
            <pre>
            Dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).
            </pre>
            <pre>
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.
            </pre>
            </param>
            <param name="vr">
            <pre>
            Dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).
            </pre>
            <pre>
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.
            </pre>
            </param>
            <param name="info">
            <pre>
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**T * A = lambda(j) * u(j)**T
            where u(j)**T denotes the transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>?GEEV</c>.</para>
            </remarks>
        </member>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle">
            <summary>
            Contains the managed implementation of the sparse BLAS routines.
            </summary>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.Name">
            <summary>
            Gets the name of the implementation.
            </summary>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.Platform">
            <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.#ctor">
            <summary>
            Constructs a new <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle"/> object.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Single,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Single[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            Multiplies a matrix in compressed sparse column format with a dense matrix.
            </summary>
            <param name="transA"></param>
            <param name="m">The number of rows in the matrix A.</param>
            <param name="n">The number of columns in the matrix C.</param>
            <param name="k">The number of columns in the matric A.</param>
            <param name="alpha">The multiplier for the matrix product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that specifies the structural properties
            of the matrix A</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies whether the
            upper or lower triangular part of the matrix is used.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that specifies whether the
            diagonal of the sparse matrix contains all 1's.</param>
            <param name="a">A <see cref="T:System.Double"/> array that contains the values of the elements of the
            matrix A.</param>
            <param name="aRows">An integer array that contains the row indexes corresponding to the values in
            <paramref name="a"/>.</param>
            <param name="aPointerB">An integer array that specifies the index into <paramref name="a"/> and
            <paramref name="aRows"/> of the first element of each column.</param>
            <param name="aPointerE">An integer array that specifies the index into <paramref name="a"/> and
            <paramref name="aRows"/> past the last element of each column.</param>
            <param name="b">A <see cref="T:System.Double"/> array that contains the components of the dense matrix.</param>
            <param name="beta">Multiplier for the matrix C.</param>
            <param name="c">A <see cref="T:System.Double"/> array that contains the components of the (dense) result matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Single,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Single[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{System.Single})">
            <inheritdoc/>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Single,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Single[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{System.Single},System.Single,Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Multiplies a dense vector by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that
            specifies the structure of the matrix.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/>
            value that specifies whether the matrix is upper or lower triangular.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/>
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a"/>.</param>
            <param name="aPointerB">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="aPointerE">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Single,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Single[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Solves for a dense vector for a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that
            specifies the structure of the matrix.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/>
            value that specifies whether the matrix is upper or lower triangular.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/>
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a"/>.</param>
            <param name="aPointerB">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="aPointerE">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{System.Single}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Multiplies a matrix in compressed sparse column format with a dense matrix.
            </summary>
            <param name="transA"></param>
            <param name="m">The number of rows in the matrix A.</param>
            <param name="n">The number of columns in the matrix C.</param>
            <param name="k">The number of columns in the matric A.</param>
            <param name="alpha">The multiplier for the matrix product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that specifies the structural properties
            of the matrix A</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies whether the
            upper or lower triangular part of the matrix is used.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that specifies whether the
            diagonal of the sparse matrix contains all 1's.</param>
            <param name="a">A <see cref="T:System.Double"/> array that contains the values of the elements of the
            matrix A.</param>
            <param name="aRows">An integer array that contains the row indexes corresponding to the values in
            <paramref name="a"/>.</param>
            <param name="aPointerB">An integer array that specifies the index into <paramref name="a"/> and
            <paramref name="aRows"/> of the first element of each column.</param>
            <param name="aPointerE">An integer array that specifies the index into <paramref name="a"/> and
            <paramref name="aRows"/> past the last element of each column.</param>
            <param name="b">A <see cref="T:System.Double"/> array that contains the components of the dense matrix.</param>
            <param name="beta">Multiplier for the matrix C.</param>
            <param name="c">A <see cref="T:System.Double"/> array that contains the components of the (dense) result matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{System.Single}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <inheritdoc/>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{System.Single}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Mathematics.Complex{System.Single},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Multiplies a dense vector by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that
            specifies the structure of the matrix.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/>
            value that specifies whether the matrix is upper or lower triangular.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/>
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a"/>.</param>
            <param name="aPointerB">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="aPointerE">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperationsOfSingle.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{System.Single}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Solves for a dense vector for a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that
            specifies the structure of the matrix.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/>
            value that specifies whether the matrix is upper or lower triangular.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/>
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a"/>.</param>
            <param name="aPointerB">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="aPointerE">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle">
            <summary>
            Summary description for SparseBlas.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.DotProduct(System.Int32,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Returns the dot product of a sparse and a dense vector.
            </summary>
            <param name="n">The number of nonzero elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="indx">Integer array of component indices.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.ScaleAndAddInPlace(System.Int32,System.Single,Extreme.Collections.Array1D{System.Single},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Evaluates a vector plus the product of a scalar and a sparse vector.
            </summary>
            <param name="n">The number of nonzero elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="indx">Integer array of component indices.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Single,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Single[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{System.Single},System.Single,Extreme.Collections.Array2D{System.Single})">
            <summary>
            Multiplies a dense matrix by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="n">The number of columns in the matrix <paramref name="c"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-matrix product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that
            specifies the structure of the matrix.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/>
            value that specifies whether the matrix is upper or lower triangular.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/>
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a"/>.</param>
            <param name="aPointerB">Integer array of length <paramref name="n"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="aPointerE">Integer array of length <paramref name="n"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="b">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="b"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="c"/>.
            </param>
            <param name="c">A reference to a one-dimensional array
            containing the elements of the matrix <paramref name="c"/>.
            The elements of <paramref name="c"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.DotProduct(System.Int32,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Returns the dot product of a sparse and a dense vector.
            </summary>
            <param name="n">The number of nonzero elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="indx">Integer array of component indices.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.SparseLinearAlgebraOperationsOfSingle.ScaleAndAddInPlace(System.Int32,Extreme.Mathematics.Complex{System.Single},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Evaluates a vector plus the product of a scalar and a sparse vector.
            </summary>
            <param name="n">The number of nonzero elements in the vectors
            <paramref name="x"/> and <paramref name="y"/>.</param>
            <param name="alpha">The scalar value used to multiply
            the elements of <paramref name="x"/>.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.
            </param>
            <param name="indx">Integer array of component indices.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.</param>
        </member>
        <member name="M:Extreme.Mathematics.ElementaryF.Pow(System.Single,System.Int32)">
            <summary>
            Returns a number raised to an integer power.
            </summary>
            <param name="x">A real number.</param>
            <param name="n">An integer exponent.</param>
            <returns>The real number raised to the specified exponent.
            </returns>
            <remarks>
            <para>Raising a number to an integer power is orders of
            magnitude faster than raising a number to a real power.
            If you know the exponent is an integer, use this method instead
            of the <see cref="M:System.Math.Pow(System.Double,System.Double)"/> method of
            <see cref="T:System.Math"/>.</para>
            </remarks>
        </member>
        <member name="T:Extreme.Mathematics.SingleConstants">
            <summary>
            Contains various mathematical constants in single precision.
            </summary>
            <remarks>
            <para>Some real numbers return time and again in
            mathematical calculations. This class provides pre-calculated
            values for many of these numbers:
            <list type="bullet">
            <listItem>Square roots.</listItem>
            <listItem>Logarithms and exponentials.</listItem>
            <listItem>&#960; and its variations: common multiples, square
            roots and integer powers.</listItem>
            <listItem>Various other mathematical constants with more
            complicated definitions.</listItem>
            </list></para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.EulersConstant">
            <summary>
            Represents Euler's constant.
            </summary>
            <remarks>
            <para>Euler's constant is defined as
            </para>
            <para><center><IMG src ="images/constantsEulerGamma.gif" height ="48" width ="136" baseline ="20"/></center></para>
            <para>The value of this field is 0.5772156649015328606065120900824.</para></remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.GoldenRatio">
            <summary>
            Represents the Golden Ratio.
            </summary>
            <remarks>
            <para>
            A line segment can be divided into two pieces in such
            a way that the ratio between the lengths of the whole
            and the largest piece equals the ratio of the lengths
            of the largest piece and the smallest piece. This
            ratio is called the Golden Ratio. Its value is equal to
            </para>
            <para><center><IMG src ="images\constantsGoldenRatio.gif" height ="45" width ="70" baseline ="16"/></center></para>
            <para>The value of this field is 1.61803398874989484820458683436.</para></remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.E">
            <summary>
            Represents the base for the natural logarithm, <i>e</i>.
            </summary>
            <remarks>
            <para>The value of this field is 2.71828182845904523536028747135266249.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Pi">
            <summary>
            Represents pi, the ratio of the circumference of a cirlce
            to its diameter.
            </summary>
            <remarks>
            <para>The value of this field is 3.141592653589793238462643383279502884.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.TwoPi">
            <summary>
            Represents two times <see cref="F:Extreme.Mathematics.SingleConstants.Pi"/>.
            </summary>
            <remarks>
            <para>The value of this field is 6.283185307179586476925286766558.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.PiOverTwo">
            <summary>
            Represents 0.5 times <see cref="F:Extreme.Mathematics.SingleConstants.Pi"/>.
            </summary>
            <remarks>
            <para>The value of this field is 1.570796326794896619231321691639751.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.PiOverFour">
            <summary>
            Represents 0.25 times <see cref="F:Extreme.Mathematics.SingleConstants.Pi"/>.
            </summary>
            <remarks>
            <para>The value of this field is 0.785398163397448309615660845819876.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.PiSquared">
            <summary>
            Represents <see cref="F:Extreme.Mathematics.SingleConstants.Pi"/> squared.
            </summary>
            <remarks>
            <para>The value of this field is 9.869604401089358618834490999873.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.SqrtPi">
            <summary>
            Represents the square root of <see cref="F:Extreme.Mathematics.SingleConstants.Pi"/>.
            </summary>
            <remarks>
            <para>The value of this field is 1.772453850905516027298167483341145.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.OneOverSqrtPi">
            <summary>
            Represents the inverse of the square root of <see cref="F:Extreme.Mathematics.SingleConstants.Pi"/>.
            </summary>
            <remarks>
            <para>The value of this field is 0.56418958354775628694807945156082.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.SqrtTwoPi">
            <summary>
            Represents the square root of two times <see cref="F:Extreme.Mathematics.SingleConstants.Pi"/>.
            </summary>
            <remarks>
            <para>The value of this field is 2.506628274631000502415765284811045.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.OneOverSqrtTwoPi">
            <summary>
            Represents the inverse of the square root of two times <see cref="F:Extreme.Mathematics.SingleConstants.Pi"/>.
            </summary>
            <remarks>
            <para>The value of this field is 0.39894228040143267793994605993439.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.LogTwoPi">
            <summary>
            Represents the natural logarithm of two times <see cref="F:Extreme.Mathematics.SingleConstants.Pi"/>.
            </summary>
            <remarks>
            <para>The value of this field is 1.837877066409345483560659472811235279723.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Degree">
            <summary>
            Represents the size of a 1 degree angle in radians.
            </summary>
            <remarks>
            <para>The value of this field is 0.0174532925199432957692.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Catalan">
            <summary>
            Represents Catalan's constant.
            </summary>
            <remarks>
            <para>The value of this field is 0.915965594177219015055.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Feigenbaum">
            <summary>
            Represents Feigenbaum's constant.
            </summary>
            <remarks>
            <para>The value of this field is 4.66920160910299067185.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Sqrt2">
            <summary>
            Represents the square root of 2.
            </summary>
            <remarks>
            <para>The value of this field is 1.414213562373095048801688724209698.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Sqrt3">
            <summary>
            Represents the square root of 3.
            </summary>
            <remarks>
            <para>The value of this field is 1.732050807568877293527446341505872.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Sqrt5">
            <summary>
            Represents the square root of 5.
            </summary>
            <remarks>
            <para>The value of this field is 2.236067977499789696409173668731276.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Sqrt7">
            <summary>
            Represents the square root of 7.
            </summary>
            <remarks>
            <para>The value of this field is 2.645751311064590590501615753639260.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Sqrt17">
            <summary>
            Represents the square root of 17.
            </summary>
            <remarks>
            <para>The value of this field is 4.1231056256176605498214098559741.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Log10">
            <summary>
            Represents the natural logarithm of 10.
            </summary>
            <remarks>
            <para>The value of this field is 2.302585092994045684017991454684364.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Log10E">
            <summary>
            Represents the base 10 logarithm of <see cref="F:Extreme.Mathematics.SingleConstants.E"/>.
            </summary>
            <remarks>
            <para>The value of this field is 2.302585092994045684017991454684364.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.InvLog10">
            <summary>
            Represents the base-10 logarithm of <see cref="F:Extreme.Mathematics.SingleConstants.E"/>.
            </summary>
            <remarks>
            <para>The value of this field is 0.434294481903251827651128918916605.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Log2">
            <summary>
            Represents the natural logarithm of 2.
            </summary>
            <remarks>
            <para>The value of this field is 0.6931471805599453094172321214581765681.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Log3">
            <summary>
            Represents the natural logarithm of 3.
            </summary>
            <remarks>
            <para>The value of this field is 1.0986122886681096913952452369225.</para>
            </remarks>
        </member>
        <member name="F:Extreme.Mathematics.SingleConstants.Log17">
            <summary>
            Represents the natural logarithm of 17.
            </summary>
            <remarks>
            <para>The value of this field is 2.8332133440562160802495346178731.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.SinglePrecisionImplementations.RegisterSinglePrecisionProvider(Extreme.ProviderManager,System.Boolean)">
            <summary>
            Registers the provider of generic implementations of linear
            algebra functions.
            </summary>
            <param name="providerManager"></param>
            <param name="native">Indicates whether native providers should
            be loaded.</param>
        </member>
        <member name="T:Extreme.Mathematics.ManagedCoreProviderOfSingle">
            <summary>
            Encapsulates the currently active BLAS implementation.
            </summary>
            <remarks>
            <para>
            The classes in the <see cref="N:Extreme.Mathematics.LinearAlgebra"/>
            namespace use the standard Basic Linear Algebra Subroutines
            (BLAS) whenever possible. The Extreme Optimization Mathematics Library
            for .NET provides two implementations. One is in 100% managed code.
            The other calls a native, highly optimized, processor-specific kernel.</para>
            <para>This class exposes properties that allow
            you to specify the BLAS objects that are to be used by
            the classes in this namespace.</para>
            <para>You can select the managed implementation by calling 
            the <see cref="M:Extreme.Mathematics.CoreImplementations`1.UseManaged"/> method. 
            To select the native implementation, call the <see cref="M:Extreme.Mathematics.CoreImplementations`1.UseNative"/> method.
            The native kernel is used by default. This is the fastest option,
            especially for larger matrices, but also has a larger memory footprint.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.ManagedCoreProviderOfSingle.GetAllImplementations``1">
            <summary>
            Enumerates all implementations of the specified type that are available from
            the provider.
            </summary>
            <typeparam name="T">The type of the implementation.</typeparam>
            <returns>A sequence of implementation objects.</returns>
        </member>
        <member name="M:Extreme.Mathematics.ManagedCoreProviderOfSingle.#ctor">
            <summary>
            Constructs a new <see cref="T:Extreme.Mathematics.ManagedCoreProvider"/>.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.ManagedCoreProviderOfSingle.WithMaxDegreeOfParallelism(System.Int32)">
            <summary>
            Returns a provider with the specified maximum degree of parallelism.
            </summary>
            <param name="maxDegreeOfParallelism">The maximum degree of parallelism.</param>
            <returns>A <see cref="T:Extreme.Mathematics.ManagedCoreProvider"/> with the specified
            maximum degree of parallelism.</returns>
        </member>
        <member name="P:Extreme.Mathematics.ManagedCoreProviderOfSingle.LinearAlgebraOperations">
            <summary>
            Gets the implementation of the 
            BLAS for float-precision arguments.
            </summary>
            <remarks>
            <para>The default value of this property is
            an instance of <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLinearAlgebraOperations"/>.
            </para>
            </remarks>
            <value>A class that inherits from <see cref="P:Extreme.Mathematics.ManagedCoreProviderOfSingle.LinearAlgebraOperations"/>.</value>
        </member>
        <member name="P:Extreme.Mathematics.ManagedCoreProviderOfSingle.DecompositionOperations">
            <summary>
            Gets the LAPACK implementation
            for float-precision arguments.
            </summary>
            <remarks>
            <para>The default value of this property is
            an instance of <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedLapack"/>.
            </para>
            </remarks>
            <value>A class that inherits from <see cref="T:Extreme.Mathematics.Implementation.DecompositionOperations`2"/>.</value>
        </member>
        <member name="P:Extreme.Mathematics.ManagedCoreProviderOfSingle.SparseLinearAlgebra">
            <summary>
            Gets the implementation of the sparse
            BLAS for float-precision arguments.
            </summary>
            <remarks>
            <para>The default value of this property is
            an instance of <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperations"/>.
            </para>
            </remarks>
            <value>A class that inherits from <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.SparseLinearAlgebraOperations"/>.</value>
        </member>
        <member name="P:Extreme.Mathematics.ManagedCoreProviderOfSingle.Fft">
            <summary>
            Gets or sets the current FFT provider implementation
            for float-precision arguments.
            </summary>
            <remarks>
            <para>The default value of this property is
            an instance of <see cref="T:Extreme.Mathematics.SignalProcessing.ManagedFftProvider"/>.
            </para>
            </remarks>
            <value>A class that inherits from <see cref="T:Extreme.Mathematics.SignalProcessing.FftProvider`1"/>.</value>
        </member>
        <member name="P:Extreme.Mathematics.ManagedCoreProviderOfSingle.ArrayFunctions">
            <inheritdoc/>
        </member>
        <member name="P:Extreme.Mathematics.ManagedCoreProviderOfSingle.ComplexArrayFunctions">
            <inheritdoc/>
        </member>
        <member name="P:Extreme.Mathematics.ManagedCoreProviderOfSingle.HasSharedDegreeOfParallelism">
            <summary>
            Indicates whether the degree of parallelism is a property that is shared
            across instances.
            </summary>
        </member>
        <member name="T:Extreme.Mathematics.SignalProcessing.Filter">
            <summary>
            Represents a digital filter.
            </summary>
        </member>
        <member name="T:Extreme.Mathematics.SignalProcessing.ManagedFftOfSingle">
            <summary>
            Represents a managed FFT implementation.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftOfSingle.#ctor(Extreme.Mathematics.SignalProcessing.FftDomain,System.Int32)">
            <summary>
            Constructs a new managed FFT implementation.
            </summary>
            <param name="domain">An <see cref="T:Extreme.Mathematics.SignalProcessing.FftDomain"/> value that specifies whether the forward transform
            is of a real or a complex signal.</param>
            <param name="length">The length of the transform.</param>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftOfSingle.Commit">
            <summary>
            Commits the implementation.
            </summary>
            <remarks>
            <para>
            This method commits the implementation to its current parameters.
            Inheritors can override this method to compute auxiliary values such as twiddle factors.
            Inheritors should always call the base method. Otherwise, loss of resources may result.
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftOfSingle.ForwardTransform(Extreme.Collections.ArraySlice{System.Single},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the discrete Fourier transform of a real signal.
            </summary>
            <param name="input">A <see cref="T:System.Single"/> array containing the input signal.</param>
            <param name="output">A complex number array to hold the transformed signal.</param>
            <remarks>
            <para>
            The output is stored in a compact format to take advantage of the symmetry properties of a real Fourier transform.
            Specifically, <paramref name="output"/> contains only the first <em>n</em>/2+1 terms of the transformed signal.
            Use the <see cref="T:Extreme.Mathematics.SignalProcessing.ComplexConjugateSignalVector`1"/> class to obtain a complex vector that represents the
            complete signal.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept real input.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="input"/> is <see langword="null"/>.
            <para>-or-</para>
            <para><paramref name="output"/> is <see langword="null"/>.</para>
            </exception>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftOfSingle.ForwardTransform(Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the discrete Fourier transform of a complex signal.
            </summary>
            <param name="input">A complex number array containing the input signal.</param>
            <param name="output">A complex number array to hold the transformed signal.</param>
            <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept complex input.
            <para>-or-</para>
            <para><paramref name="input"/> and <paramref name="output"/> are the same, but the Fourier transform implementation is not configured
            to handle in-place transforms.</para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="input"/> is <see langword="null"/>.
            <para>-or-</para>
            <para><paramref name="output"/> is <see langword="null"/>.</para>
            </exception>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftOfSingle.ForwardTransformInPlace(Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the discrete Fourier transform of a complex signal in place.
            </summary>
            <param name="input">On input, a complex number array containing the input signal.
            On return, the forward transform of the input.</param>
            <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept complex input.
            <para>-or-</para>
            <para>The Fourier transform implementation is not configured to handle in-place transforms.</para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="input"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftOfSingle.BackwardTransform(Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{System.Single})">
            <summary>
            Computes the discrete Fourier transform of a real signal.
            </summary>
            <param name="input">A <see cref="T:System.Single"/> array containing the input signal.</param>
            <param name="output">A complex number array to hold the transformed signal.</param>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftOfSingle.BackwardTransform(Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the discrete Fourier transform of a complex signal.
            </summary>
            <param name="input">A complex number array containing the input signal.</param>
            <param name="output">A complex number array to hold the transformed signal.</param>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:Extreme.Mathematics.SignalProcessing.FftDomain"/> of the transform is not complex.
            <para>-or-</para>
            <para>The input and output are the same, but the transform was not set up for in place calculation</para>
            </exception>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftOfSingle.BackwardTransformInPlace(Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the inverse discrete Fourier transform of a complex signal in place.
            </summary>
            <param name="input">On input, a complex number array containing the input signal.
            On return, the inverse transform of the input.</param>
        </member>
        <member name="T:Extreme.Mathematics.SignalProcessing.ManagedFft2DOfSingle">
            <summary>
            Represents a managed two-dimensional FFT implementation.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFft2DOfSingle.#ctor(Extreme.Mathematics.SignalProcessing.FftProvider{System.Single},Extreme.Mathematics.SignalProcessing.FftDomain,System.Int32,System.Int32)">
            <summary>
            Constructs a new managed FFT implementation.
            </summary>
            <param name="provider">The provider to use for 1D transforms.</param>
            <param name="domain">An <see cref="T:Extreme.Mathematics.SignalProcessing.FftDomain"/> value that specifies whether the forward transform
            is of a real or a complex signal.</param>
            <param name="rowCount">The number of rows.</param>
            <param name="columnCount">The number of columns.</param>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFft2DOfSingle.Commit">
            <summary>
            Commits the implementation.
            </summary>
            <remarks>
            <para>
            This method commits the implementation to its current parameters.
            Inheritors can override this method to compute auxiliary values such as twiddle factors.
            Inheritors should always call the base method. Otherwise, loss of resources may result.
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFft2DOfSingle.ForwardTransform(Extreme.Collections.Array2D{System.Single},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the discrete Fourier transform of a real signal.
            </summary>
            <param name="input">A <see cref="T:System.Single"/> array containing the input signal.</param>
            <param name="output">A complex number array to hold the transformed signal.</param>
            <remarks>
            <para>
            The output is stored in a compact format to take advantage of the symmetry properties of a real Fourier transform.
            Specifically, <paramref name="output"/> contains only the first <em>n</em>/2+1 terms of the transformed signal.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept real input.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="input"/> is <see langword="null"/>.
            <para>-or-</para>
            <para><paramref name="output"/> is <see langword="null"/>.</para>
            </exception>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFft2DOfSingle.ForwardTransform(Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the discrete Fourier transform of a complex signal.
            </summary>
            <param name="input">A complex number array containing the input signal.</param>
            <param name="output">A complex number array to hold the transformed signal.</param>
            <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept complex input.
            <para>-or-</para>
            <para><paramref name="input"/> and <paramref name="output"/> are the same, but the Fourier transform implementation is not configured
            to handle in-place transforms.</para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="input"/> is <see langword="null"/>.
            <para>-or-</para>
            <para><paramref name="output"/> is <see langword="null"/>.</para>
            </exception>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFft2DOfSingle.ForwardTransformInPlace(Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the discrete Fourier transform of a complex signal in place.
            </summary>
            <param name="input">On input, a complex number array containing the input signal.
            On return, the forward transform of the input.</param>
            <exception cref="T:System.InvalidOperationException">The Fourier transform implementation is not configured
            to accept complex input.
            <para>-or-</para>
            <para>The Fourier transform implementation is not configured to handle in-place transforms.</para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="input"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFft2DOfSingle.BackwardTransform(Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{System.Single})">
            <summary>
            Computes the discrete Fourier transform of a real signal.
            </summary>
            <param name="input">A <see cref="T:System.Single"/> array containing the input signal.</param>
            <param name="output">A complex number array to hold the transformed signal.</param>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFft2DOfSingle.BackwardTransform(Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the discrete Fourier transform of a complex signal.
            </summary>
            <param name="input">A complex number array containing the input signal.</param>
            <param name="output">A complex number array to hold the transformed signal.</param>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:Extreme.Mathematics.SignalProcessing.FftDomain"/> of the transform is not complex.
            <para>-or-</para>
            <para>The input and output are the same, but the transform was not set up for in place calculation</para>
            </exception>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFft2DOfSingle.BackwardTransformInPlace(Extreme.Collections.Array2D{Extreme.Mathematics.Complex{System.Single}})">
            <summary>
            Computes the inverse discrete Fourier transform of a complex signal in place.
            </summary>
            <param name="input">On input, a complex number array containing the input signal.
            On return, the inverse transform of the input.</param>
        </member>
        <member name="T:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle">
            <summary>
            Represents the provider of managed FFT implementations.
            </summary>
        </member>
        <member name="P:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.Name">
            <inheritdoc/>
        </member>
        <member name="P:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.Platform">
            <inheritdoc/>
        </member>
        <member name="P:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.RealManagedThresholdLength">
            <summary>
            Gets or sets the threshold for switching between the managed and native FFT providers.
            </summary>
            <remarks>
            <para>
            Real transforms of length less than or equal to <see cref="P:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.RealManagedThresholdLength"/> are always
            performed using the managed provider. Real transforms of length greater than <see cref="P:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.RealManagedThresholdLength"/>
            are performed using a native provider, if one is available.
            </para>
            <para>The default value for the threshold is 64.</para>
            </remarks>
        </member>
        <member name="P:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.ComplexManagedThresholdLength">
            <summary>
            Gets or sets the threshold for switching between the managed and native FFT providers.
            </summary>
            <remarks>
            <para>
            Complex transforms of length less than or equal to <see cref="P:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.ComplexManagedThresholdLength"/> are always
            performed using the managed provider. Complex transforms of length greater than <see cref="P:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.ComplexManagedThresholdLength"/>
            are performed using a native provider, if one is available.
            </para>
            <para>The default value for the threshold is 32.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.Create1DRealFft(System.Int32)">
            <summary>
            Creates a Fast Fourier Transformer for one-dimensional real data.
            </summary>
            <param name="length">The length of the data vectors.</param>
            <returns>An <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> object that can be used to compute an FFT of length equal to <paramref name="length"/>.</returns>
            <remarks>
            <para>
            <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> objects may use unmanaged memory and other resources. You should always call the dispose
            method before the last reference to an <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> object is released.
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.Create1DComplexFft(System.Int32)">
            <summary>
            Creates a Fast Fourier Transformer for one-dimensional complex data.
            </summary>
            <param name="length">The length of the data vectors.</param>
            <returns>An <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> object that can be used to compute an FFT of length equal to <paramref name="length"/>.</returns>
            <remarks>
            <para>
            <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> objects may use unmanaged memory and other resources. You should always call the dispose
            method before the last reference to an <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> object is released.
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.Create2DRealFft(System.Int32,System.Int32)">
            <summary>
            Creates a Fast Fourier Transformer for two-dimensional real data.
            </summary>
            <param name="rowCount">The number of rows.</param>
            <param name="columnCount">The number of columns.</param>
            <returns>An <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> object that can be used to compute an FFT of 
            dimensions equal to <paramref name="rowCount"/> by <paramref name="columnCount"/>.</returns>
            <remarks>
            <para>
            <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> objects may use unmanaged memory and other resources. You should always call the dispose
            method before the last reference to an <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> object is released.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The total number of elements is greater than 2<sup>31</sup>-1.
            </exception>
        </member>
        <member name="M:Extreme.Mathematics.SignalProcessing.ManagedFftProviderOfSingle.Create2DComplexFft(System.Int32,System.Int32)">
            <summary>
            Creates a Fast Fourier Transformer for two-dimensional complex data.
            </summary>
            <param name="rowCount">The number of rows.</param>
            <param name="columnCount">The number of columns.</param>
            <returns>An <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> object that can be used to compute an FFT of 
            dimensions equal to <paramref name="rowCount"/> by <paramref name="columnCount"/>.</returns>
            <remarks>
            <para>
            <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> objects may use unmanaged memory and other resources. You should always call the dispose
            method before the last reference to an <see cref="T:Extreme.Mathematics.SignalProcessing.Fft`1"/> object is released.
            </para>
            </remarks>
        </member>
    </members>
</doc>
